Description: .c files for zmq/core directory
 pyzmq (13.1.0-1~bpo70~dst+1) wheezy-saltstack; urgency=low
 .
   * Rebuild for wheezy-saltstack.
Author: Joe Healy <joehealy@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- /dev/null
+++ pyzmq-13.1.0/zmq/core/constants.c
@@ -0,0 +1,3654 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core__constants
+#define __PYX_HAVE_API__zmq__core__constants
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "constants.pyx",
+};
+
+/*--- Type declarations ---*/
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+
+#if PY_MAJOR_VERSION >= 3
+static CYTHON_INLINE PyObject* __Pyx_PyDict_Keys(PyObject* d); /*proto*/
+#else
+#define __Pyx_PyDict_Keys(d) PyDict_Keys(d)
+#endif
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
+    PyListObject* L = (PyListObject*) list;
+    Py_ssize_t len = Py_SIZE(list);
+    if (likely(L->allocated > len)) {
+        Py_INCREF(x);
+        PyList_SET_ITEM(list, len, x);
+        Py_SIZE(list) = len+1;
+        return 0;
+    }
+    return PyList_Append(list, x);
+}
+#else
+#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
+#endif
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+
+static PyObject* __Pyx_Globals(void); /*proto*/
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static int __Pyx_check_binary_version(void);
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'zmq.core.constants' */
+#define __Pyx_MODULE_NAME "zmq.core.constants"
+int __pyx_module_is_main_zmq__core__constants = 0;
+
+/* Implementation of 'zmq.core.constants' */
+static char __pyx_k_1[] = "0MQ Constants.";
+static char __pyx_k_2[] = "DELAY_ATTACH_ON_CONNECT";
+static char __pyx_k_3[] = "EVENT_CONNECT_DELAYED";
+static char __pyx_k_4[] = "EVENT_CONNECT_RETRIED";
+static char __pyx_k___[] = "_";
+static char __pyx_k__FD[] = "FD";
+static char __pyx_k__HWM[] = "HWM";
+static char __pyx_k__PUB[] = "PUB";
+static char __pyx_k__REP[] = "REP";
+static char __pyx_k__REQ[] = "REQ";
+static char __pyx_k__SUB[] = "SUB";
+static char __pyx_k__key[] = "key";
+static char __pyx_k__EFSM[] = "EFSM";
+static char __pyx_k__MORE[] = "MORE";
+static char __pyx_k__PAIR[] = "PAIR";
+static char __pyx_k__PULL[] = "PULL";
+static char __pyx_k__PUSH[] = "PUSH";
+static char __pyx_k__RATE[] = "RATE";
+static char __pyx_k__SWAP[] = "SWAP";
+static char __pyx_k__TYPE[] = "TYPE";
+static char __pyx_k__XPUB[] = "XPUB";
+static char __pyx_k__XREP[] = "XREP";
+static char __pyx_k__XREQ[] = "XREQ";
+static char __pyx_k__XSUB[] = "XSUB";
+static char __pyx_k__keys[] = "keys";
+static char __pyx_k__ETERM[] = "ETERM";
+static char __pyx_k__QUEUE[] = "QUEUE";
+static char __pyx_k__errno[] = "errno";
+static char __pyx_k__DEALER[] = "DEALER";
+static char __pyx_k__EAGAIN[] = "EAGAIN";
+static char __pyx_k__EFAULT[] = "EFAULT";
+static char __pyx_k__EINVAL[] = "EINVAL";
+static char __pyx_k__ENODEV[] = "ENODEV";
+static char __pyx_k__ENOMEM[] = "ENOMEM";
+static char __pyx_k__EVENTS[] = "EVENTS";
+static char __pyx_k__LINGER[] = "LINGER";
+static char __pyx_k__POLLIN[] = "POLLIN";
+static char __pyx_k__RCVBUF[] = "RCVBUF";
+static char __pyx_k__RCVHWM[] = "RCVHWM";
+static char __pyx_k__ROUTER[] = "ROUTER";
+static char __pyx_k__SNDBUF[] = "SNDBUF";
+static char __pyx_k__SNDHWM[] = "SNDHWM";
+static char __pyx_k___names[] = "_names";
+static char __pyx_k__BACKLOG[] = "BACKLOG";
+static char __pyx_k__ENOBUFS[] = "ENOBUFS";
+static char __pyx_k__ENOTSUP[] = "ENOTSUP";
+static char __pyx_k__NOBLOCK[] = "NOBLOCK";
+static char __pyx_k__POLLERR[] = "POLLERR";
+static char __pyx_k__POLLOUT[] = "POLLOUT";
+static char __pyx_k__RCVMORE[] = "RCVMORE";
+static char __pyx_k__SNDMORE[] = "SNDMORE";
+static char __pyx_k__VERSION[] = "VERSION";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k__AFFINITY[] = "AFFINITY";
+static char __pyx_k__DONTWAIT[] = "DONTWAIT";
+static char __pyx_k__EMSGSIZE[] = "EMSGSIZE";
+static char __pyx_k__EMTHREAD[] = "EMTHREAD";
+static char __pyx_k__ENETDOWN[] = "ENETDOWN";
+static char __pyx_k__ENOTCONN[] = "ENOTCONN";
+static char __pyx_k__ENOTSOCK[] = "ENOTSOCK";
+static char __pyx_k__IDENTITY[] = "IDENTITY";
+static char __pyx_k__IPV4ONLY[] = "IPV4ONLY";
+static char __pyx_k__RCVTIMEO[] = "RCVTIMEO";
+static char __pyx_k__SNDTIMEO[] = "SNDTIMEO";
+static char __pyx_k__STREAMER[] = "STREAMER";
+static char __pyx_k__UPSTREAM[] = "UPSTREAM";
+static char __pyx_k____dict__[] = "__dict__";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__ENETRESET[] = "ENETRESET";
+static char __pyx_k__ETIMEDOUT[] = "ETIMEDOUT";
+static char __pyx_k__FORWARDER[] = "FORWARDER";
+static char __pyx_k__SUBSCRIBE[] = "SUBSCRIBE";
+static char __pyx_k__DOWNSTREAM[] = "DOWNSTREAM";
+static char __pyx_k__EADDRINUSE[] = "EADDRINUSE";
+static char __pyx_k__ECONNRESET[] = "ECONNRESET";
+static char __pyx_k__IO_THREADS[] = "IO_THREADS";
+static char __pyx_k__MAXMSGSIZE[] = "MAXMSGSIZE";
+static char __pyx_k__MCAST_LOOP[] = "MCAST_LOOP";
+static char __pyx_k__ROUTER_RAW[] = "ROUTER_RAW";
+static char __pyx_k____import__[] = "__import__";
+static char __pyx_k___optionals[] = "_optionals";
+static char __pyx_k__startswith[] = "startswith";
+static char __pyx_k__EINPROGRESS[] = "EINPROGRESS";
+static char __pyx_k__ENETUNREACH[] = "ENETUNREACH";
+static char __pyx_k__MAX_SOCKETS[] = "MAX_SOCKETS";
+static char __pyx_k__UNSUBSCRIBE[] = "UNSUBSCRIBE";
+static char __pyx_k__EAFNOSUPPORT[] = "EAFNOSUPPORT";
+static char __pyx_k__ECONNABORTED[] = "ECONNABORTED";
+static char __pyx_k__ECONNREFUSED[] = "ECONNREFUSED";
+static char __pyx_k__EHOSTUNREACH[] = "EHOSTUNREACH";
+static char __pyx_k__EVENT_CLOSED[] = "EVENT_CLOSED";
+static char __pyx_k__RECOVERY_IVL[] = "RECOVERY_IVL";
+static char __pyx_k__XPUB_VERBOSE[] = "XPUB_VERBOSE";
+static char __pyx_k__EADDRNOTAVAIL[] = "EADDRNOTAVAIL";
+static char __pyx_k__LAST_ENDPOINT[] = "LAST_ENDPOINT";
+static char __pyx_k__RECONNECT_IVL[] = "RECONNECT_IVL";
+static char __pyx_k__TCP_KEEPALIVE[] = "TCP_KEEPALIVE";
+static char __pyx_k__ENOCOMPATPROTO[] = "ENOCOMPATPROTO";
+static char __pyx_k__EVENT_ACCEPTED[] = "EVENT_ACCEPTED";
+static char __pyx_k__MULTICAST_HOPS[] = "MULTICAST_HOPS";
+static char __pyx_k__EPROTONOSUPPORT[] = "EPROTONOSUPPORT";
+static char __pyx_k__EVENT_CONNECTED[] = "EVENT_CONNECTED";
+static char __pyx_k__EVENT_LISTENING[] = "EVENT_LISTENING";
+static char __pyx_k__FAIL_UNROUTABLE[] = "FAIL_UNROUTABLE";
+static char __pyx_k__ROUTER_BEHAVIOR[] = "ROUTER_BEHAVIOR";
+static char __pyx_k__ROUTER_MANDATORY[] = "ROUTER_MANDATORY";
+static char __pyx_k__EVENT_BIND_FAILED[] = "EVENT_BIND_FAILED";
+static char __pyx_k__RECONNECT_IVL_MAX[] = "RECONNECT_IVL_MAX";
+static char __pyx_k__RECOVERY_IVL_MSEC[] = "RECOVERY_IVL_MSEC";
+static char __pyx_k__TCP_ACCEPT_FILTER[] = "TCP_ACCEPT_FILTER";
+static char __pyx_k__TCP_KEEPALIVE_CNT[] = "TCP_KEEPALIVE_CNT";
+static char __pyx_k__EVENT_CLOSE_FAILED[] = "EVENT_CLOSE_FAILED";
+static char __pyx_k__EVENT_DISCONNECTED[] = "EVENT_DISCONNECTED";
+static char __pyx_k__TCP_KEEPALIVE_IDLE[] = "TCP_KEEPALIVE_IDLE";
+static char __pyx_k__EVENT_ACCEPT_FAILED[] = "EVENT_ACCEPT_FAILED";
+static char __pyx_k__TCP_KEEPALIVE_INTVL[] = "TCP_KEEPALIVE_INTVL";
+static PyObject *__pyx_n_s_2;
+static PyObject *__pyx_n_s_3;
+static PyObject *__pyx_n_s_4;
+static PyObject *__pyx_n_s__AFFINITY;
+static PyObject *__pyx_n_s__BACKLOG;
+static PyObject *__pyx_n_s__DEALER;
+static PyObject *__pyx_n_s__DONTWAIT;
+static PyObject *__pyx_n_s__DOWNSTREAM;
+static PyObject *__pyx_n_s__EADDRINUSE;
+static PyObject *__pyx_n_s__EADDRNOTAVAIL;
+static PyObject *__pyx_n_s__EAFNOSUPPORT;
+static PyObject *__pyx_n_s__EAGAIN;
+static PyObject *__pyx_n_s__ECONNABORTED;
+static PyObject *__pyx_n_s__ECONNREFUSED;
+static PyObject *__pyx_n_s__ECONNRESET;
+static PyObject *__pyx_n_s__EFAULT;
+static PyObject *__pyx_n_s__EFSM;
+static PyObject *__pyx_n_s__EHOSTUNREACH;
+static PyObject *__pyx_n_s__EINPROGRESS;
+static PyObject *__pyx_n_s__EINVAL;
+static PyObject *__pyx_n_s__EMSGSIZE;
+static PyObject *__pyx_n_s__EMTHREAD;
+static PyObject *__pyx_n_s__ENETDOWN;
+static PyObject *__pyx_n_s__ENETRESET;
+static PyObject *__pyx_n_s__ENETUNREACH;
+static PyObject *__pyx_n_s__ENOBUFS;
+static PyObject *__pyx_n_s__ENOCOMPATPROTO;
+static PyObject *__pyx_n_s__ENODEV;
+static PyObject *__pyx_n_s__ENOMEM;
+static PyObject *__pyx_n_s__ENOTCONN;
+static PyObject *__pyx_n_s__ENOTSOCK;
+static PyObject *__pyx_n_s__ENOTSUP;
+static PyObject *__pyx_n_s__EPROTONOSUPPORT;
+static PyObject *__pyx_n_s__ETERM;
+static PyObject *__pyx_n_s__ETIMEDOUT;
+static PyObject *__pyx_n_s__EVENTS;
+static PyObject *__pyx_n_s__EVENT_ACCEPTED;
+static PyObject *__pyx_n_s__EVENT_ACCEPT_FAILED;
+static PyObject *__pyx_n_s__EVENT_BIND_FAILED;
+static PyObject *__pyx_n_s__EVENT_CLOSED;
+static PyObject *__pyx_n_s__EVENT_CLOSE_FAILED;
+static PyObject *__pyx_n_s__EVENT_CONNECTED;
+static PyObject *__pyx_n_s__EVENT_DISCONNECTED;
+static PyObject *__pyx_n_s__EVENT_LISTENING;
+static PyObject *__pyx_n_s__FAIL_UNROUTABLE;
+static PyObject *__pyx_n_s__FD;
+static PyObject *__pyx_n_s__FORWARDER;
+static PyObject *__pyx_n_s__HWM;
+static PyObject *__pyx_n_s__IDENTITY;
+static PyObject *__pyx_n_s__IO_THREADS;
+static PyObject *__pyx_n_s__IPV4ONLY;
+static PyObject *__pyx_n_s__LAST_ENDPOINT;
+static PyObject *__pyx_n_s__LINGER;
+static PyObject *__pyx_n_s__MAXMSGSIZE;
+static PyObject *__pyx_n_s__MAX_SOCKETS;
+static PyObject *__pyx_n_s__MCAST_LOOP;
+static PyObject *__pyx_n_s__MORE;
+static PyObject *__pyx_n_s__MULTICAST_HOPS;
+static PyObject *__pyx_n_s__NOBLOCK;
+static PyObject *__pyx_n_s__PAIR;
+static PyObject *__pyx_n_s__POLLERR;
+static PyObject *__pyx_n_s__POLLIN;
+static PyObject *__pyx_n_s__POLLOUT;
+static PyObject *__pyx_n_s__PUB;
+static PyObject *__pyx_n_s__PULL;
+static PyObject *__pyx_n_s__PUSH;
+static PyObject *__pyx_n_s__QUEUE;
+static PyObject *__pyx_n_s__RATE;
+static PyObject *__pyx_n_s__RCVBUF;
+static PyObject *__pyx_n_s__RCVHWM;
+static PyObject *__pyx_n_s__RCVMORE;
+static PyObject *__pyx_n_s__RCVTIMEO;
+static PyObject *__pyx_n_s__RECONNECT_IVL;
+static PyObject *__pyx_n_s__RECONNECT_IVL_MAX;
+static PyObject *__pyx_n_s__RECOVERY_IVL;
+static PyObject *__pyx_n_s__RECOVERY_IVL_MSEC;
+static PyObject *__pyx_n_s__REP;
+static PyObject *__pyx_n_s__REQ;
+static PyObject *__pyx_n_s__ROUTER;
+static PyObject *__pyx_n_s__ROUTER_BEHAVIOR;
+static PyObject *__pyx_n_s__ROUTER_MANDATORY;
+static PyObject *__pyx_n_s__ROUTER_RAW;
+static PyObject *__pyx_n_s__SNDBUF;
+static PyObject *__pyx_n_s__SNDHWM;
+static PyObject *__pyx_n_s__SNDMORE;
+static PyObject *__pyx_n_s__SNDTIMEO;
+static PyObject *__pyx_n_s__STREAMER;
+static PyObject *__pyx_n_s__SUB;
+static PyObject *__pyx_n_s__SUBSCRIBE;
+static PyObject *__pyx_n_s__SWAP;
+static PyObject *__pyx_n_s__TCP_ACCEPT_FILTER;
+static PyObject *__pyx_n_s__TCP_KEEPALIVE;
+static PyObject *__pyx_n_s__TCP_KEEPALIVE_CNT;
+static PyObject *__pyx_n_s__TCP_KEEPALIVE_IDLE;
+static PyObject *__pyx_n_s__TCP_KEEPALIVE_INTVL;
+static PyObject *__pyx_n_s__TYPE;
+static PyObject *__pyx_n_s__UNSUBSCRIBE;
+static PyObject *__pyx_n_s__UPSTREAM;
+static PyObject *__pyx_n_s__VERSION;
+static PyObject *__pyx_n_s__XPUB;
+static PyObject *__pyx_n_s__XPUB_VERBOSE;
+static PyObject *__pyx_n_s__XREP;
+static PyObject *__pyx_n_s__XREQ;
+static PyObject *__pyx_n_s__XSUB;
+static PyObject *__pyx_n_s___;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____dict__;
+static PyObject *__pyx_n_s____import__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s___names;
+static PyObject *__pyx_n_s___optionals;
+static PyObject *__pyx_n_s__errno;
+static PyObject *__pyx_n_s__key;
+static PyObject *__pyx_n_s__keys;
+static PyObject *__pyx_n_s__startswith;
+static PyObject *__pyx_k_tuple_5;
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("constants"),
+    __Pyx_DOCSTR(__pyx_k_1), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_n_s_2, __pyx_k_2, sizeof(__pyx_k_2), 0, 0, 1, 1},
+  {&__pyx_n_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 1},
+  {&__pyx_n_s_4, __pyx_k_4, sizeof(__pyx_k_4), 0, 0, 1, 1},
+  {&__pyx_n_s__AFFINITY, __pyx_k__AFFINITY, sizeof(__pyx_k__AFFINITY), 0, 0, 1, 1},
+  {&__pyx_n_s__BACKLOG, __pyx_k__BACKLOG, sizeof(__pyx_k__BACKLOG), 0, 0, 1, 1},
+  {&__pyx_n_s__DEALER, __pyx_k__DEALER, sizeof(__pyx_k__DEALER), 0, 0, 1, 1},
+  {&__pyx_n_s__DONTWAIT, __pyx_k__DONTWAIT, sizeof(__pyx_k__DONTWAIT), 0, 0, 1, 1},
+  {&__pyx_n_s__DOWNSTREAM, __pyx_k__DOWNSTREAM, sizeof(__pyx_k__DOWNSTREAM), 0, 0, 1, 1},
+  {&__pyx_n_s__EADDRINUSE, __pyx_k__EADDRINUSE, sizeof(__pyx_k__EADDRINUSE), 0, 0, 1, 1},
+  {&__pyx_n_s__EADDRNOTAVAIL, __pyx_k__EADDRNOTAVAIL, sizeof(__pyx_k__EADDRNOTAVAIL), 0, 0, 1, 1},
+  {&__pyx_n_s__EAFNOSUPPORT, __pyx_k__EAFNOSUPPORT, sizeof(__pyx_k__EAFNOSUPPORT), 0, 0, 1, 1},
+  {&__pyx_n_s__EAGAIN, __pyx_k__EAGAIN, sizeof(__pyx_k__EAGAIN), 0, 0, 1, 1},
+  {&__pyx_n_s__ECONNABORTED, __pyx_k__ECONNABORTED, sizeof(__pyx_k__ECONNABORTED), 0, 0, 1, 1},
+  {&__pyx_n_s__ECONNREFUSED, __pyx_k__ECONNREFUSED, sizeof(__pyx_k__ECONNREFUSED), 0, 0, 1, 1},
+  {&__pyx_n_s__ECONNRESET, __pyx_k__ECONNRESET, sizeof(__pyx_k__ECONNRESET), 0, 0, 1, 1},
+  {&__pyx_n_s__EFAULT, __pyx_k__EFAULT, sizeof(__pyx_k__EFAULT), 0, 0, 1, 1},
+  {&__pyx_n_s__EFSM, __pyx_k__EFSM, sizeof(__pyx_k__EFSM), 0, 0, 1, 1},
+  {&__pyx_n_s__EHOSTUNREACH, __pyx_k__EHOSTUNREACH, sizeof(__pyx_k__EHOSTUNREACH), 0, 0, 1, 1},
+  {&__pyx_n_s__EINPROGRESS, __pyx_k__EINPROGRESS, sizeof(__pyx_k__EINPROGRESS), 0, 0, 1, 1},
+  {&__pyx_n_s__EINVAL, __pyx_k__EINVAL, sizeof(__pyx_k__EINVAL), 0, 0, 1, 1},
+  {&__pyx_n_s__EMSGSIZE, __pyx_k__EMSGSIZE, sizeof(__pyx_k__EMSGSIZE), 0, 0, 1, 1},
+  {&__pyx_n_s__EMTHREAD, __pyx_k__EMTHREAD, sizeof(__pyx_k__EMTHREAD), 0, 0, 1, 1},
+  {&__pyx_n_s__ENETDOWN, __pyx_k__ENETDOWN, sizeof(__pyx_k__ENETDOWN), 0, 0, 1, 1},
+  {&__pyx_n_s__ENETRESET, __pyx_k__ENETRESET, sizeof(__pyx_k__ENETRESET), 0, 0, 1, 1},
+  {&__pyx_n_s__ENETUNREACH, __pyx_k__ENETUNREACH, sizeof(__pyx_k__ENETUNREACH), 0, 0, 1, 1},
+  {&__pyx_n_s__ENOBUFS, __pyx_k__ENOBUFS, sizeof(__pyx_k__ENOBUFS), 0, 0, 1, 1},
+  {&__pyx_n_s__ENOCOMPATPROTO, __pyx_k__ENOCOMPATPROTO, sizeof(__pyx_k__ENOCOMPATPROTO), 0, 0, 1, 1},
+  {&__pyx_n_s__ENODEV, __pyx_k__ENODEV, sizeof(__pyx_k__ENODEV), 0, 0, 1, 1},
+  {&__pyx_n_s__ENOMEM, __pyx_k__ENOMEM, sizeof(__pyx_k__ENOMEM), 0, 0, 1, 1},
+  {&__pyx_n_s__ENOTCONN, __pyx_k__ENOTCONN, sizeof(__pyx_k__ENOTCONN), 0, 0, 1, 1},
+  {&__pyx_n_s__ENOTSOCK, __pyx_k__ENOTSOCK, sizeof(__pyx_k__ENOTSOCK), 0, 0, 1, 1},
+  {&__pyx_n_s__ENOTSUP, __pyx_k__ENOTSUP, sizeof(__pyx_k__ENOTSUP), 0, 0, 1, 1},
+  {&__pyx_n_s__EPROTONOSUPPORT, __pyx_k__EPROTONOSUPPORT, sizeof(__pyx_k__EPROTONOSUPPORT), 0, 0, 1, 1},
+  {&__pyx_n_s__ETERM, __pyx_k__ETERM, sizeof(__pyx_k__ETERM), 0, 0, 1, 1},
+  {&__pyx_n_s__ETIMEDOUT, __pyx_k__ETIMEDOUT, sizeof(__pyx_k__ETIMEDOUT), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENTS, __pyx_k__EVENTS, sizeof(__pyx_k__EVENTS), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENT_ACCEPTED, __pyx_k__EVENT_ACCEPTED, sizeof(__pyx_k__EVENT_ACCEPTED), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENT_ACCEPT_FAILED, __pyx_k__EVENT_ACCEPT_FAILED, sizeof(__pyx_k__EVENT_ACCEPT_FAILED), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENT_BIND_FAILED, __pyx_k__EVENT_BIND_FAILED, sizeof(__pyx_k__EVENT_BIND_FAILED), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENT_CLOSED, __pyx_k__EVENT_CLOSED, sizeof(__pyx_k__EVENT_CLOSED), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENT_CLOSE_FAILED, __pyx_k__EVENT_CLOSE_FAILED, sizeof(__pyx_k__EVENT_CLOSE_FAILED), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENT_CONNECTED, __pyx_k__EVENT_CONNECTED, sizeof(__pyx_k__EVENT_CONNECTED), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENT_DISCONNECTED, __pyx_k__EVENT_DISCONNECTED, sizeof(__pyx_k__EVENT_DISCONNECTED), 0, 0, 1, 1},
+  {&__pyx_n_s__EVENT_LISTENING, __pyx_k__EVENT_LISTENING, sizeof(__pyx_k__EVENT_LISTENING), 0, 0, 1, 1},
+  {&__pyx_n_s__FAIL_UNROUTABLE, __pyx_k__FAIL_UNROUTABLE, sizeof(__pyx_k__FAIL_UNROUTABLE), 0, 0, 1, 1},
+  {&__pyx_n_s__FD, __pyx_k__FD, sizeof(__pyx_k__FD), 0, 0, 1, 1},
+  {&__pyx_n_s__FORWARDER, __pyx_k__FORWARDER, sizeof(__pyx_k__FORWARDER), 0, 0, 1, 1},
+  {&__pyx_n_s__HWM, __pyx_k__HWM, sizeof(__pyx_k__HWM), 0, 0, 1, 1},
+  {&__pyx_n_s__IDENTITY, __pyx_k__IDENTITY, sizeof(__pyx_k__IDENTITY), 0, 0, 1, 1},
+  {&__pyx_n_s__IO_THREADS, __pyx_k__IO_THREADS, sizeof(__pyx_k__IO_THREADS), 0, 0, 1, 1},
+  {&__pyx_n_s__IPV4ONLY, __pyx_k__IPV4ONLY, sizeof(__pyx_k__IPV4ONLY), 0, 0, 1, 1},
+  {&__pyx_n_s__LAST_ENDPOINT, __pyx_k__LAST_ENDPOINT, sizeof(__pyx_k__LAST_ENDPOINT), 0, 0, 1, 1},
+  {&__pyx_n_s__LINGER, __pyx_k__LINGER, sizeof(__pyx_k__LINGER), 0, 0, 1, 1},
+  {&__pyx_n_s__MAXMSGSIZE, __pyx_k__MAXMSGSIZE, sizeof(__pyx_k__MAXMSGSIZE), 0, 0, 1, 1},
+  {&__pyx_n_s__MAX_SOCKETS, __pyx_k__MAX_SOCKETS, sizeof(__pyx_k__MAX_SOCKETS), 0, 0, 1, 1},
+  {&__pyx_n_s__MCAST_LOOP, __pyx_k__MCAST_LOOP, sizeof(__pyx_k__MCAST_LOOP), 0, 0, 1, 1},
+  {&__pyx_n_s__MORE, __pyx_k__MORE, sizeof(__pyx_k__MORE), 0, 0, 1, 1},
+  {&__pyx_n_s__MULTICAST_HOPS, __pyx_k__MULTICAST_HOPS, sizeof(__pyx_k__MULTICAST_HOPS), 0, 0, 1, 1},
+  {&__pyx_n_s__NOBLOCK, __pyx_k__NOBLOCK, sizeof(__pyx_k__NOBLOCK), 0, 0, 1, 1},
+  {&__pyx_n_s__PAIR, __pyx_k__PAIR, sizeof(__pyx_k__PAIR), 0, 0, 1, 1},
+  {&__pyx_n_s__POLLERR, __pyx_k__POLLERR, sizeof(__pyx_k__POLLERR), 0, 0, 1, 1},
+  {&__pyx_n_s__POLLIN, __pyx_k__POLLIN, sizeof(__pyx_k__POLLIN), 0, 0, 1, 1},
+  {&__pyx_n_s__POLLOUT, __pyx_k__POLLOUT, sizeof(__pyx_k__POLLOUT), 0, 0, 1, 1},
+  {&__pyx_n_s__PUB, __pyx_k__PUB, sizeof(__pyx_k__PUB), 0, 0, 1, 1},
+  {&__pyx_n_s__PULL, __pyx_k__PULL, sizeof(__pyx_k__PULL), 0, 0, 1, 1},
+  {&__pyx_n_s__PUSH, __pyx_k__PUSH, sizeof(__pyx_k__PUSH), 0, 0, 1, 1},
+  {&__pyx_n_s__QUEUE, __pyx_k__QUEUE, sizeof(__pyx_k__QUEUE), 0, 0, 1, 1},
+  {&__pyx_n_s__RATE, __pyx_k__RATE, sizeof(__pyx_k__RATE), 0, 0, 1, 1},
+  {&__pyx_n_s__RCVBUF, __pyx_k__RCVBUF, sizeof(__pyx_k__RCVBUF), 0, 0, 1, 1},
+  {&__pyx_n_s__RCVHWM, __pyx_k__RCVHWM, sizeof(__pyx_k__RCVHWM), 0, 0, 1, 1},
+  {&__pyx_n_s__RCVMORE, __pyx_k__RCVMORE, sizeof(__pyx_k__RCVMORE), 0, 0, 1, 1},
+  {&__pyx_n_s__RCVTIMEO, __pyx_k__RCVTIMEO, sizeof(__pyx_k__RCVTIMEO), 0, 0, 1, 1},
+  {&__pyx_n_s__RECONNECT_IVL, __pyx_k__RECONNECT_IVL, sizeof(__pyx_k__RECONNECT_IVL), 0, 0, 1, 1},
+  {&__pyx_n_s__RECONNECT_IVL_MAX, __pyx_k__RECONNECT_IVL_MAX, sizeof(__pyx_k__RECONNECT_IVL_MAX), 0, 0, 1, 1},
+  {&__pyx_n_s__RECOVERY_IVL, __pyx_k__RECOVERY_IVL, sizeof(__pyx_k__RECOVERY_IVL), 0, 0, 1, 1},
+  {&__pyx_n_s__RECOVERY_IVL_MSEC, __pyx_k__RECOVERY_IVL_MSEC, sizeof(__pyx_k__RECOVERY_IVL_MSEC), 0, 0, 1, 1},
+  {&__pyx_n_s__REP, __pyx_k__REP, sizeof(__pyx_k__REP), 0, 0, 1, 1},
+  {&__pyx_n_s__REQ, __pyx_k__REQ, sizeof(__pyx_k__REQ), 0, 0, 1, 1},
+  {&__pyx_n_s__ROUTER, __pyx_k__ROUTER, sizeof(__pyx_k__ROUTER), 0, 0, 1, 1},
+  {&__pyx_n_s__ROUTER_BEHAVIOR, __pyx_k__ROUTER_BEHAVIOR, sizeof(__pyx_k__ROUTER_BEHAVIOR), 0, 0, 1, 1},
+  {&__pyx_n_s__ROUTER_MANDATORY, __pyx_k__ROUTER_MANDATORY, sizeof(__pyx_k__ROUTER_MANDATORY), 0, 0, 1, 1},
+  {&__pyx_n_s__ROUTER_RAW, __pyx_k__ROUTER_RAW, sizeof(__pyx_k__ROUTER_RAW), 0, 0, 1, 1},
+  {&__pyx_n_s__SNDBUF, __pyx_k__SNDBUF, sizeof(__pyx_k__SNDBUF), 0, 0, 1, 1},
+  {&__pyx_n_s__SNDHWM, __pyx_k__SNDHWM, sizeof(__pyx_k__SNDHWM), 0, 0, 1, 1},
+  {&__pyx_n_s__SNDMORE, __pyx_k__SNDMORE, sizeof(__pyx_k__SNDMORE), 0, 0, 1, 1},
+  {&__pyx_n_s__SNDTIMEO, __pyx_k__SNDTIMEO, sizeof(__pyx_k__SNDTIMEO), 0, 0, 1, 1},
+  {&__pyx_n_s__STREAMER, __pyx_k__STREAMER, sizeof(__pyx_k__STREAMER), 0, 0, 1, 1},
+  {&__pyx_n_s__SUB, __pyx_k__SUB, sizeof(__pyx_k__SUB), 0, 0, 1, 1},
+  {&__pyx_n_s__SUBSCRIBE, __pyx_k__SUBSCRIBE, sizeof(__pyx_k__SUBSCRIBE), 0, 0, 1, 1},
+  {&__pyx_n_s__SWAP, __pyx_k__SWAP, sizeof(__pyx_k__SWAP), 0, 0, 1, 1},
+  {&__pyx_n_s__TCP_ACCEPT_FILTER, __pyx_k__TCP_ACCEPT_FILTER, sizeof(__pyx_k__TCP_ACCEPT_FILTER), 0, 0, 1, 1},
+  {&__pyx_n_s__TCP_KEEPALIVE, __pyx_k__TCP_KEEPALIVE, sizeof(__pyx_k__TCP_KEEPALIVE), 0, 0, 1, 1},
+  {&__pyx_n_s__TCP_KEEPALIVE_CNT, __pyx_k__TCP_KEEPALIVE_CNT, sizeof(__pyx_k__TCP_KEEPALIVE_CNT), 0, 0, 1, 1},
+  {&__pyx_n_s__TCP_KEEPALIVE_IDLE, __pyx_k__TCP_KEEPALIVE_IDLE, sizeof(__pyx_k__TCP_KEEPALIVE_IDLE), 0, 0, 1, 1},
+  {&__pyx_n_s__TCP_KEEPALIVE_INTVL, __pyx_k__TCP_KEEPALIVE_INTVL, sizeof(__pyx_k__TCP_KEEPALIVE_INTVL), 0, 0, 1, 1},
+  {&__pyx_n_s__TYPE, __pyx_k__TYPE, sizeof(__pyx_k__TYPE), 0, 0, 1, 1},
+  {&__pyx_n_s__UNSUBSCRIBE, __pyx_k__UNSUBSCRIBE, sizeof(__pyx_k__UNSUBSCRIBE), 0, 0, 1, 1},
+  {&__pyx_n_s__UPSTREAM, __pyx_k__UPSTREAM, sizeof(__pyx_k__UPSTREAM), 0, 0, 1, 1},
+  {&__pyx_n_s__VERSION, __pyx_k__VERSION, sizeof(__pyx_k__VERSION), 0, 0, 1, 1},
+  {&__pyx_n_s__XPUB, __pyx_k__XPUB, sizeof(__pyx_k__XPUB), 0, 0, 1, 1},
+  {&__pyx_n_s__XPUB_VERBOSE, __pyx_k__XPUB_VERBOSE, sizeof(__pyx_k__XPUB_VERBOSE), 0, 0, 1, 1},
+  {&__pyx_n_s__XREP, __pyx_k__XREP, sizeof(__pyx_k__XREP), 0, 0, 1, 1},
+  {&__pyx_n_s__XREQ, __pyx_k__XREQ, sizeof(__pyx_k__XREQ), 0, 0, 1, 1},
+  {&__pyx_n_s__XSUB, __pyx_k__XSUB, sizeof(__pyx_k__XSUB), 0, 0, 1, 1},
+  {&__pyx_n_s___, __pyx_k___, sizeof(__pyx_k___), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____dict__, __pyx_k____dict__, sizeof(__pyx_k____dict__), 0, 0, 1, 1},
+  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s___names, __pyx_k___names, sizeof(__pyx_k___names), 0, 0, 1, 1},
+  {&__pyx_n_s___optionals, __pyx_k___optionals, sizeof(__pyx_k___optionals), 0, 0, 1, 1},
+  {&__pyx_n_s__errno, __pyx_k__errno, sizeof(__pyx_k__errno), 0, 0, 1, 1},
+  {&__pyx_n_s__key, __pyx_k__key, sizeof(__pyx_k__key), 0, 0, 1, 1},
+  {&__pyx_n_s__keys, __pyx_k__keys, sizeof(__pyx_k__keys), 0, 0, 1, 1},
+  {&__pyx_n_s__startswith, __pyx_k__startswith, sizeof(__pyx_k__startswith), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  return 0;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/constants.pyx":190
+ * #-----------------------------------------------------------------------------
+ * _names = list(locals().keys())
+ * __all__ = [ key for key in _names if not key.startswith('_') ]             # <<<<<<<<<<<<<<
+ */
+  __pyx_k_tuple_5 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s___)); if (unlikely(!__pyx_k_tuple_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_5);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_5));
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC initconstants(void); /*proto*/
+PyMODINIT_FUNC initconstants(void)
+#else
+PyMODINIT_FUNC PyInit_constants(void); /*proto*/
+PyMODINIT_FUNC PyInit_constants(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  Py_ssize_t __pyx_t_5;
+  PyObject *(*__pyx_t_6)(PyObject *);
+  PyObject *__pyx_t_7 = NULL;
+  int __pyx_t_8;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_constants(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("constants"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_1), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core.constants")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core.constants", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core__constants) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  /*--- Type import code ---*/
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/constants.pyx":32
+ * #-----------------------------------------------------------------------------
+ * 
+ * _optionals = []             # <<<<<<<<<<<<<<
+ * 
+ * if ZMQ_VERSION < 30000:
+ */
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s___optionals, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":34
+ * _optionals = []
+ * 
+ * if ZMQ_VERSION < 30000:             # <<<<<<<<<<<<<<
+ *     # backport DONTWAIT as alias to NOBLOCK
+ *     NOBLOCK = ZMQ_NOBLOCK
+ */
+  __pyx_t_2 = (ZMQ_VERSION < 30000);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/constants.pyx":36
+ * if ZMQ_VERSION < 30000:
+ *     # backport DONTWAIT as alias to NOBLOCK
+ *     NOBLOCK = ZMQ_NOBLOCK             # <<<<<<<<<<<<<<
+ *     DONTWAIT = ZMQ_NOBLOCK
+ * else:
+ */
+    __pyx_t_1 = PyInt_FromLong(ZMQ_NOBLOCK); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 36; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (PyDict_SetItem(__pyx_d, __pyx_n_s__NOBLOCK, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 36; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "zmq/core/constants.pyx":37
+ *     # backport DONTWAIT as alias to NOBLOCK
+ *     NOBLOCK = ZMQ_NOBLOCK
+ *     DONTWAIT = ZMQ_NOBLOCK             # <<<<<<<<<<<<<<
+ * else:
+ *     # keep NOBLOCK as alias for new DONTWAIT
+ */
+    __pyx_t_1 = PyInt_FromLong(ZMQ_NOBLOCK); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 37; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (PyDict_SetItem(__pyx_d, __pyx_n_s__DONTWAIT, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 37; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    goto __pyx_L2;
+  }
+  /*else*/ {
+
+    /* "zmq/core/constants.pyx":40
+ * else:
+ *     # keep NOBLOCK as alias for new DONTWAIT
+ *     NOBLOCK = ZMQ_DONTWAIT             # <<<<<<<<<<<<<<
+ *     DONTWAIT = ZMQ_DONTWAIT
+ * 
+ */
+    __pyx_t_1 = PyInt_FromLong(ZMQ_DONTWAIT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (PyDict_SetItem(__pyx_d, __pyx_n_s__NOBLOCK, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "zmq/core/constants.pyx":41
+ *     # keep NOBLOCK as alias for new DONTWAIT
+ *     NOBLOCK = ZMQ_DONTWAIT
+ *     DONTWAIT = ZMQ_DONTWAIT             # <<<<<<<<<<<<<<
+ * 
+ * VERSION = ZMQ_VERSION
+ */
+    __pyx_t_1 = PyInt_FromLong(ZMQ_DONTWAIT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (PyDict_SetItem(__pyx_d, __pyx_n_s__DONTWAIT, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  }
+  __pyx_L2:;
+
+  /* "zmq/core/constants.pyx":43
+ *     DONTWAIT = ZMQ_DONTWAIT
+ * 
+ * VERSION = ZMQ_VERSION             # <<<<<<<<<<<<<<
+ * 
+ * # socket types
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_VERSION); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__VERSION, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":46
+ * 
+ * # socket types
+ * PAIR = ZMQ_PAIR             # <<<<<<<<<<<<<<
+ * PUB = ZMQ_PUB
+ * SUB = ZMQ_SUB
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_PAIR); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__PAIR, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":47
+ * # socket types
+ * PAIR = ZMQ_PAIR
+ * PUB = ZMQ_PUB             # <<<<<<<<<<<<<<
+ * SUB = ZMQ_SUB
+ * REQ = ZMQ_REQ
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_PUB); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 47; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__PUB, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 47; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":48
+ * PAIR = ZMQ_PAIR
+ * PUB = ZMQ_PUB
+ * SUB = ZMQ_SUB             # <<<<<<<<<<<<<<
+ * REQ = ZMQ_REQ
+ * REP = ZMQ_REP
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_SUB); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__SUB, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":49
+ * PUB = ZMQ_PUB
+ * SUB = ZMQ_SUB
+ * REQ = ZMQ_REQ             # <<<<<<<<<<<<<<
+ * REP = ZMQ_REP
+ * DEALER = ZMQ_DEALER
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_REQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__REQ, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":50
+ * SUB = ZMQ_SUB
+ * REQ = ZMQ_REQ
+ * REP = ZMQ_REP             # <<<<<<<<<<<<<<
+ * DEALER = ZMQ_DEALER
+ * ROUTER = ZMQ_ROUTER
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_REP); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__REP, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":51
+ * REQ = ZMQ_REQ
+ * REP = ZMQ_REP
+ * DEALER = ZMQ_DEALER             # <<<<<<<<<<<<<<
+ * ROUTER = ZMQ_ROUTER
+ * PULL = ZMQ_PULL
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_DEALER); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__DEALER, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":52
+ * REP = ZMQ_REP
+ * DEALER = ZMQ_DEALER
+ * ROUTER = ZMQ_ROUTER             # <<<<<<<<<<<<<<
+ * PULL = ZMQ_PULL
+ * PUSH = ZMQ_PUSH
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_ROUTER); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ROUTER, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":53
+ * DEALER = ZMQ_DEALER
+ * ROUTER = ZMQ_ROUTER
+ * PULL = ZMQ_PULL             # <<<<<<<<<<<<<<
+ * PUSH = ZMQ_PUSH
+ * XPUB = ZMQ_XPUB
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_PULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__PULL, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":54
+ * ROUTER = ZMQ_ROUTER
+ * PULL = ZMQ_PULL
+ * PUSH = ZMQ_PUSH             # <<<<<<<<<<<<<<
+ * XPUB = ZMQ_XPUB
+ * XSUB = ZMQ_XSUB
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_PUSH); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__PUSH, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":55
+ * PULL = ZMQ_PULL
+ * PUSH = ZMQ_PUSH
+ * XPUB = ZMQ_XPUB             # <<<<<<<<<<<<<<
+ * XSUB = ZMQ_XSUB
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_XPUB); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__XPUB, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":56
+ * PUSH = ZMQ_PUSH
+ * XPUB = ZMQ_XPUB
+ * XSUB = ZMQ_XSUB             # <<<<<<<<<<<<<<
+ * 
+ * # keep deprecated aliases
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_XSUB); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__XSUB, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":59
+ * 
+ * # keep deprecated aliases
+ * XREQ = DEALER             # <<<<<<<<<<<<<<
+ * XREP = ROUTER
+ * UPSTREAM = PULL
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__DEALER); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__XREQ, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":60
+ * # keep deprecated aliases
+ * XREQ = DEALER
+ * XREP = ROUTER             # <<<<<<<<<<<<<<
+ * UPSTREAM = PULL
+ * DOWNSTREAM = PUSH
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__ROUTER); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__XREP, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":61
+ * XREQ = DEALER
+ * XREP = ROUTER
+ * UPSTREAM = PULL             # <<<<<<<<<<<<<<
+ * DOWNSTREAM = PUSH
+ * 
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__PULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__UPSTREAM, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":62
+ * XREP = ROUTER
+ * UPSTREAM = PULL
+ * DOWNSTREAM = PUSH             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__PUSH); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__DOWNSTREAM, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":66
+ * 
+ * # socket options
+ * AFFINITY = ZMQ_AFFINITY             # <<<<<<<<<<<<<<
+ * IDENTITY = ZMQ_IDENTITY
+ * SUBSCRIBE = ZMQ_SUBSCRIBE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_AFFINITY); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 66; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__AFFINITY, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 66; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":67
+ * # socket options
+ * AFFINITY = ZMQ_AFFINITY
+ * IDENTITY = ZMQ_IDENTITY             # <<<<<<<<<<<<<<
+ * SUBSCRIBE = ZMQ_SUBSCRIBE
+ * UNSUBSCRIBE = ZMQ_UNSUBSCRIBE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_IDENTITY); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 67; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__IDENTITY, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 67; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":68
+ * AFFINITY = ZMQ_AFFINITY
+ * IDENTITY = ZMQ_IDENTITY
+ * SUBSCRIBE = ZMQ_SUBSCRIBE             # <<<<<<<<<<<<<<
+ * UNSUBSCRIBE = ZMQ_UNSUBSCRIBE
+ * RATE = ZMQ_RATE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_SUBSCRIBE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__SUBSCRIBE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":69
+ * IDENTITY = ZMQ_IDENTITY
+ * SUBSCRIBE = ZMQ_SUBSCRIBE
+ * UNSUBSCRIBE = ZMQ_UNSUBSCRIBE             # <<<<<<<<<<<<<<
+ * RATE = ZMQ_RATE
+ * RECOVERY_IVL = ZMQ_RECOVERY_IVL
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_UNSUBSCRIBE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__UNSUBSCRIBE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":70
+ * SUBSCRIBE = ZMQ_SUBSCRIBE
+ * UNSUBSCRIBE = ZMQ_UNSUBSCRIBE
+ * RATE = ZMQ_RATE             # <<<<<<<<<<<<<<
+ * RECOVERY_IVL = ZMQ_RECOVERY_IVL
+ * RECONNECT_IVL_MAX = ZMQ_RECONNECT_IVL_MAX
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RATE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RATE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":71
+ * UNSUBSCRIBE = ZMQ_UNSUBSCRIBE
+ * RATE = ZMQ_RATE
+ * RECOVERY_IVL = ZMQ_RECOVERY_IVL             # <<<<<<<<<<<<<<
+ * RECONNECT_IVL_MAX = ZMQ_RECONNECT_IVL_MAX
+ * SNDBUF = ZMQ_SNDBUF
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RECOVERY_IVL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 71; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RECOVERY_IVL, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 71; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":72
+ * RATE = ZMQ_RATE
+ * RECOVERY_IVL = ZMQ_RECOVERY_IVL
+ * RECONNECT_IVL_MAX = ZMQ_RECONNECT_IVL_MAX             # <<<<<<<<<<<<<<
+ * SNDBUF = ZMQ_SNDBUF
+ * RCVBUF = ZMQ_RCVBUF
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RECONNECT_IVL_MAX); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RECONNECT_IVL_MAX, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":73
+ * RECOVERY_IVL = ZMQ_RECOVERY_IVL
+ * RECONNECT_IVL_MAX = ZMQ_RECONNECT_IVL_MAX
+ * SNDBUF = ZMQ_SNDBUF             # <<<<<<<<<<<<<<
+ * RCVBUF = ZMQ_RCVBUF
+ * RCVMORE = ZMQ_RCVMORE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_SNDBUF); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__SNDBUF, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":74
+ * RECONNECT_IVL_MAX = ZMQ_RECONNECT_IVL_MAX
+ * SNDBUF = ZMQ_SNDBUF
+ * RCVBUF = ZMQ_RCVBUF             # <<<<<<<<<<<<<<
+ * RCVMORE = ZMQ_RCVMORE
+ * SNDMORE = ZMQ_SNDMORE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RCVBUF); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RCVBUF, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":75
+ * SNDBUF = ZMQ_SNDBUF
+ * RCVBUF = ZMQ_RCVBUF
+ * RCVMORE = ZMQ_RCVMORE             # <<<<<<<<<<<<<<
+ * SNDMORE = ZMQ_SNDMORE
+ * POLLIN = ZMQ_POLLIN
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RCVMORE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RCVMORE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":76
+ * RCVBUF = ZMQ_RCVBUF
+ * RCVMORE = ZMQ_RCVMORE
+ * SNDMORE = ZMQ_SNDMORE             # <<<<<<<<<<<<<<
+ * POLLIN = ZMQ_POLLIN
+ * POLLOUT = ZMQ_POLLOUT
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_SNDMORE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__SNDMORE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":77
+ * RCVMORE = ZMQ_RCVMORE
+ * SNDMORE = ZMQ_SNDMORE
+ * POLLIN = ZMQ_POLLIN             # <<<<<<<<<<<<<<
+ * POLLOUT = ZMQ_POLLOUT
+ * POLLERR = ZMQ_POLLERR
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_POLLIN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 77; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__POLLIN, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 77; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":78
+ * SNDMORE = ZMQ_SNDMORE
+ * POLLIN = ZMQ_POLLIN
+ * POLLOUT = ZMQ_POLLOUT             # <<<<<<<<<<<<<<
+ * POLLERR = ZMQ_POLLERR
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_POLLOUT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__POLLOUT, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":79
+ * POLLIN = ZMQ_POLLIN
+ * POLLOUT = ZMQ_POLLOUT
+ * POLLERR = ZMQ_POLLERR             # <<<<<<<<<<<<<<
+ * 
+ * STREAMER = ZMQ_STREAMER
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_POLLERR); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__POLLERR, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":81
+ * POLLERR = ZMQ_POLLERR
+ * 
+ * STREAMER = ZMQ_STREAMER             # <<<<<<<<<<<<<<
+ * FORWARDER = ZMQ_FORWARDER
+ * QUEUE = ZMQ_QUEUE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_STREAMER); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__STREAMER, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":82
+ * 
+ * STREAMER = ZMQ_STREAMER
+ * FORWARDER = ZMQ_FORWARDER             # <<<<<<<<<<<<<<
+ * QUEUE = ZMQ_QUEUE
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_FORWARDER); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__FORWARDER, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":83
+ * STREAMER = ZMQ_STREAMER
+ * FORWARDER = ZMQ_FORWARDER
+ * QUEUE = ZMQ_QUEUE             # <<<<<<<<<<<<<<
+ * 
+ * # sockopts new in 2.2.0
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_QUEUE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__QUEUE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":86
+ * 
+ * # sockopts new in 2.2.0
+ * SNDTIMEO = ZMQ_SNDTIMEO             # <<<<<<<<<<<<<<
+ * RCVTIMEO = ZMQ_RCVTIMEO
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_SNDTIMEO); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__SNDTIMEO, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":87
+ * # sockopts new in 2.2.0
+ * SNDTIMEO = ZMQ_SNDTIMEO
+ * RCVTIMEO = ZMQ_RCVTIMEO             # <<<<<<<<<<<<<<
+ * 
+ * # sockopts removed in 3.0.0
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RCVTIMEO); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RCVTIMEO, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":90
+ * 
+ * # sockopts removed in 3.0.0
+ * HWM = ZMQ_HWM             # <<<<<<<<<<<<<<
+ * SWAP = ZMQ_SWAP
+ * MCAST_LOOP = ZMQ_MCAST_LOOP
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_HWM); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__HWM, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":91
+ * # sockopts removed in 3.0.0
+ * HWM = ZMQ_HWM
+ * SWAP = ZMQ_SWAP             # <<<<<<<<<<<<<<
+ * MCAST_LOOP = ZMQ_MCAST_LOOP
+ * RECOVERY_IVL_MSEC = ZMQ_RECOVERY_IVL_MSEC
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_SWAP); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 91; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__SWAP, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 91; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":92
+ * HWM = ZMQ_HWM
+ * SWAP = ZMQ_SWAP
+ * MCAST_LOOP = ZMQ_MCAST_LOOP             # <<<<<<<<<<<<<<
+ * RECOVERY_IVL_MSEC = ZMQ_RECOVERY_IVL_MSEC
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_MCAST_LOOP); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__MCAST_LOOP, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":93
+ * SWAP = ZMQ_SWAP
+ * MCAST_LOOP = ZMQ_MCAST_LOOP
+ * RECOVERY_IVL_MSEC = ZMQ_RECOVERY_IVL_MSEC             # <<<<<<<<<<<<<<
+ * 
+ * # new in 3.x
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RECOVERY_IVL_MSEC); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 93; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RECOVERY_IVL_MSEC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 93; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":96
+ * 
+ * # new in 3.x
+ * IO_THREADS = ZMQ_IO_THREADS             # <<<<<<<<<<<<<<
+ * MAX_SOCKETS = ZMQ_MAX_SOCKETS
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_IO_THREADS); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__IO_THREADS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":97
+ * # new in 3.x
+ * IO_THREADS = ZMQ_IO_THREADS
+ * MAX_SOCKETS = ZMQ_MAX_SOCKETS             # <<<<<<<<<<<<<<
+ * 
+ * MORE = ZMQ_MORE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_MAX_SOCKETS); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__MAX_SOCKETS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":99
+ * MAX_SOCKETS = ZMQ_MAX_SOCKETS
+ * 
+ * MORE = ZMQ_MORE             # <<<<<<<<<<<<<<
+ * 
+ * MAXMSGSIZE = ZMQ_MAXMSGSIZE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_MORE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__MORE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":101
+ * MORE = ZMQ_MORE
+ * 
+ * MAXMSGSIZE = ZMQ_MAXMSGSIZE             # <<<<<<<<<<<<<<
+ * SNDHWM = ZMQ_SNDHWM
+ * RCVHWM = ZMQ_RCVHWM
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_MAXMSGSIZE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__MAXMSGSIZE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":102
+ * 
+ * MAXMSGSIZE = ZMQ_MAXMSGSIZE
+ * SNDHWM = ZMQ_SNDHWM             # <<<<<<<<<<<<<<
+ * RCVHWM = ZMQ_RCVHWM
+ * MULTICAST_HOPS = ZMQ_MULTICAST_HOPS
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_SNDHWM); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__SNDHWM, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":103
+ * MAXMSGSIZE = ZMQ_MAXMSGSIZE
+ * SNDHWM = ZMQ_SNDHWM
+ * RCVHWM = ZMQ_RCVHWM             # <<<<<<<<<<<<<<
+ * MULTICAST_HOPS = ZMQ_MULTICAST_HOPS
+ * IPV4ONLY = ZMQ_IPV4ONLY
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RCVHWM); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RCVHWM, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":104
+ * SNDHWM = ZMQ_SNDHWM
+ * RCVHWM = ZMQ_RCVHWM
+ * MULTICAST_HOPS = ZMQ_MULTICAST_HOPS             # <<<<<<<<<<<<<<
+ * IPV4ONLY = ZMQ_IPV4ONLY
+ * LAST_ENDPOINT = ZMQ_LAST_ENDPOINT
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_MULTICAST_HOPS); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__MULTICAST_HOPS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":105
+ * RCVHWM = ZMQ_RCVHWM
+ * MULTICAST_HOPS = ZMQ_MULTICAST_HOPS
+ * IPV4ONLY = ZMQ_IPV4ONLY             # <<<<<<<<<<<<<<
+ * LAST_ENDPOINT = ZMQ_LAST_ENDPOINT
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_IPV4ONLY); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__IPV4ONLY, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":106
+ * MULTICAST_HOPS = ZMQ_MULTICAST_HOPS
+ * IPV4ONLY = ZMQ_IPV4ONLY
+ * LAST_ENDPOINT = ZMQ_LAST_ENDPOINT             # <<<<<<<<<<<<<<
+ * 
+ * ROUTER_MANDATORY = ZMQ_ROUTER_MANDATORY
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_LAST_ENDPOINT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__LAST_ENDPOINT, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":108
+ * LAST_ENDPOINT = ZMQ_LAST_ENDPOINT
+ * 
+ * ROUTER_MANDATORY = ZMQ_ROUTER_MANDATORY             # <<<<<<<<<<<<<<
+ * # aliases
+ * ROUTER_BEHAVIOR = ROUTER_MANDATORY
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_ROUTER_MANDATORY); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ROUTER_MANDATORY, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":110
+ * ROUTER_MANDATORY = ZMQ_ROUTER_MANDATORY
+ * # aliases
+ * ROUTER_BEHAVIOR = ROUTER_MANDATORY             # <<<<<<<<<<<<<<
+ * FAIL_UNROUTABLE = ROUTER_MANDATORY
+ * 
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__ROUTER_MANDATORY); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ROUTER_BEHAVIOR, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":111
+ * # aliases
+ * ROUTER_BEHAVIOR = ROUTER_MANDATORY
+ * FAIL_UNROUTABLE = ROUTER_MANDATORY             # <<<<<<<<<<<<<<
+ * 
+ * TCP_KEEPALIVE = ZMQ_TCP_KEEPALIVE
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__ROUTER_MANDATORY); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 111; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__FAIL_UNROUTABLE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 111; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":113
+ * FAIL_UNROUTABLE = ROUTER_MANDATORY
+ * 
+ * TCP_KEEPALIVE = ZMQ_TCP_KEEPALIVE             # <<<<<<<<<<<<<<
+ * TCP_KEEPALIVE_CNT = ZMQ_TCP_KEEPALIVE_CNT
+ * TCP_KEEPALIVE_IDLE = ZMQ_TCP_KEEPALIVE_IDLE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_TCP_KEEPALIVE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__TCP_KEEPALIVE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":114
+ * 
+ * TCP_KEEPALIVE = ZMQ_TCP_KEEPALIVE
+ * TCP_KEEPALIVE_CNT = ZMQ_TCP_KEEPALIVE_CNT             # <<<<<<<<<<<<<<
+ * TCP_KEEPALIVE_IDLE = ZMQ_TCP_KEEPALIVE_IDLE
+ * TCP_KEEPALIVE_INTVL = ZMQ_TCP_KEEPALIVE_INTVL
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_TCP_KEEPALIVE_CNT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__TCP_KEEPALIVE_CNT, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":115
+ * TCP_KEEPALIVE = ZMQ_TCP_KEEPALIVE
+ * TCP_KEEPALIVE_CNT = ZMQ_TCP_KEEPALIVE_CNT
+ * TCP_KEEPALIVE_IDLE = ZMQ_TCP_KEEPALIVE_IDLE             # <<<<<<<<<<<<<<
+ * TCP_KEEPALIVE_INTVL = ZMQ_TCP_KEEPALIVE_INTVL
+ * TCP_ACCEPT_FILTER = ZMQ_TCP_ACCEPT_FILTER
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_TCP_KEEPALIVE_IDLE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__TCP_KEEPALIVE_IDLE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":116
+ * TCP_KEEPALIVE_CNT = ZMQ_TCP_KEEPALIVE_CNT
+ * TCP_KEEPALIVE_IDLE = ZMQ_TCP_KEEPALIVE_IDLE
+ * TCP_KEEPALIVE_INTVL = ZMQ_TCP_KEEPALIVE_INTVL             # <<<<<<<<<<<<<<
+ * TCP_ACCEPT_FILTER = ZMQ_TCP_ACCEPT_FILTER
+ * DELAY_ATTACH_ON_CONNECT = ZMQ_DELAY_ATTACH_ON_CONNECT
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_TCP_KEEPALIVE_INTVL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__TCP_KEEPALIVE_INTVL, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":117
+ * TCP_KEEPALIVE_IDLE = ZMQ_TCP_KEEPALIVE_IDLE
+ * TCP_KEEPALIVE_INTVL = ZMQ_TCP_KEEPALIVE_INTVL
+ * TCP_ACCEPT_FILTER = ZMQ_TCP_ACCEPT_FILTER             # <<<<<<<<<<<<<<
+ * DELAY_ATTACH_ON_CONNECT = ZMQ_DELAY_ATTACH_ON_CONNECT
+ * XPUB_VERBOSE = ZMQ_XPUB_VERBOSE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_TCP_ACCEPT_FILTER); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__TCP_ACCEPT_FILTER, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":118
+ * TCP_KEEPALIVE_INTVL = ZMQ_TCP_KEEPALIVE_INTVL
+ * TCP_ACCEPT_FILTER = ZMQ_TCP_ACCEPT_FILTER
+ * DELAY_ATTACH_ON_CONNECT = ZMQ_DELAY_ATTACH_ON_CONNECT             # <<<<<<<<<<<<<<
+ * XPUB_VERBOSE = ZMQ_XPUB_VERBOSE
+ * ROUTER_RAW = ZMQ_ROUTER_RAW
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_DELAY_ATTACH_ON_CONNECT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_2, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":119
+ * TCP_ACCEPT_FILTER = ZMQ_TCP_ACCEPT_FILTER
+ * DELAY_ATTACH_ON_CONNECT = ZMQ_DELAY_ATTACH_ON_CONNECT
+ * XPUB_VERBOSE = ZMQ_XPUB_VERBOSE             # <<<<<<<<<<<<<<
+ * ROUTER_RAW = ZMQ_ROUTER_RAW
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_XPUB_VERBOSE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__XPUB_VERBOSE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":120
+ * DELAY_ATTACH_ON_CONNECT = ZMQ_DELAY_ATTACH_ON_CONNECT
+ * XPUB_VERBOSE = ZMQ_XPUB_VERBOSE
+ * ROUTER_RAW = ZMQ_ROUTER_RAW             # <<<<<<<<<<<<<<
+ * 
+ * EVENT_CONNECTED = ZMQ_EVENT_CONNECTED
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_ROUTER_RAW); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ROUTER_RAW, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":122
+ * ROUTER_RAW = ZMQ_ROUTER_RAW
+ * 
+ * EVENT_CONNECTED = ZMQ_EVENT_CONNECTED             # <<<<<<<<<<<<<<
+ * EVENT_CONNECT_DELAYED = ZMQ_EVENT_CONNECT_DELAYED
+ * EVENT_CONNECT_RETRIED = ZMQ_EVENT_CONNECT_RETRIED
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_CONNECTED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENT_CONNECTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":123
+ * 
+ * EVENT_CONNECTED = ZMQ_EVENT_CONNECTED
+ * EVENT_CONNECT_DELAYED = ZMQ_EVENT_CONNECT_DELAYED             # <<<<<<<<<<<<<<
+ * EVENT_CONNECT_RETRIED = ZMQ_EVENT_CONNECT_RETRIED
+ * EVENT_LISTENING = ZMQ_EVENT_LISTENING
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_CONNECT_DELAYED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_3, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":124
+ * EVENT_CONNECTED = ZMQ_EVENT_CONNECTED
+ * EVENT_CONNECT_DELAYED = ZMQ_EVENT_CONNECT_DELAYED
+ * EVENT_CONNECT_RETRIED = ZMQ_EVENT_CONNECT_RETRIED             # <<<<<<<<<<<<<<
+ * EVENT_LISTENING = ZMQ_EVENT_LISTENING
+ * EVENT_BIND_FAILED = ZMQ_EVENT_BIND_FAILED
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_CONNECT_RETRIED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_4, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":125
+ * EVENT_CONNECT_DELAYED = ZMQ_EVENT_CONNECT_DELAYED
+ * EVENT_CONNECT_RETRIED = ZMQ_EVENT_CONNECT_RETRIED
+ * EVENT_LISTENING = ZMQ_EVENT_LISTENING             # <<<<<<<<<<<<<<
+ * EVENT_BIND_FAILED = ZMQ_EVENT_BIND_FAILED
+ * EVENT_ACCEPTED = ZMQ_EVENT_ACCEPTED
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_LISTENING); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENT_LISTENING, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":126
+ * EVENT_CONNECT_RETRIED = ZMQ_EVENT_CONNECT_RETRIED
+ * EVENT_LISTENING = ZMQ_EVENT_LISTENING
+ * EVENT_BIND_FAILED = ZMQ_EVENT_BIND_FAILED             # <<<<<<<<<<<<<<
+ * EVENT_ACCEPTED = ZMQ_EVENT_ACCEPTED
+ * EVENT_ACCEPT_FAILED = ZMQ_EVENT_ACCEPT_FAILED
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_BIND_FAILED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENT_BIND_FAILED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":127
+ * EVENT_LISTENING = ZMQ_EVENT_LISTENING
+ * EVENT_BIND_FAILED = ZMQ_EVENT_BIND_FAILED
+ * EVENT_ACCEPTED = ZMQ_EVENT_ACCEPTED             # <<<<<<<<<<<<<<
+ * EVENT_ACCEPT_FAILED = ZMQ_EVENT_ACCEPT_FAILED
+ * EVENT_CLOSED = ZMQ_EVENT_CLOSED
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_ACCEPTED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENT_ACCEPTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":128
+ * EVENT_BIND_FAILED = ZMQ_EVENT_BIND_FAILED
+ * EVENT_ACCEPTED = ZMQ_EVENT_ACCEPTED
+ * EVENT_ACCEPT_FAILED = ZMQ_EVENT_ACCEPT_FAILED             # <<<<<<<<<<<<<<
+ * EVENT_CLOSED = ZMQ_EVENT_CLOSED
+ * EVENT_CLOSE_FAILED = ZMQ_EVENT_CLOSE_FAILED
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_ACCEPT_FAILED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENT_ACCEPT_FAILED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":129
+ * EVENT_ACCEPTED = ZMQ_EVENT_ACCEPTED
+ * EVENT_ACCEPT_FAILED = ZMQ_EVENT_ACCEPT_FAILED
+ * EVENT_CLOSED = ZMQ_EVENT_CLOSED             # <<<<<<<<<<<<<<
+ * EVENT_CLOSE_FAILED = ZMQ_EVENT_CLOSE_FAILED
+ * EVENT_DISCONNECTED = ZMQ_EVENT_DISCONNECTED
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_CLOSED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENT_CLOSED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":130
+ * EVENT_ACCEPT_FAILED = ZMQ_EVENT_ACCEPT_FAILED
+ * EVENT_CLOSED = ZMQ_EVENT_CLOSED
+ * EVENT_CLOSE_FAILED = ZMQ_EVENT_CLOSE_FAILED             # <<<<<<<<<<<<<<
+ * EVENT_DISCONNECTED = ZMQ_EVENT_DISCONNECTED
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_CLOSE_FAILED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENT_CLOSE_FAILED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":131
+ * EVENT_CLOSED = ZMQ_EVENT_CLOSED
+ * EVENT_CLOSE_FAILED = ZMQ_EVENT_CLOSE_FAILED
+ * EVENT_DISCONNECTED = ZMQ_EVENT_DISCONNECTED             # <<<<<<<<<<<<<<
+ * 
+ * FD = ZMQ_FD
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENT_DISCONNECTED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENT_DISCONNECTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":133
+ * EVENT_DISCONNECTED = ZMQ_EVENT_DISCONNECTED
+ * 
+ * FD = ZMQ_FD             # <<<<<<<<<<<<<<
+ * EVENTS = ZMQ_EVENTS
+ * TYPE = ZMQ_TYPE
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_FD); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__FD, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":134
+ * 
+ * FD = ZMQ_FD
+ * EVENTS = ZMQ_EVENTS             # <<<<<<<<<<<<<<
+ * TYPE = ZMQ_TYPE
+ * LINGER = ZMQ_LINGER
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_EVENTS); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EVENTS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":135
+ * FD = ZMQ_FD
+ * EVENTS = ZMQ_EVENTS
+ * TYPE = ZMQ_TYPE             # <<<<<<<<<<<<<<
+ * LINGER = ZMQ_LINGER
+ * RECONNECT_IVL = ZMQ_RECONNECT_IVL
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_TYPE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__TYPE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":136
+ * EVENTS = ZMQ_EVENTS
+ * TYPE = ZMQ_TYPE
+ * LINGER = ZMQ_LINGER             # <<<<<<<<<<<<<<
+ * RECONNECT_IVL = ZMQ_RECONNECT_IVL
+ * BACKLOG = ZMQ_BACKLOG
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_LINGER); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__LINGER, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":137
+ * TYPE = ZMQ_TYPE
+ * LINGER = ZMQ_LINGER
+ * RECONNECT_IVL = ZMQ_RECONNECT_IVL             # <<<<<<<<<<<<<<
+ * BACKLOG = ZMQ_BACKLOG
+ * 
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_RECONNECT_IVL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__RECONNECT_IVL, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":138
+ * LINGER = ZMQ_LINGER
+ * RECONNECT_IVL = ZMQ_RECONNECT_IVL
+ * BACKLOG = ZMQ_BACKLOG             # <<<<<<<<<<<<<<
+ * 
+ * # As new constants are added in future versions, add a new block here
+ */
+  __pyx_t_1 = PyInt_FromLong(ZMQ_BACKLOG); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__BACKLOG, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":151
+ * # Often used standard errnos
+ * from errno import (
+ *     EAGAIN,             # <<<<<<<<<<<<<<
+ *     EINVAL,
+ *     EFAULT,
+ */
+  __pyx_t_1 = PyList_New(5); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__EAGAIN));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__EAGAIN));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__EAGAIN));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__EINVAL));
+  PyList_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_n_s__EINVAL));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__EINVAL));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__EFAULT));
+  PyList_SET_ITEM(__pyx_t_1, 2, ((PyObject *)__pyx_n_s__EFAULT));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__EFAULT));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__ENOMEM));
+  PyList_SET_ITEM(__pyx_t_1, 3, ((PyObject *)__pyx_n_s__ENOMEM));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ENOMEM));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__ENODEV));
+  PyList_SET_ITEM(__pyx_t_1, 4, ((PyObject *)__pyx_n_s__ENODEV));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ENODEV));
+  __pyx_t_3 = __Pyx_Import(((PyObject *)__pyx_n_s__errno), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__EAGAIN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EAGAIN, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__EINVAL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EINVAL, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__EFAULT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EFAULT, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__ENOMEM); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENOMEM, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__ENODEV); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENODEV, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":159
+ * 
+ * # For Windows compatability
+ * ENOTSUP = ZMQ_ENOTSUP             # <<<<<<<<<<<<<<
+ * EPROTONOSUPPORT = ZMQ_EPROTONOSUPPORT
+ * ENOBUFS = ZMQ_ENOBUFS
+ */
+  __pyx_t_3 = PyInt_FromLong(ENOTSUP); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENOTSUP, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":160
+ * # For Windows compatability
+ * ENOTSUP = ZMQ_ENOTSUP
+ * EPROTONOSUPPORT = ZMQ_EPROTONOSUPPORT             # <<<<<<<<<<<<<<
+ * ENOBUFS = ZMQ_ENOBUFS
+ * ENETDOWN = ZMQ_ENETDOWN
+ */
+  __pyx_t_3 = PyInt_FromLong(EPROTONOSUPPORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EPROTONOSUPPORT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":161
+ * ENOTSUP = ZMQ_ENOTSUP
+ * EPROTONOSUPPORT = ZMQ_EPROTONOSUPPORT
+ * ENOBUFS = ZMQ_ENOBUFS             # <<<<<<<<<<<<<<
+ * ENETDOWN = ZMQ_ENETDOWN
+ * EADDRINUSE = ZMQ_EADDRINUSE
+ */
+  __pyx_t_3 = PyInt_FromLong(ENOBUFS); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENOBUFS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":162
+ * EPROTONOSUPPORT = ZMQ_EPROTONOSUPPORT
+ * ENOBUFS = ZMQ_ENOBUFS
+ * ENETDOWN = ZMQ_ENETDOWN             # <<<<<<<<<<<<<<
+ * EADDRINUSE = ZMQ_EADDRINUSE
+ * EADDRNOTAVAIL = ZMQ_EADDRNOTAVAIL
+ */
+  __pyx_t_3 = PyInt_FromLong(ENETDOWN); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENETDOWN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":163
+ * ENOBUFS = ZMQ_ENOBUFS
+ * ENETDOWN = ZMQ_ENETDOWN
+ * EADDRINUSE = ZMQ_EADDRINUSE             # <<<<<<<<<<<<<<
+ * EADDRNOTAVAIL = ZMQ_EADDRNOTAVAIL
+ * ECONNREFUSED = ZMQ_ECONNREFUSED
+ */
+  __pyx_t_3 = PyInt_FromLong(EADDRINUSE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EADDRINUSE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":164
+ * ENETDOWN = ZMQ_ENETDOWN
+ * EADDRINUSE = ZMQ_EADDRINUSE
+ * EADDRNOTAVAIL = ZMQ_EADDRNOTAVAIL             # <<<<<<<<<<<<<<
+ * ECONNREFUSED = ZMQ_ECONNREFUSED
+ * EINPROGRESS = ZMQ_EINPROGRESS
+ */
+  __pyx_t_3 = PyInt_FromLong(EADDRNOTAVAIL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EADDRNOTAVAIL, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":165
+ * EADDRINUSE = ZMQ_EADDRINUSE
+ * EADDRNOTAVAIL = ZMQ_EADDRNOTAVAIL
+ * ECONNREFUSED = ZMQ_ECONNREFUSED             # <<<<<<<<<<<<<<
+ * EINPROGRESS = ZMQ_EINPROGRESS
+ * ENOTSOCK = ZMQ_ENOTSOCK
+ */
+  __pyx_t_3 = PyInt_FromLong(ECONNREFUSED); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ECONNREFUSED, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":166
+ * EADDRNOTAVAIL = ZMQ_EADDRNOTAVAIL
+ * ECONNREFUSED = ZMQ_ECONNREFUSED
+ * EINPROGRESS = ZMQ_EINPROGRESS             # <<<<<<<<<<<<<<
+ * ENOTSOCK = ZMQ_ENOTSOCK
+ * 
+ */
+  __pyx_t_3 = PyInt_FromLong(EINPROGRESS); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EINPROGRESS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":167
+ * ECONNREFUSED = ZMQ_ECONNREFUSED
+ * EINPROGRESS = ZMQ_EINPROGRESS
+ * ENOTSOCK = ZMQ_ENOTSOCK             # <<<<<<<<<<<<<<
+ * 
+ * # new errnos in zmq3
+ */
+  __pyx_t_3 = PyInt_FromLong(ENOTSOCK); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENOTSOCK, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":170
+ * 
+ * # new errnos in zmq3
+ * EMSGSIZE = ZMQ_EMSGSIZE             # <<<<<<<<<<<<<<
+ * EAFNOSUPPORT = ZMQ_EAFNOSUPPORT
+ * ENETUNREACH = ZMQ_ENETUNREACH
+ */
+  __pyx_t_3 = PyInt_FromLong(EMSGSIZE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EMSGSIZE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":171
+ * # new errnos in zmq3
+ * EMSGSIZE = ZMQ_EMSGSIZE
+ * EAFNOSUPPORT = ZMQ_EAFNOSUPPORT             # <<<<<<<<<<<<<<
+ * ENETUNREACH = ZMQ_ENETUNREACH
+ * ECONNABORTED = ZMQ_ECONNABORTED
+ */
+  __pyx_t_3 = PyInt_FromLong(EAFNOSUPPORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EAFNOSUPPORT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":172
+ * EMSGSIZE = ZMQ_EMSGSIZE
+ * EAFNOSUPPORT = ZMQ_EAFNOSUPPORT
+ * ENETUNREACH = ZMQ_ENETUNREACH             # <<<<<<<<<<<<<<
+ * ECONNABORTED = ZMQ_ECONNABORTED
+ * ECONNRESET = ZMQ_ECONNRESET
+ */
+  __pyx_t_3 = PyInt_FromLong(ENETUNREACH); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENETUNREACH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":173
+ * EAFNOSUPPORT = ZMQ_EAFNOSUPPORT
+ * ENETUNREACH = ZMQ_ENETUNREACH
+ * ECONNABORTED = ZMQ_ECONNABORTED             # <<<<<<<<<<<<<<
+ * ECONNRESET = ZMQ_ECONNRESET
+ * ENOTCONN = ZMQ_ENOTCONN
+ */
+  __pyx_t_3 = PyInt_FromLong(ECONNABORTED); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ECONNABORTED, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":174
+ * ENETUNREACH = ZMQ_ENETUNREACH
+ * ECONNABORTED = ZMQ_ECONNABORTED
+ * ECONNRESET = ZMQ_ECONNRESET             # <<<<<<<<<<<<<<
+ * ENOTCONN = ZMQ_ENOTCONN
+ * ETIMEDOUT = ZMQ_ETIMEDOUT
+ */
+  __pyx_t_3 = PyInt_FromLong(ECONNRESET); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ECONNRESET, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":175
+ * ECONNABORTED = ZMQ_ECONNABORTED
+ * ECONNRESET = ZMQ_ECONNRESET
+ * ENOTCONN = ZMQ_ENOTCONN             # <<<<<<<<<<<<<<
+ * ETIMEDOUT = ZMQ_ETIMEDOUT
+ * EHOSTUNREACH = ZMQ_EHOSTUNREACH
+ */
+  __pyx_t_3 = PyInt_FromLong(ENOTCONN); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENOTCONN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":176
+ * ECONNRESET = ZMQ_ECONNRESET
+ * ENOTCONN = ZMQ_ENOTCONN
+ * ETIMEDOUT = ZMQ_ETIMEDOUT             # <<<<<<<<<<<<<<
+ * EHOSTUNREACH = ZMQ_EHOSTUNREACH
+ * ENETRESET = ZMQ_ENETRESET
+ */
+  __pyx_t_3 = PyInt_FromLong(ETIMEDOUT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ETIMEDOUT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":177
+ * ENOTCONN = ZMQ_ENOTCONN
+ * ETIMEDOUT = ZMQ_ETIMEDOUT
+ * EHOSTUNREACH = ZMQ_EHOSTUNREACH             # <<<<<<<<<<<<<<
+ * ENETRESET = ZMQ_ENETRESET
+ * 
+ */
+  __pyx_t_3 = PyInt_FromLong(EHOSTUNREACH); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EHOSTUNREACH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":178
+ * ETIMEDOUT = ZMQ_ETIMEDOUT
+ * EHOSTUNREACH = ZMQ_EHOSTUNREACH
+ * ENETRESET = ZMQ_ENETRESET             # <<<<<<<<<<<<<<
+ * 
+ * # 0MQ Native
+ */
+  __pyx_t_3 = PyInt_FromLong(ENETRESET); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENETRESET, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":181
+ * 
+ * # 0MQ Native
+ * EFSM = ZMQ_EFSM             # <<<<<<<<<<<<<<
+ * ENOCOMPATPROTO = ZMQ_ENOCOMPATPROTO
+ * ETERM = ZMQ_ETERM
+ */
+  __pyx_t_3 = PyInt_FromLong(EFSM); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EFSM, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":182
+ * # 0MQ Native
+ * EFSM = ZMQ_EFSM
+ * ENOCOMPATPROTO = ZMQ_ENOCOMPATPROTO             # <<<<<<<<<<<<<<
+ * ETERM = ZMQ_ETERM
+ * EMTHREAD = ZMQ_EMTHREAD
+ */
+  __pyx_t_3 = PyInt_FromLong(ENOCOMPATPROTO); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ENOCOMPATPROTO, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":183
+ * EFSM = ZMQ_EFSM
+ * ENOCOMPATPROTO = ZMQ_ENOCOMPATPROTO
+ * ETERM = ZMQ_ETERM             # <<<<<<<<<<<<<<
+ * EMTHREAD = ZMQ_EMTHREAD
+ * 
+ */
+  __pyx_t_3 = PyInt_FromLong(ETERM); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ETERM, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":184
+ * ENOCOMPATPROTO = ZMQ_ENOCOMPATPROTO
+ * ETERM = ZMQ_ETERM
+ * EMTHREAD = ZMQ_EMTHREAD             # <<<<<<<<<<<<<<
+ * 
+ * #-----------------------------------------------------------------------------
+ */
+  __pyx_t_3 = PyInt_FromLong(EMTHREAD); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__EMTHREAD, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/constants.pyx":189
+ * # Symbols to export
+ * #-----------------------------------------------------------------------------
+ * _names = list(locals().keys())             # <<<<<<<<<<<<<<
+ * __all__ = [ key for key in _names if not key.startswith('_') ]
+ */
+  __pyx_t_3 = __Pyx_Globals(); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_1 = __Pyx_PyDict_Keys(__pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyObject_Call(((PyObject *)((PyObject*)(&PyList_Type))), ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s___names, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":190
+ * #-----------------------------------------------------------------------------
+ * _names = list(locals().keys())
+ * __all__ = [ key for key in _names if not key.startswith('_') ]             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s___names); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyList_CheckExact(__pyx_t_3) || PyTuple_CheckExact(__pyx_t_3)) {
+    __pyx_t_4 = __pyx_t_3; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
+    __pyx_t_6 = NULL;
+  } else {
+    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext;
+  }
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  for (;;) {
+    if (!__pyx_t_6 && PyList_CheckExact(__pyx_t_4)) {
+      if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
+      #if CYTHON_COMPILING_IN_CPYTHON
+      __pyx_t_3 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_3); __pyx_t_5++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      #else
+      __pyx_t_3 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      #endif
+    } else if (!__pyx_t_6 && PyTuple_CheckExact(__pyx_t_4)) {
+      if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
+      #if CYTHON_COMPILING_IN_CPYTHON
+      __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_3); __pyx_t_5++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      #else
+      __pyx_t_3 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      #endif
+    } else {
+      __pyx_t_3 = __pyx_t_6(__pyx_t_4);
+      if (unlikely(!__pyx_t_3)) {
+        if (PyErr_Occurred()) {
+          if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) PyErr_Clear();
+          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_3);
+    }
+    if (PyDict_SetItem(__pyx_d, __pyx_n_s__key, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__key); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s__startswith); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_7);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(__pyx_t_7, ((PyObject *)__pyx_k_tuple_5), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_8 = (!__pyx_t_2);
+    if (__pyx_t_8) {
+      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__key); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_3))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+  }
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+
+  /* "zmq/core/constants.pyx":1
+ * """0MQ Constants."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_7);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core.constants", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core.constants");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON
+    result = PyDict_GetItem(__pyx_d, name);
+    if (result) {
+        Py_INCREF(result);
+    } else {
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    if (!result) {
+        PyErr_Clear();
+#endif
+        result = __Pyx_GetBuiltinName(name);
+    }
+    return result;
+}
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+#if PY_MAJOR_VERSION >= 3
+static CYTHON_INLINE PyObject* __Pyx_PyDict_Keys(PyObject* d) {
+    return PyObject_CallMethodObjArgs(d, __pyx_n_s__keys, NULL);
+}
+#endif
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_VERSION_HEX < 0x03030000
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    #if PY_VERSION_HEX >= 0x02050000
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if (strchr(__Pyx_MODULE_NAME, '.')) {
+                #if PY_VERSION_HEX < 0x03030000
+                PyObject *py_level = PyInt_FromLong(1);
+                if (!py_level)
+                    goto bad;
+                module = PyObject_CallFunctionObjArgs(py_import,
+                    name, global_dict, empty_dict, list, py_level, NULL);
+                Py_DECREF(py_level);
+                #else
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                #endif
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0; /* try absolute import on failure */
+        }
+        #endif
+        if (!module) {
+            #if PY_VERSION_HEX < 0x03030000
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+    #else
+    if (level>0) {
+        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
+        goto bad;
+    }
+    module = PyObject_CallFunctionObjArgs(py_import,
+        name, global_dict, empty_dict, list, NULL);
+    #endif
+bad:
+    #if PY_VERSION_HEX < 0x03030000
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static PyObject* __Pyx_Globals(void) {
+    Py_ssize_t i;
+    PyObject *names = NULL;
+    PyObject *globals = PyObject_GetAttr(__pyx_m, __pyx_n_s____dict__);
+    if (!globals) {
+        PyErr_SetString(PyExc_TypeError,
+            "current module must have __dict__ attribute");
+        goto bad;
+    }
+    names = PyObject_Dir(__pyx_m);
+    if (!names)
+        goto bad;
+    for (i = PyList_GET_SIZE(names)-1; i >= 0; i--) {
+#if CYTHON_COMPILING_IN_PYPY
+        PyObject* name = PySequence_GetItem(names, i);
+        if (!name)
+            goto bad;
+#else
+        PyObject* name = PyList_GET_ITEM(names, i);
+#endif
+        if (!PyDict_Contains(globals, name)) {
+            PyObject* value = PyObject_GetAttr(__pyx_m, name);
+            if (!value) {
+#if CYTHON_COMPILING_IN_PYPY
+                Py_DECREF(name);
+#endif
+                goto bad;
+            }
+            if (PyDict_SetItem(globals, name, value) < 0) {
+#if CYTHON_COMPILING_IN_PYPY
+                Py_DECREF(name);
+#endif
+                Py_DECREF(value);
+                goto bad;
+            }
+        }
+#if CYTHON_COMPILING_IN_PYPY
+        Py_DECREF(name);
+#endif
+    }
+    Py_DECREF(names);
+    return globals;
+bad:
+    Py_XDECREF(names);
+    Py_XDECREF(globals);
+    return NULL;
+}
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
--- /dev/null
+++ pyzmq-13.1.0/zmq/core/_version.c
@@ -0,0 +1,1837 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core___version
+#define __PYX_HAVE_API__zmq__core___version
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "_version.pyx",
+};
+
+/*--- Type declarations ---*/
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static int __Pyx_check_binary_version(void);
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'zmq.core._version' */
+#define __Pyx_MODULE_NAME "zmq.core._version"
+int __pyx_module_is_main_zmq__core___version = 0;
+
+/* Implementation of 'zmq.core._version' */
+static PyObject *__pyx_pf_3zmq_4core_8_version_zmq_version_info(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
+static char __pyx_k_1[] = "PyZMQ and 0MQ version functions.";
+static char __pyx_k_4[] = "/private/tmp/pyzmq/zmq/core/_version.pyx";
+static char __pyx_k_5[] = "zmq.core._version";
+static char __pyx_k__major[] = "major";
+static char __pyx_k__minor[] = "minor";
+static char __pyx_k__patch[] = "patch";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__zmq_version_info[] = "zmq_version_info";
+static PyObject *__pyx_kp_s_4;
+static PyObject *__pyx_n_s_5;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s__major;
+static PyObject *__pyx_n_s__minor;
+static PyObject *__pyx_n_s__patch;
+static PyObject *__pyx_n_s__zmq_version_info;
+static PyObject *__pyx_k_tuple_2;
+static PyObject *__pyx_k_codeobj_3;
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_8_version_1zmq_version_info(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_8_version_zmq_version_info[] = "zmq_version_info()\n\n    Return the version of ZeroMQ itself as a 3-tuple of ints.\n    ";
+static PyMethodDef __pyx_mdef_3zmq_4core_8_version_1zmq_version_info = {__Pyx_NAMESTR("zmq_version_info"), (PyCFunction)__pyx_pw_3zmq_4core_8_version_1zmq_version_info, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_8_version_zmq_version_info)};
+static PyObject *__pyx_pw_3zmq_4core_8_version_1zmq_version_info(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("zmq_version_info (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_8_version_zmq_version_info(__pyx_self);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/_version.pyx":32
+ * #-----------------------------------------------------------------------------
+ * 
+ * def zmq_version_info():             # <<<<<<<<<<<<<<
+ *     """zmq_version_info()
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_8_version_zmq_version_info(CYTHON_UNUSED PyObject *__pyx_self) {
+  int __pyx_v_major;
+  int __pyx_v_minor;
+  int __pyx_v_patch;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("zmq_version_info", 0);
+
+  /* "zmq/core/_version.pyx":38
+ *     """
+ *     cdef int major, minor, patch
+ *     _zmq_version(&major, &minor, &patch)             # <<<<<<<<<<<<<<
+ *     return (major, minor, patch)
+ * 
+ */
+  zmq_version((&__pyx_v_major), (&__pyx_v_minor), (&__pyx_v_patch));
+
+  /* "zmq/core/_version.pyx":39
+ *     cdef int major, minor, patch
+ *     _zmq_version(&major, &minor, &patch)
+ *     return (major, minor, patch)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyInt_FromLong(__pyx_v_major); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyInt_FromLong(__pyx_v_minor); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyInt_FromLong(__pyx_v_patch); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  __pyx_t_1 = 0;
+  __pyx_t_2 = 0;
+  __pyx_t_3 = 0;
+  __pyx_r = ((PyObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core._version.zmq_version_info", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("_version"),
+    __Pyx_DOCSTR(__pyx_k_1), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_s_4, __pyx_k_4, sizeof(__pyx_k_4), 0, 0, 1, 0},
+  {&__pyx_n_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s__major, __pyx_k__major, sizeof(__pyx_k__major), 0, 0, 1, 1},
+  {&__pyx_n_s__minor, __pyx_k__minor, sizeof(__pyx_k__minor), 0, 0, 1, 1},
+  {&__pyx_n_s__patch, __pyx_k__patch, sizeof(__pyx_k__patch), 0, 0, 1, 1},
+  {&__pyx_n_s__zmq_version_info, __pyx_k__zmq_version_info, sizeof(__pyx_k__zmq_version_info), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  return 0;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/_version.pyx":32
+ * #-----------------------------------------------------------------------------
+ * 
+ * def zmq_version_info():             # <<<<<<<<<<<<<<
+ *     """zmq_version_info()
+ * 
+ */
+  __pyx_k_tuple_2 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__major), ((PyObject *)__pyx_n_s__minor), ((PyObject *)__pyx_n_s__patch)); if (unlikely(!__pyx_k_tuple_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_2);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_2));
+  __pyx_k_codeobj_3 = (PyObject*)__Pyx_PyCode_New(0, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_2, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_4, __pyx_n_s__zmq_version_info, 32, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC init_version(void); /*proto*/
+PyMODINIT_FUNC init_version(void)
+#else
+PyMODINIT_FUNC PyInit__version(void); /*proto*/
+PyMODINIT_FUNC PyInit__version(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__version(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("_version"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_1), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core._version")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core._version", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core___version) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  /*--- Type import code ---*/
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/_version.pyx":32
+ * #-----------------------------------------------------------------------------
+ * 
+ * def zmq_version_info():             # <<<<<<<<<<<<<<
+ *     """zmq_version_info()
+ * 
+ */
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3zmq_4core_8_version_1zmq_version_info, NULL, __pyx_n_s_5); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__zmq_version_info, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/_version.pyx":42
+ * 
+ * 
+ * __all__ = ['zmq_version_info']             # <<<<<<<<<<<<<<
+ * 
+ */
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__zmq_version_info));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__zmq_version_info));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__zmq_version_info));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+
+  /* "zmq/core/_version.pyx":1
+ * """PyZMQ and 0MQ version functions."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core._version", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core._version");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
--- /dev/null
+++ pyzmq-13.1.0/zmq/core/error.c
@@ -0,0 +1,2154 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core__error
+#define __PYX_HAVE_API__zmq__core__error
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "error.pyx",
+};
+
+/*--- Type declarations ---*/
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
+         const char* cstring, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));
+
+#include <string.h>
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static int __Pyx_check_binary_version(void);
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'zmq.core.error' */
+#define __Pyx_MODULE_NAME "zmq.core.error"
+int __pyx_module_is_main_zmq__core__error = 0;
+
+/* Implementation of 'zmq.core.error' */
+static PyObject *__pyx_pf_3zmq_4core_5error_strerror(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_errno); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_5error_2zmq_errno(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
+static char __pyx_k_1[] = "0MQ Error classes and functions.";
+static char __pyx_k_2[] = "zmq.utils.strtypes";
+static char __pyx_k_5[] = "/private/tmp/pyzmq/zmq/core/error.pyx";
+static char __pyx_k_6[] = "zmq.core.error";
+static char __pyx_k__bytes[] = "bytes";
+static char __pyx_k__errno[] = "errno";
+static char __pyx_k__str_e[] = "str_e";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__strerror[] = "strerror";
+static char __pyx_k__zmq_errno[] = "zmq_errno";
+static char __pyx_k____import__[] = "__import__";
+static PyObject *__pyx_n_s_2;
+static PyObject *__pyx_kp_s_5;
+static PyObject *__pyx_n_s_6;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____import__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s__bytes;
+static PyObject *__pyx_n_s__errno;
+static PyObject *__pyx_n_s__str_e;
+static PyObject *__pyx_n_s__strerror;
+static PyObject *__pyx_n_s__zmq_errno;
+static PyObject *__pyx_k_tuple_3;
+static PyObject *__pyx_k_codeobj_4;
+static PyObject *__pyx_k_codeobj_7;
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_5error_1strerror(PyObject *__pyx_self, PyObject *__pyx_arg_errno); /*proto*/
+static char __pyx_doc_3zmq_4core_5error_strerror[] = "strerror(errno)\n\n    Return the error string given the error number.\n    ";
+static PyMethodDef __pyx_mdef_3zmq_4core_5error_1strerror = {__Pyx_NAMESTR("strerror"), (PyCFunction)__pyx_pw_3zmq_4core_5error_1strerror, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_5error_strerror)};
+static PyObject *__pyx_pw_3zmq_4core_5error_1strerror(PyObject *__pyx_self, PyObject *__pyx_arg_errno) {
+  int __pyx_v_errno;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("strerror (wrapper)", 0);
+  assert(__pyx_arg_errno); {
+    __pyx_v_errno = __Pyx_PyInt_AsInt(__pyx_arg_errno); if (unlikely((__pyx_v_errno == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.error.strerror", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_5error_strerror(__pyx_self, ((int)__pyx_v_errno));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/error.pyx":34
+ * from zmq.utils.strtypes import bytes
+ * 
+ * def strerror(int errno):             # <<<<<<<<<<<<<<
+ *     """strerror(errno)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_5error_strerror(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_errno) {
+  const char* __pyx_v_str_e;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("strerror", 0);
+
+  /* "zmq/core/error.pyx":41
+ *     cdef const_char_ptr str_e
+ *     # char * will be a bytes object:
+ *     str_e = zmq_strerror(errno)             # <<<<<<<<<<<<<<
+ *     if str is bytes:
+ *         # Python 2: str is bytes, so we already have the right type
+ */
+  __pyx_v_str_e = zmq_strerror(__pyx_v_errno);
+
+  /* "zmq/core/error.pyx":42
+ *     # char * will be a bytes object:
+ *     str_e = zmq_strerror(errno)
+ *     if str is bytes:             # <<<<<<<<<<<<<<
+ *         # Python 2: str is bytes, so we already have the right type
+ *         return str_e
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__bytes); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = (((PyObject*)(&PyString_Type)) == ((PyObject*)__pyx_t_1));
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "zmq/core/error.pyx":44
+ *     if str is bytes:
+ *         # Python 2: str is bytes, so we already have the right type
+ *         return str_e             # <<<<<<<<<<<<<<
+ *     else:
+ *         # Python 3: decode bytes to unicode str
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_str_e); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __pyx_r = ((PyObject *)__pyx_t_1);
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/error.pyx":47
+ *     else:
+ *         # Python 3: decode bytes to unicode str
+ *         return str_e.decode()             # <<<<<<<<<<<<<<
+ * 
+ * def zmq_errno():
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__Pyx_decode_c_string(__pyx_v_str_e, 0, strlen(__pyx_v_str_e), NULL, NULL, NULL)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 47; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __pyx_r = ((PyObject *)__pyx_t_1);
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.error.strerror", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_5error_3zmq_errno(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_5error_2zmq_errno[] = "zmq_errno()\n    \n    Return the integer errno of the most recent zmq error.\n    ";
+static PyMethodDef __pyx_mdef_3zmq_4core_5error_3zmq_errno = {__Pyx_NAMESTR("zmq_errno"), (PyCFunction)__pyx_pw_3zmq_4core_5error_3zmq_errno, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_5error_2zmq_errno)};
+static PyObject *__pyx_pw_3zmq_4core_5error_3zmq_errno(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("zmq_errno (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_5error_2zmq_errno(__pyx_self);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/error.pyx":49
+ *         return str_e.decode()
+ * 
+ * def zmq_errno():             # <<<<<<<<<<<<<<
+ *     """zmq_errno()
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_5error_2zmq_errno(CYTHON_UNUSED PyObject *__pyx_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("zmq_errno", 0);
+
+  /* "zmq/core/error.pyx":54
+ *     Return the integer errno of the most recent zmq error.
+ *     """
+ *     return zmq_errno_c()             # <<<<<<<<<<<<<<
+ * 
+ * __all__ = ['strerror', 'zmq_errno']
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyInt_FromLong(zmq_errno()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.error.zmq_errno", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("error"),
+    __Pyx_DOCSTR(__pyx_k_1), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_n_s_2, __pyx_k_2, sizeof(__pyx_k_2), 0, 0, 1, 1},
+  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
+  {&__pyx_n_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s__bytes, __pyx_k__bytes, sizeof(__pyx_k__bytes), 0, 0, 1, 1},
+  {&__pyx_n_s__errno, __pyx_k__errno, sizeof(__pyx_k__errno), 0, 0, 1, 1},
+  {&__pyx_n_s__str_e, __pyx_k__str_e, sizeof(__pyx_k__str_e), 0, 0, 1, 1},
+  {&__pyx_n_s__strerror, __pyx_k__strerror, sizeof(__pyx_k__strerror), 0, 0, 1, 1},
+  {&__pyx_n_s__zmq_errno, __pyx_k__zmq_errno, sizeof(__pyx_k__zmq_errno), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  return 0;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/error.pyx":34
+ * from zmq.utils.strtypes import bytes
+ * 
+ * def strerror(int errno):             # <<<<<<<<<<<<<<
+ *     """strerror(errno)
+ * 
+ */
+  __pyx_k_tuple_3 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__errno), ((PyObject *)__pyx_n_s__errno), ((PyObject *)__pyx_n_s__str_e)); if (unlikely(!__pyx_k_tuple_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_3);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_3));
+  __pyx_k_codeobj_4 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_3, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_5, __pyx_n_s__strerror, 34, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/error.pyx":49
+ *         return str_e.decode()
+ * 
+ * def zmq_errno():             # <<<<<<<<<<<<<<
+ *     """zmq_errno()
+ * 
+ */
+  __pyx_k_codeobj_7 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_5, __pyx_n_s__zmq_errno, 49, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC initerror(void); /*proto*/
+PyMODINIT_FUNC initerror(void)
+#else
+PyMODINIT_FUNC PyInit_error(void); /*proto*/
+PyMODINIT_FUNC PyInit_error(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_error(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("error"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_1), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core.error")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core.error", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core__error) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  /*--- Type import code ---*/
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/error.pyx":32
+ * from libzmq cimport zmq_strerror, zmq_errno as zmq_errno_c
+ * 
+ * from zmq.utils.strtypes import bytes             # <<<<<<<<<<<<<<
+ * 
+ * def strerror(int errno):
+ */
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__bytes));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__bytes));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__bytes));
+  __pyx_t_2 = __Pyx_Import(((PyObject *)__pyx_n_s_2), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s__bytes); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__bytes, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "zmq/core/error.pyx":34
+ * from zmq.utils.strtypes import bytes
+ * 
+ * def strerror(int errno):             # <<<<<<<<<<<<<<
+ *     """strerror(errno)
+ * 
+ */
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_3zmq_4core_5error_1strerror, NULL, __pyx_n_s_6); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__strerror, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "zmq/core/error.pyx":49
+ *         return str_e.decode()
+ * 
+ * def zmq_errno():             # <<<<<<<<<<<<<<
+ *     """zmq_errno()
+ * 
+ */
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_3zmq_4core_5error_3zmq_errno, NULL, __pyx_n_s_6); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__zmq_errno, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "zmq/core/error.pyx":56
+ *     return zmq_errno_c()
+ * 
+ * __all__ = ['strerror', 'zmq_errno']             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__strerror));
+  PyList_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_n_s__strerror));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__strerror));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__zmq_errno));
+  PyList_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_n_s__zmq_errno));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__zmq_errno));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+
+  /* "zmq/core/error.pyx":1
+ * """0MQ Error classes and functions."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core.error", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core.error");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON
+    result = PyDict_GetItem(__pyx_d, name);
+    if (result) {
+        Py_INCREF(result);
+    } else {
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    if (!result) {
+        PyErr_Clear();
+#endif
+        result = __Pyx_GetBuiltinName(name);
+    }
+    return result;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
+         const char* cstring, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    Py_ssize_t length;
+    if (unlikely((start < 0) | (stop < 0))) {
+        length = strlen(cstring);
+        if (start < 0) {
+            start += length;
+            if (start < 0)
+                start = 0;
+        }
+        if (stop < 0)
+            stop += length;
+    }
+    length = stop - start;
+    if (unlikely(length <= 0))
+        return PyUnicode_FromUnicode(NULL, 0);
+    cstring += start;
+    if (decode_func) {
+        return decode_func(cstring, length, errors);
+    } else {
+        return PyUnicode_Decode(cstring, length, encoding, errors);
+    }
+}
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_VERSION_HEX < 0x03030000
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    #if PY_VERSION_HEX >= 0x02050000
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if (strchr(__Pyx_MODULE_NAME, '.')) {
+                #if PY_VERSION_HEX < 0x03030000
+                PyObject *py_level = PyInt_FromLong(1);
+                if (!py_level)
+                    goto bad;
+                module = PyObject_CallFunctionObjArgs(py_import,
+                    name, global_dict, empty_dict, list, py_level, NULL);
+                Py_DECREF(py_level);
+                #else
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                #endif
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0; /* try absolute import on failure */
+        }
+        #endif
+        if (!module) {
+            #if PY_VERSION_HEX < 0x03030000
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+    #else
+    if (level>0) {
+        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
+        goto bad;
+    }
+    module = PyObject_CallFunctionObjArgs(py_import,
+        name, global_dict, empty_dict, list, NULL);
+    #endif
+bad:
+    #if PY_VERSION_HEX < 0x03030000
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
--- /dev/null
+++ pyzmq-13.1.0/zmq/core/socket.c
@@ -0,0 +1,11288 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core__socket
+#define __PYX_HAVE_API__zmq__core__socket
+#include "pyversion_compat.h"
+#include "errno.h"
+#include "string.h"
+#include "stdio.h"
+#include "pythread.h"
+#include "datetime.h"
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#include "ipcmaxlen.h"
+#include "getpid_compat.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "socket.pyx",
+  "socket.pxd",
+  "checkrc.pxd",
+  "message.pxd",
+  "buffers.pxd",
+  "datetime.pxd",
+  "context.pxd",
+  "type.pxd",
+  "bool.pxd",
+  "complex.pxd",
+};
+
+/*--- Type declarations ---*/
+struct __pyx_obj_3zmq_4core_6socket_Socket;
+struct __pyx_obj_3zmq_4core_7message_Frame;
+struct __pyx_obj_3zmq_4core_7message_MessageTracker;
+struct __pyx_obj_3zmq_4core_7context_Context;
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send;
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv;
+struct __pyx_opt_args_3zmq_4core_6socket__recv_frame;
+struct __pyx_opt_args_3zmq_4core_6socket__recv_copy;
+struct __pyx_opt_args_3zmq_4core_6socket__send_frame;
+struct __pyx_opt_args_3zmq_4core_6socket__send_copy;
+
+/* "zmq/core/socket.pxd":46
+ * 
+ *     # cpdef methods for direct-cython access:
+ *     cpdef object send(self, object data, int flags=*, copy=*, track=*)             # <<<<<<<<<<<<<<
+ *     cpdef object recv(self, int flags=*, copy=*, track=*)
+ * 
+ */
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send {
+  int __pyx_n;
+  int flags;
+  PyObject *copy;
+  PyObject *track;
+};
+
+/* "zmq/core/socket.pxd":47
+ *     # cpdef methods for direct-cython access:
+ *     cpdef object send(self, object data, int flags=*, copy=*, track=*)
+ *     cpdef object recv(self, int flags=*, copy=*, track=*)             # <<<<<<<<<<<<<<
+ * 
+ */
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv {
+  int __pyx_n;
+  int flags;
+  PyObject *copy;
+  PyObject *track;
+};
+
+/* "zmq/core/socket.pyx":112
+ *     return False
+ * 
+ * cdef inline Frame _recv_frame(void *handle, int flags=0, track=False):             # <<<<<<<<<<<<<<
+ *     """Receive a message in a non-copying manner and return a Frame."""
+ *     cdef int rc
+ */
+struct __pyx_opt_args_3zmq_4core_6socket__recv_frame {
+  int __pyx_n;
+  int flags;
+  PyObject *track;
+};
+
+/* "zmq/core/socket.pyx":124
+ *     return msg
+ * 
+ * cdef inline object _recv_copy(void *handle, int flags=0):             # <<<<<<<<<<<<<<
+ *     """Receive a message and return a copy"""
+ *     cdef zmq_msg_t zmq_msg
+ */
+struct __pyx_opt_args_3zmq_4core_6socket__recv_copy {
+  int __pyx_n;
+  int flags;
+};
+
+/* "zmq/core/socket.pyx":136
+ *     return msg_bytes
+ * 
+ * cdef inline object _send_frame(void *handle, Frame msg, int flags=0):             # <<<<<<<<<<<<<<
+ *     """Send a Frame on this socket in a non-copy manner."""
+ *     cdef int rc
+ */
+struct __pyx_opt_args_3zmq_4core_6socket__send_frame {
+  int __pyx_n;
+  int flags;
+};
+
+/* "zmq/core/socket.pyx":152
+ * 
+ * 
+ * cdef inline object _send_copy(void *handle, object msg, int flags=0):             # <<<<<<<<<<<<<<
+ *     """Send a message on this socket by copying its content."""
+ *     cdef int rc, rc2
+ */
+struct __pyx_opt_args_3zmq_4core_6socket__send_copy {
+  int __pyx_n;
+  int flags;
+};
+
+/* "zmq/core/socket.pxd":33
+ * 
+ * 
+ * cdef class Socket:             # <<<<<<<<<<<<<<
+ *     """A 0MQ socket."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_6socket_Socket {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_6socket_Socket *__pyx_vtab;
+  PyObject *__weakref__;
+  void *handle;
+  int socket_type;
+  struct __pyx_obj_3zmq_4core_7context_Context *context;
+  int _closed;
+  int _pid;
+};
+
+
+/* "message.pxd":41
+ * 
+ * 
+ * cdef class Frame:             # <<<<<<<<<<<<<<
+ *     """A Message Frame class for non-copy send/recvs."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_7message_Frame {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_7message_Frame *__pyx_vtab;
+  zmq_msg_t zmq_msg;
+  PyObject *_data;
+  PyObject *_buffer;
+  PyObject *_bytes;
+  int _failed_init;
+  PyObject *tracker_event;
+  PyObject *tracker;
+  int more;
+};
+
+
+/* "message.pxd":34
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class MessageTracker(object):             # <<<<<<<<<<<<<<
+ *     """A class for tracking if 0MQ is done using one or more messages."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_7message_MessageTracker {
+  PyObject_HEAD
+  PyObject *events;
+  PyObject *peers;
+};
+
+
+/* "context.pxd":26
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class Context:             # <<<<<<<<<<<<<<
+ *     """Manage the lifecycle of a 0MQ context."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_7context_Context {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_7context_Context *__pyx_vtab;
+  PyObject *__weakref__;
+  void *handle;
+  void **_sockets;
+  size_t _n_sockets;
+  size_t _max_sockets;
+  int _pid;
+  PyObject *closed;
+};
+
+
+
+/* "zmq/core/socket.pyx":178
+ * 
+ * 
+ * cdef class Socket:             # <<<<<<<<<<<<<<
+ *     """Socket(context, socket_type)
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_6socket_Socket {
+  PyObject *(*send)(struct __pyx_obj_3zmq_4core_6socket_Socket *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send *__pyx_optional_args);
+  PyObject *(*recv)(struct __pyx_obj_3zmq_4core_6socket_Socket *, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv *__pyx_optional_args);
+};
+static struct __pyx_vtabstruct_3zmq_4core_6socket_Socket *__pyx_vtabptr_3zmq_4core_6socket_Socket;
+
+
+/* "context.pxd":26
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class Context:             # <<<<<<<<<<<<<<
+ *     """Manage the lifecycle of a 0MQ context."""
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_7context_Context {
+  void (*_add_socket)(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+  void (*_remove_socket)(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+};
+static struct __pyx_vtabstruct_3zmq_4core_7context_Context *__pyx_vtabptr_3zmq_4core_7context_Context;
+
+
+/* "message.pxd":41
+ * 
+ * 
+ * cdef class Frame:             # <<<<<<<<<<<<<<
+ *     """A Message Frame class for non-copy send/recvs."""
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_7message_Frame {
+  struct __pyx_obj_3zmq_4core_7message_Frame *(*fast_copy)(struct __pyx_obj_3zmq_4core_7message_Frame *);
+  PyObject *(*_getbuffer)(struct __pyx_obj_3zmq_4core_7message_Frame *);
+};
+static struct __pyx_vtabstruct_3zmq_4core_7message_Frame *__pyx_vtabptr_3zmq_4core_7message_Frame;
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
+
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
+
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/
+
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
+    const char* function_name); /*proto*/
+
+static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
+    const char *name, int exact); /*proto*/
+
+static CYTHON_INLINE int __Pyx_PySequence_Contains(PyObject* item, PyObject* seq, int eq) {
+    int result = PySequence_Contains(seq, item);
+    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
+}
+
+#define __Pyx_GetItemInt(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_Fast(o, i, is_list, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+#define __Pyx_GetItemInt_List(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_List_Fast(o, i, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+#define __Pyx_GetItemInt_Tuple(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_Tuple_Fast(o, i, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck);
+
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+
+#ifndef __PYX_FORCE_INIT_THREADS
+  #define __PYX_FORCE_INIT_THREADS 0
+#endif
+
+static CYTHON_INLINE pyzmq_int64_t __Pyx_PyInt_from_py_pyzmq_int64_t(PyObject *);
+
+static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_pyzmq_int64_t(pyzmq_int64_t);
+
+static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_ZMQ_FD_T(ZMQ_FD_T);
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static CYTHON_INLINE int __Pyx_StrEq(const char *, const char *); /*proto*/
+
+static int __Pyx_check_binary_version(void);
+
+static int __Pyx_SetVtable(PyObject *dict, void *vtable); /*proto*/
+
+#if !defined(__Pyx_PyIdentifier_FromString)
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
+#else
+  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
+#endif
+#endif
+
+static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
+
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/
+
+static void* __Pyx_GetVtable(PyObject *dict); /*proto*/
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'zmq.core.context' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_7context_Context = 0;
+
+/* Module declarations from 'libc.errno' */
+
+/* Module declarations from 'libc.string' */
+
+/* Module declarations from 'cpython.version' */
+
+/* Module declarations from 'cpython.ref' */
+
+/* Module declarations from 'cpython.exc' */
+
+/* Module declarations from 'cpython.module' */
+
+/* Module declarations from 'cpython.mem' */
+
+/* Module declarations from 'cpython.tuple' */
+
+/* Module declarations from 'cpython.list' */
+
+/* Module declarations from 'libc.stdio' */
+
+/* Module declarations from 'cpython.object' */
+
+/* Module declarations from 'cpython.sequence' */
+
+/* Module declarations from 'cpython.mapping' */
+
+/* Module declarations from 'cpython.iterator' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.type' */
+static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
+
+/* Module declarations from 'cpython.number' */
+
+/* Module declarations from 'cpython.int' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.bool' */
+static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;
+
+/* Module declarations from 'cpython.long' */
+
+/* Module declarations from 'cpython.float' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.complex' */
+static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;
+
+/* Module declarations from 'cpython.string' */
+
+/* Module declarations from 'cpython.unicode' */
+
+/* Module declarations from 'cpython.dict' */
+
+/* Module declarations from 'cpython.instance' */
+
+/* Module declarations from 'cpython.function' */
+
+/* Module declarations from 'cpython.method' */
+
+/* Module declarations from 'cpython.weakref' */
+
+/* Module declarations from 'cpython.getargs' */
+
+/* Module declarations from 'cpython.pythread' */
+
+/* Module declarations from 'cpython.pystate' */
+
+/* Module declarations from 'cpython.cobject' */
+
+/* Module declarations from 'cpython.oldbuffer' */
+
+/* Module declarations from 'cpython.set' */
+
+/* Module declarations from 'cpython.buffer' */
+
+/* Module declarations from 'cpython.bytes' */
+
+/* Module declarations from 'cpython.pycapsule' */
+
+/* Module declarations from 'datetime' */
+
+/* Module declarations from 'cpython.datetime' */
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_date = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_time = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_datetime = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_timedelta = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_tzinfo = 0;
+
+/* Module declarations from 'cpython' */
+
+/* Module declarations from 'buffers' */
+static CYTHON_INLINE int __pyx_f_7buffers_memoryview_available(void); /*proto*/
+static CYTHON_INLINE int __pyx_f_7buffers_oldstyle_available(void); /*proto*/
+static CYTHON_INLINE int __pyx_f_7buffers_check_buffer(PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer(PyObject *, int, int, void **, Py_ssize_t *, Py_ssize_t *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer_r(PyObject *, void **, Py_ssize_t *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_3(void *, Py_ssize_t, int); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_2(void *, Py_ssize_t, int); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer(void *, Py_ssize_t, int); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject(PyObject *, int); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject_r(PyObject *); /*proto*/
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'zmq.core.message' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_7message_MessageTracker = 0;
+static PyTypeObject *__pyx_ptype_3zmq_4core_7message_Frame = 0;
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_7message_copy_zmq_msg_bytes(zmq_msg_t *); /*proto*/
+
+/* Module declarations from 'zmq.core.checkrc' */
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int); /*proto*/
+
+/* Module declarations from 'zmq.core.socket' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_6socket_Socket = 0;
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_6socket__check_closed(struct __pyx_obj_3zmq_4core_6socket_Socket *, int); /*proto*/
+static CYTHON_INLINE struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_f_3zmq_4core_6socket__recv_frame(void *, struct __pyx_opt_args_3zmq_4core_6socket__recv_frame *__pyx_optional_args); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_6socket__recv_copy(void *, struct __pyx_opt_args_3zmq_4core_6socket__recv_copy *__pyx_optional_args); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_6socket__send_frame(void *, struct __pyx_obj_3zmq_4core_7message_Frame *, struct __pyx_opt_args_3zmq_4core_6socket__send_frame *__pyx_optional_args); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_6socket__send_copy(void *, PyObject *, struct __pyx_opt_args_3zmq_4core_6socket__send_copy *__pyx_optional_args); /*proto*/
+#define __Pyx_MODULE_NAME "zmq.core.socket"
+int __pyx_module_is_main_zmq__core__socket = 0;
+
+/* Implementation of 'zmq.core.socket' */
+static PyObject *__pyx_builtin_property;
+static PyObject *__pyx_builtin_TypeError;
+static PyObject *__pyx_builtin_NotImplementedError;
+static PyObject *__pyx_builtin_ValueError;
+static PyObject *__pyx_builtin_AttributeError;
+static int __pyx_pf_3zmq_4core_6socket_6Socket___cinit__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_context, int __pyx_v_socket_type, CYTHON_UNUSED PyObject *__pyx_v_args, CYTHON_UNUSED PyObject *__pyx_v_kwrags); /* proto */
+static void __pyx_pf_3zmq_4core_6socket_6Socket_2__dealloc__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_6socket_6Socket_4__init__(CYTHON_UNUSED struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_context, CYTHON_UNUSED PyObject *__pyx_v_socket_type); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_6closed(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_8close(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_linger); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_10set(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, int __pyx_v_option, PyObject *__pyx_v_optval); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_12get(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, int __pyx_v_option); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_14bind(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_addr); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_16connect(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_addr); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_18unbind(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_addr); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_20disconnect(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_addr); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_22send(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_v_flags, PyObject *__pyx_v_copy, PyObject *__pyx_v_track); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_24recv(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, int __pyx_v_flags, PyObject *__pyx_v_copy, PyObject *__pyx_v_track); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_11socket_type___get__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_6socket_6Socket_11socket_type_2__set__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_7context___get__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_6socket_6Socket_7context_2__set__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
+static int __pyx_pf_3zmq_4core_6socket_6Socket_7context_4__del__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_7_closed___get__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_6socket_6Socket_7_closed_2__set__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
+static PyObject *__pyx_tp_new_3zmq_4core_6socket_Socket(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static char __pyx_k_2[] = "unicode not allowed, use setsockopt_string";
+static char __pyx_k_4[] = "expected bytes, got: %r";
+static char __pyx_k_5[] = "expected int, got: %r";
+static char __pyx_k_6[] = "utf-8";
+static char __pyx_k_8[] = "expected str, got: %r";
+static char __pyx_k_10[] = "://";
+static char __pyx_k_12[] = "ipc path \"{0}\" is longer than {1} characters (sizeof(sockaddr_un.sun_path)). zmq.IPC_PATH_MAX_LEN constant can be used to check addr length (if it is defined).";
+static char __pyx_k_14[] = "unbind requires libzmq >= 3.0, have %s";
+static char __pyx_k_16[] = "disconnect requires libzmq >= 3.0, have %s";
+static char __pyx_k_20[] = "unicode not allowed, use send_unicode";
+static char __pyx_k_22[] = "Not a tracked message";
+static char __pyx_k_26[] = "zmq.error";
+static char __pyx_k_27[] = "%r does not provide a buffer interface.";
+static char __pyx_k_29[] = "";
+static char __pyx_k_30[] = "Old style buffers not available.";
+static char __pyx_k_32[] = "0MQ Socket class.";
+static char __pyx_k_33[] = "zmq.utils";
+static char __pyx_k_34[] = "zmq.core";
+static char __pyx_k_35[] = "zmq.core.constants";
+static char __pyx_k_36[] = "*";
+static char __pyx_k_37[] = "zmq.utils.strtypes";
+static char __pyx_k__B[] = "B";
+static char __pyx_k__msg[] = "msg";
+static char __pyx_k__sys[] = "sys";
+static char __pyx_k__zmq[] = "zmq";
+static char __pyx_k__char[] = "char";
+static char __pyx_k__copy[] = "copy";
+static char __pyx_k__data[] = "data";
+static char __pyx_k__recv[] = "recv";
+static char __pyx_k__send[] = "send";
+static char __pyx_k__time[] = "time";
+static char __pyx_k__Again[] = "Again";
+static char __pyx_k__ascii[] = "ascii";
+static char __pyx_k__bytes[] = "bytes";
+static char __pyx_k__dtype[] = "dtype";
+static char __pyx_k__flags[] = "flags";
+static char __pyx_k__split[] = "split";
+static char __pyx_k__track[] = "track";
+static char __pyx_k__Socket[] = "Socket";
+static char __pyx_k__buffer[] = "buffer";
+static char __pyx_k__closed[] = "closed";
+static char __pyx_k__codecs[] = "codecs";
+static char __pyx_k__decode[] = "decode";
+static char __pyx_k__encode[] = "encode";
+static char __pyx_k__format[] = "format";
+static char __pyx_k__linger[] = "linger";
+static char __pyx_k__option[] = "option";
+static char __pyx_k__optval[] = "optval";
+static char __pyx_k__pickle[] = "pickle";
+static char __pyx_k__random[] = "random";
+static char __pyx_k__struct[] = "struct";
+static char __pyx_k__ENOTSUP[] = "ENOTSUP";
+static char __pyx_k__RCVMORE[] = "RCVMORE";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k___handle[] = "_handle";
+static char __pyx_k__cPickle[] = "cPickle";
+static char __pyx_k__context[] = "context";
+static char __pyx_k__jsonapi[] = "jsonapi";
+static char __pyx_k__replace[] = "replace";
+static char __pyx_k__tracker[] = "tracker";
+static char __pyx_k__unicode[] = "unicode";
+static char __pyx_k__ENOTSOCK[] = "ENOTSOCK";
+static char __pyx_k__ZMQError[] = "ZMQError";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__copy_mod[] = "copy_mod";
+static char __pyx_k__itemsize[] = "itemsize";
+static char __pyx_k__property[] = "property";
+static char __pyx_k__typecode[] = "typecode";
+static char __pyx_k__TypeError[] = "TypeError";
+static char __pyx_k__constants[] = "constants";
+static char __pyx_k__ValueError[] = "ValueError";
+static char __pyx_k____import__[] = "__import__";
+static char __pyx_k__basestring[] = "basestring";
+static char __pyx_k__getsockopt[] = "getsockopt";
+static char __pyx_k__socket_type[] = "socket_type";
+static char __pyx_k__zmq_version[] = "zmq_version";
+static char __pyx_k__ZMQBindError[] = "ZMQBindError";
+static char __pyx_k__AttributeError[] = "AttributeError";
+static char __pyx_k__bytes_sockopts[] = "bytes_sockopts";
+static char __pyx_k__int64_sockopts[] = "int64_sockopts";
+static char __pyx_k__IPC_PATH_MAX_LEN[] = "IPC_PATH_MAX_LEN";
+static char __pyx_k__ContextTerminated[] = "ContextTerminated";
+static char __pyx_k__NotImplementedError[] = "NotImplementedError";
+static PyObject *__pyx_kp_s_10;
+static PyObject *__pyx_kp_s_12;
+static PyObject *__pyx_kp_s_14;
+static PyObject *__pyx_kp_s_16;
+static PyObject *__pyx_kp_s_2;
+static PyObject *__pyx_kp_s_20;
+static PyObject *__pyx_kp_s_22;
+static PyObject *__pyx_n_s_26;
+static PyObject *__pyx_kp_s_27;
+static PyObject *__pyx_kp_s_29;
+static PyObject *__pyx_kp_s_30;
+static PyObject *__pyx_n_s_33;
+static PyObject *__pyx_n_s_34;
+static PyObject *__pyx_n_s_35;
+static PyObject *__pyx_n_s_36;
+static PyObject *__pyx_n_s_37;
+static PyObject *__pyx_kp_s_4;
+static PyObject *__pyx_kp_s_5;
+static PyObject *__pyx_kp_s_6;
+static PyObject *__pyx_kp_s_8;
+static PyObject *__pyx_n_s__Again;
+static PyObject *__pyx_n_s__AttributeError;
+static PyObject *__pyx_n_b__B;
+static PyObject *__pyx_n_s__ContextTerminated;
+static PyObject *__pyx_n_s__ENOTSOCK;
+static PyObject *__pyx_n_s__ENOTSUP;
+static PyObject *__pyx_n_s__IPC_PATH_MAX_LEN;
+static PyObject *__pyx_n_s__NotImplementedError;
+static PyObject *__pyx_n_s__RCVMORE;
+static PyObject *__pyx_n_s__Socket;
+static PyObject *__pyx_n_s__TypeError;
+static PyObject *__pyx_n_s__ValueError;
+static PyObject *__pyx_n_s__ZMQBindError;
+static PyObject *__pyx_n_s__ZMQError;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____import__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s___handle;
+static PyObject *__pyx_n_s__ascii;
+static PyObject *__pyx_n_s__basestring;
+static PyObject *__pyx_n_s__buffer;
+static PyObject *__pyx_n_s__bytes;
+static PyObject *__pyx_n_s__bytes_sockopts;
+static PyObject *__pyx_n_s__cPickle;
+static PyObject *__pyx_n_s__char;
+static PyObject *__pyx_n_s__closed;
+static PyObject *__pyx_n_s__codecs;
+static PyObject *__pyx_n_s__constants;
+static PyObject *__pyx_n_s__context;
+static PyObject *__pyx_n_s__copy;
+static PyObject *__pyx_n_s__copy_mod;
+static PyObject *__pyx_n_s__data;
+static PyObject *__pyx_n_s__decode;
+static PyObject *__pyx_n_s__dtype;
+static PyObject *__pyx_n_s__encode;
+static PyObject *__pyx_n_s__flags;
+static PyObject *__pyx_n_s__format;
+static PyObject *__pyx_n_s__getsockopt;
+static PyObject *__pyx_n_s__int64_sockopts;
+static PyObject *__pyx_n_s__itemsize;
+static PyObject *__pyx_n_s__jsonapi;
+static PyObject *__pyx_n_s__linger;
+static PyObject *__pyx_n_s__msg;
+static PyObject *__pyx_n_s__option;
+static PyObject *__pyx_n_s__optval;
+static PyObject *__pyx_n_s__pickle;
+static PyObject *__pyx_n_s__property;
+static PyObject *__pyx_n_s__random;
+static PyObject *__pyx_n_s__recv;
+static PyObject *__pyx_n_s__replace;
+static PyObject *__pyx_n_s__send;
+static PyObject *__pyx_n_s__socket_type;
+static PyObject *__pyx_n_s__split;
+static PyObject *__pyx_n_s__struct;
+static PyObject *__pyx_n_s__sys;
+static PyObject *__pyx_n_s__time;
+static PyObject *__pyx_n_s__track;
+static PyObject *__pyx_n_s__tracker;
+static PyObject *__pyx_n_s__typecode;
+static PyObject *__pyx_n_s__unicode;
+static PyObject *__pyx_n_s__zmq;
+static PyObject *__pyx_n_s__zmq_version;
+static PyObject *__pyx_int_1;
+static PyObject *__pyx_k_1;
+static PyObject *__pyx_k_18;
+static PyObject *__pyx_k_19;
+static PyObject *__pyx_k_24;
+static PyObject *__pyx_k_25;
+static PyObject *__pyx_k_tuple_3;
+static PyObject *__pyx_k_tuple_7;
+static PyObject *__pyx_k_tuple_9;
+static PyObject *__pyx_k_tuple_11;
+static PyObject *__pyx_k_tuple_13;
+static PyObject *__pyx_k_tuple_15;
+static PyObject *__pyx_k_tuple_17;
+static PyObject *__pyx_k_tuple_21;
+static PyObject *__pyx_k_tuple_23;
+static PyObject *__pyx_k_tuple_28;
+static PyObject *__pyx_k_tuple_31;
+
+/* "zmq/core/socket.pyx":90
+ * # true methods frequently cannot be inlined, acc. Cython docs
+ * 
+ * cdef inline _check_closed(Socket s, bint raise_notsup):             # <<<<<<<<<<<<<<
+ *     cdef int rc
+ *     cdef int errno
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_6socket__check_closed(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_s, int __pyx_v_raise_notsup) {
+  int __pyx_v_rc;
+  int __pyx_v_stype;
+  size_t __pyx_v_sz;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_check_closed", 0);
+
+  /* "zmq/core/socket.pyx":94
+ *     cdef int errno
+ *     cdef int stype
+ *     cdef size_t sz=sizeof(int)             # <<<<<<<<<<<<<<
+ *     if s._closed:
+ *         if raise_notsup:
+ */
+  __pyx_v_sz = (sizeof(int));
+
+  /* "zmq/core/socket.pyx":95
+ *     cdef int stype
+ *     cdef size_t sz=sizeof(int)
+ *     if s._closed:             # <<<<<<<<<<<<<<
+ *         if raise_notsup:
+ *             raise ZMQError(ENOTSUP)
+ */
+  if (__pyx_v_s->_closed) {
+
+    /* "zmq/core/socket.pyx":96
+ *     cdef size_t sz=sizeof(int)
+ *     if s._closed:
+ *         if raise_notsup:             # <<<<<<<<<<<<<<
+ *             raise ZMQError(ENOTSUP)
+ *         else:
+ */
+    if (__pyx_v_raise_notsup) {
+
+      /* "zmq/core/socket.pyx":97
+ *     if s._closed:
+ *         if raise_notsup:
+ *             raise ZMQError(ENOTSUP)             # <<<<<<<<<<<<<<
+ *         else:
+ *             return True
+ */
+      __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__ENOTSUP); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_2);
+      __pyx_t_2 = 0;
+      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L4;
+    }
+    /*else*/ {
+
+      /* "zmq/core/socket.pyx":99
+ *             raise ZMQError(ENOTSUP)
+ *         else:
+ *             return True             # <<<<<<<<<<<<<<
+ *     else:
+ *         rc = zmq_getsockopt(s.handle, ZMQ_TYPE, <void *>&stype, &sz)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+    }
+    __pyx_L4:;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/socket.pyx":101
+ *             return True
+ *     else:
+ *         rc = zmq_getsockopt(s.handle, ZMQ_TYPE, <void *>&stype, &sz)             # <<<<<<<<<<<<<<
+ *         if rc < 0 and zmq_errno() == ENOTSOCK:
+ *             s._closed = True
+ */
+    __pyx_v_rc = zmq_getsockopt(__pyx_v_s->handle, ZMQ_TYPE, ((void *)(&__pyx_v_stype)), (&__pyx_v_sz));
+
+    /* "zmq/core/socket.pyx":102
+ *     else:
+ *         rc = zmq_getsockopt(s.handle, ZMQ_TYPE, <void *>&stype, &sz)
+ *         if rc < 0 and zmq_errno() == ENOTSOCK:             # <<<<<<<<<<<<<<
+ *             s._closed = True
+ *             if raise_notsup:
+ */
+    __pyx_t_4 = (__pyx_v_rc < 0);
+    if (__pyx_t_4) {
+      __pyx_t_2 = PyInt_FromLong(zmq_errno()); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__ENOTSOCK); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_1 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_6 = __pyx_t_5;
+    } else {
+      __pyx_t_6 = __pyx_t_4;
+    }
+    if (__pyx_t_6) {
+
+      /* "zmq/core/socket.pyx":103
+ *         rc = zmq_getsockopt(s.handle, ZMQ_TYPE, <void *>&stype, &sz)
+ *         if rc < 0 and zmq_errno() == ENOTSOCK:
+ *             s._closed = True             # <<<<<<<<<<<<<<
+ *             if raise_notsup:
+ *                 raise ZMQError(ENOTSUP)
+ */
+      __pyx_v_s->_closed = 1;
+
+      /* "zmq/core/socket.pyx":104
+ *         if rc < 0 and zmq_errno() == ENOTSOCK:
+ *             s._closed = True
+ *             if raise_notsup:             # <<<<<<<<<<<<<<
+ *                 raise ZMQError(ENOTSUP)
+ *             else:
+ */
+      if (__pyx_v_raise_notsup) {
+
+        /* "zmq/core/socket.pyx":105
+ *             s._closed = True
+ *             if raise_notsup:
+ *                 raise ZMQError(ENOTSUP)             # <<<<<<<<<<<<<<
+ *             else:
+ *                 return True
+ */
+        __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__ENOTSUP); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_2);
+        PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
+        __Pyx_GIVEREF(__pyx_t_3);
+        __pyx_t_3 = 0;
+        __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        goto __pyx_L6;
+      }
+      /*else*/ {
+
+        /* "zmq/core/socket.pyx":107
+ *                 raise ZMQError(ENOTSUP)
+ *             else:
+ *                 return True             # <<<<<<<<<<<<<<
+ *         else:
+ *             _check_rc(rc)
+ */
+        __Pyx_XDECREF(__pyx_r);
+        __pyx_t_3 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_r = __pyx_t_3;
+        __pyx_t_3 = 0;
+        goto __pyx_L0;
+      }
+      __pyx_L6:;
+      goto __pyx_L5;
+    }
+    /*else*/ {
+
+      /* "zmq/core/socket.pyx":109
+ *                 return True
+ *         else:
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ *     return False
+ * 
+ */
+      __pyx_t_7 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_7 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    __pyx_L5:;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":110
+ *         else:
+ *             _check_rc(rc)
+ *     return False             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline Frame _recv_frame(void *handle, int flags=0, track=False):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_3 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.socket._check_closed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":112
+ *     return False
+ * 
+ * cdef inline Frame _recv_frame(void *handle, int flags=0, track=False):             # <<<<<<<<<<<<<<
+ *     """Receive a message in a non-copying manner and return a Frame."""
+ *     cdef int rc
+ */
+
+static CYTHON_INLINE struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_f_3zmq_4core_6socket__recv_frame(void *__pyx_v_handle, struct __pyx_opt_args_3zmq_4core_6socket__recv_frame *__pyx_optional_args) {
+  int __pyx_v_flags = ((int)0);
+  PyObject *__pyx_v_track = __pyx_k_1;
+  int __pyx_v_rc;
+  struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_msg = 0;
+  struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_3;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_recv_frame", 0);
+  if (__pyx_optional_args) {
+    if (__pyx_optional_args->__pyx_n > 0) {
+      __pyx_v_flags = __pyx_optional_args->flags;
+      if (__pyx_optional_args->__pyx_n > 1) {
+        __pyx_v_track = __pyx_optional_args->track;
+      }
+    }
+  }
+
+  /* "zmq/core/socket.pyx":116
+ *     cdef int rc
+ *     cdef Frame msg
+ *     msg = Frame(track=track)             # <<<<<<<<<<<<<<
+ * 
+ *     with nogil:
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__track), __pyx_v_track) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3zmq_4core_7message_Frame)), ((PyObject *)__pyx_empty_tuple), ((PyObject *)__pyx_t_1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_v_msg = ((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "zmq/core/socket.pyx":118
+ *     msg = Frame(track=track)
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_msg_recv(&msg.zmq_msg, handle, flags)
+ * 
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/socket.pyx":119
+ * 
+ *     with nogil:
+ *         rc = zmq_msg_recv(&msg.zmq_msg, handle, flags)             # <<<<<<<<<<<<<<
+ * 
+ *     _check_rc(rc)
+ */
+        __pyx_v_rc = zmq_msg_recv((&__pyx_v_msg->zmq_msg), __pyx_v_handle, __pyx_v_flags);
+      }
+
+      /* "zmq/core/socket.pyx":118
+ *     msg = Frame(track=track)
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_msg_recv(&msg.zmq_msg, handle, flags)
+ * 
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/socket.pyx":121
+ *         rc = zmq_msg_recv(&msg.zmq_msg, handle, flags)
+ * 
+ *     _check_rc(rc)             # <<<<<<<<<<<<<<
+ *     return msg
+ * 
+ */
+  __pyx_t_3 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/socket.pyx":122
+ * 
+ *     _check_rc(rc)
+ *     return msg             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline object _recv_copy(void *handle, int flags=0):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_msg));
+  __pyx_r = __pyx_v_msg;
+  goto __pyx_L0;
+
+  __pyx_r = ((struct __pyx_obj_3zmq_4core_7message_Frame *)Py_None); __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.socket._recv_frame", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_msg);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":124
+ *     return msg
+ * 
+ * cdef inline object _recv_copy(void *handle, int flags=0):             # <<<<<<<<<<<<<<
+ *     """Receive a message and return a copy"""
+ *     cdef zmq_msg_t zmq_msg
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_6socket__recv_copy(void *__pyx_v_handle, struct __pyx_opt_args_3zmq_4core_6socket__recv_copy *__pyx_optional_args) {
+  int __pyx_v_flags = ((int)0);
+  zmq_msg_t __pyx_v_zmq_msg;
+  int __pyx_v_rc;
+  PyObject *__pyx_v_msg_bytes = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_recv_copy", 0);
+  if (__pyx_optional_args) {
+    if (__pyx_optional_args->__pyx_n > 0) {
+      __pyx_v_flags = __pyx_optional_args->flags;
+    }
+  }
+
+  /* "zmq/core/socket.pyx":127
+ *     """Receive a message and return a copy"""
+ *     cdef zmq_msg_t zmq_msg
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         zmq_msg_init (&zmq_msg)
+ *         rc = zmq_msg_recv(&zmq_msg, handle, flags)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/socket.pyx":128
+ *     cdef zmq_msg_t zmq_msg
+ *     with nogil:
+ *         zmq_msg_init (&zmq_msg)             # <<<<<<<<<<<<<<
+ *         rc = zmq_msg_recv(&zmq_msg, handle, flags)
+ *     _check_rc(rc)
+ */
+        zmq_msg_init((&__pyx_v_zmq_msg));
+
+        /* "zmq/core/socket.pyx":129
+ *     with nogil:
+ *         zmq_msg_init (&zmq_msg)
+ *         rc = zmq_msg_recv(&zmq_msg, handle, flags)             # <<<<<<<<<<<<<<
+ *     _check_rc(rc)
+ *     msg_bytes = copy_zmq_msg_bytes(&zmq_msg)
+ */
+        __pyx_v_rc = zmq_msg_recv((&__pyx_v_zmq_msg), __pyx_v_handle, __pyx_v_flags);
+      }
+
+      /* "zmq/core/socket.pyx":127
+ *     """Receive a message and return a copy"""
+ *     cdef zmq_msg_t zmq_msg
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         zmq_msg_init (&zmq_msg)
+ *         rc = zmq_msg_recv(&zmq_msg, handle, flags)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/socket.pyx":130
+ *         zmq_msg_init (&zmq_msg)
+ *         rc = zmq_msg_recv(&zmq_msg, handle, flags)
+ *     _check_rc(rc)             # <<<<<<<<<<<<<<
+ *     msg_bytes = copy_zmq_msg_bytes(&zmq_msg)
+ *     with nogil:
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/socket.pyx":131
+ *         rc = zmq_msg_recv(&zmq_msg, handle, flags)
+ *     _check_rc(rc)
+ *     msg_bytes = copy_zmq_msg_bytes(&zmq_msg)             # <<<<<<<<<<<<<<
+ *     with nogil:
+ *         zmq_msg_close(&zmq_msg)
+ */
+  __pyx_t_2 = __pyx_f_3zmq_4core_7message_copy_zmq_msg_bytes((&__pyx_v_zmq_msg)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_v_msg_bytes = __pyx_t_2;
+  __pyx_t_2 = 0;
+
+  /* "zmq/core/socket.pyx":132
+ *     _check_rc(rc)
+ *     msg_bytes = copy_zmq_msg_bytes(&zmq_msg)
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         zmq_msg_close(&zmq_msg)
+ *     return msg_bytes
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/socket.pyx":133
+ *     msg_bytes = copy_zmq_msg_bytes(&zmq_msg)
+ *     with nogil:
+ *         zmq_msg_close(&zmq_msg)             # <<<<<<<<<<<<<<
+ *     return msg_bytes
+ * 
+ */
+        zmq_msg_close((&__pyx_v_zmq_msg));
+      }
+
+      /* "zmq/core/socket.pyx":132
+ *     _check_rc(rc)
+ *     msg_bytes = copy_zmq_msg_bytes(&zmq_msg)
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         zmq_msg_close(&zmq_msg)
+ *     return msg_bytes
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/socket.pyx":134
+ *     with nogil:
+ *         zmq_msg_close(&zmq_msg)
+ *     return msg_bytes             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline object _send_frame(void *handle, Frame msg, int flags=0):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_msg_bytes);
+  __pyx_r = __pyx_v_msg_bytes;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.socket._recv_copy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_msg_bytes);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":136
+ *     return msg_bytes
+ * 
+ * cdef inline object _send_frame(void *handle, Frame msg, int flags=0):             # <<<<<<<<<<<<<<
+ *     """Send a Frame on this socket in a non-copy manner."""
+ *     cdef int rc
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_6socket__send_frame(void *__pyx_v_handle, struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_msg, struct __pyx_opt_args_3zmq_4core_6socket__send_frame *__pyx_optional_args) {
+  int __pyx_v_flags = ((int)0);
+  int __pyx_v_rc;
+  struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_msg_copy = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_send_frame", 0);
+  if (__pyx_optional_args) {
+    if (__pyx_optional_args->__pyx_n > 0) {
+      __pyx_v_flags = __pyx_optional_args->flags;
+    }
+  }
+
+  /* "zmq/core/socket.pyx":143
+ *     # Always copy so the original message isn't garbage collected.
+ *     # This doesn't do a real copy, just a reference.
+ *     msg_copy = msg.fast_copy()             # <<<<<<<<<<<<<<
+ * 
+ *     with nogil:
+ */
+  __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_3zmq_4core_7message_Frame *)__pyx_v_msg->__pyx_vtab)->fast_copy(__pyx_v_msg)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_msg_copy = ((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":145
+ *     msg_copy = msg.fast_copy()
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_msg_send(&msg_copy.zmq_msg, handle, flags)
+ * 
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/socket.pyx":146
+ * 
+ *     with nogil:
+ *         rc = zmq_msg_send(&msg_copy.zmq_msg, handle, flags)             # <<<<<<<<<<<<<<
+ * 
+ *     _check_rc(rc)
+ */
+        __pyx_v_rc = zmq_msg_send((&__pyx_v_msg_copy->zmq_msg), __pyx_v_handle, __pyx_v_flags);
+      }
+
+      /* "zmq/core/socket.pyx":145
+ *     msg_copy = msg.fast_copy()
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_msg_send(&msg_copy.zmq_msg, handle, flags)
+ * 
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/socket.pyx":148
+ *         rc = zmq_msg_send(&msg_copy.zmq_msg, handle, flags)
+ * 
+ *     _check_rc(rc)             # <<<<<<<<<<<<<<
+ *     return msg.tracker
+ * 
+ */
+  __pyx_t_2 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/socket.pyx":149
+ * 
+ *     _check_rc(rc)
+ *     return msg.tracker             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_msg->tracker);
+  __pyx_r = __pyx_v_msg->tracker;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.socket._send_frame", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_msg_copy);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":152
+ * 
+ * 
+ * cdef inline object _send_copy(void *handle, object msg, int flags=0):             # <<<<<<<<<<<<<<
+ *     """Send a message on this socket by copying its content."""
+ *     cdef int rc, rc2
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_6socket__send_copy(void *__pyx_v_handle, PyObject *__pyx_v_msg, struct __pyx_opt_args_3zmq_4core_6socket__send_copy *__pyx_optional_args) {
+  int __pyx_v_flags = ((int)0);
+  int __pyx_v_rc;
+  int __pyx_v_rc2;
+  zmq_msg_t __pyx_v_data;
+  char *__pyx_v_msg_c;
+  Py_ssize_t __pyx_v_msg_c_len;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_send_copy", 0);
+  if (__pyx_optional_args) {
+    if (__pyx_optional_args->__pyx_n > 0) {
+      __pyx_v_flags = __pyx_optional_args->flags;
+    }
+  }
+
+  /* "zmq/core/socket.pyx":157
+ *     cdef zmq_msg_t data
+ *     cdef char *msg_c
+ *     cdef Py_ssize_t msg_c_len=0             # <<<<<<<<<<<<<<
+ * 
+ *     # copy to c array:
+ */
+  __pyx_v_msg_c_len = 0;
+
+  /* "zmq/core/socket.pyx":160
+ * 
+ *     # copy to c array:
+ *     asbuffer_r(msg, <void **>&msg_c, &msg_c_len)             # <<<<<<<<<<<<<<
+ * 
+ *     # Copy the msg before sending. This avoids any complications with
+ */
+  __pyx_t_1 = __pyx_f_7buffers_asbuffer_r(__pyx_v_msg, ((void **)(&__pyx_v_msg_c)), (&__pyx_v_msg_c_len)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":165
+ *     # the GIL, etc.
+ *     # If zmq_msg_init_* fails we must not call zmq_msg_close (Bus Error)
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_msg_init_size(&data, msg_c_len)
+ * 
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/socket.pyx":166
+ *     # If zmq_msg_init_* fails we must not call zmq_msg_close (Bus Error)
+ *     with nogil:
+ *         rc = zmq_msg_init_size(&data, msg_c_len)             # <<<<<<<<<<<<<<
+ * 
+ *     _check_rc(rc)
+ */
+        __pyx_v_rc = zmq_msg_init_size((&__pyx_v_data), __pyx_v_msg_c_len);
+      }
+
+      /* "zmq/core/socket.pyx":165
+ *     # the GIL, etc.
+ *     # If zmq_msg_init_* fails we must not call zmq_msg_close (Bus Error)
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_msg_init_size(&data, msg_c_len)
+ * 
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/socket.pyx":168
+ *         rc = zmq_msg_init_size(&data, msg_c_len)
+ * 
+ *     _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *     with nogil:
+ */
+  __pyx_t_2 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/socket.pyx":170
+ *     _check_rc(rc)
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         memcpy(zmq_msg_data(&data), msg_c, zmq_msg_size(&data))
+ *         rc = zmq_msg_send(&data, handle, flags)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/socket.pyx":171
+ * 
+ *     with nogil:
+ *         memcpy(zmq_msg_data(&data), msg_c, zmq_msg_size(&data))             # <<<<<<<<<<<<<<
+ *         rc = zmq_msg_send(&data, handle, flags)
+ *         rc2 = zmq_msg_close(&data)
+ */
+        memcpy(zmq_msg_data((&__pyx_v_data)), __pyx_v_msg_c, zmq_msg_size((&__pyx_v_data)));
+
+        /* "zmq/core/socket.pyx":172
+ *     with nogil:
+ *         memcpy(zmq_msg_data(&data), msg_c, zmq_msg_size(&data))
+ *         rc = zmq_msg_send(&data, handle, flags)             # <<<<<<<<<<<<<<
+ *         rc2 = zmq_msg_close(&data)
+ *     _check_rc(rc)
+ */
+        __pyx_v_rc = zmq_msg_send((&__pyx_v_data), __pyx_v_handle, __pyx_v_flags);
+
+        /* "zmq/core/socket.pyx":173
+ *         memcpy(zmq_msg_data(&data), msg_c, zmq_msg_size(&data))
+ *         rc = zmq_msg_send(&data, handle, flags)
+ *         rc2 = zmq_msg_close(&data)             # <<<<<<<<<<<<<<
+ *     _check_rc(rc)
+ *     _check_rc(rc2)
+ */
+        __pyx_v_rc2 = zmq_msg_close((&__pyx_v_data));
+      }
+
+      /* "zmq/core/socket.pyx":170
+ *     _check_rc(rc)
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         memcpy(zmq_msg_data(&data), msg_c, zmq_msg_size(&data))
+ *         rc = zmq_msg_send(&data, handle, flags)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/socket.pyx":174
+ *         rc = zmq_msg_send(&data, handle, flags)
+ *         rc2 = zmq_msg_close(&data)
+ *     _check_rc(rc)             # <<<<<<<<<<<<<<
+ *     _check_rc(rc2)
+ * 
+ */
+  __pyx_t_2 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/socket.pyx":175
+ *         rc2 = zmq_msg_close(&data)
+ *     _check_rc(rc)
+ *     _check_rc(rc2)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_t_2 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc2); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.socket._send_copy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_6socket_6Socket_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3zmq_4core_6socket_6Socket_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_context = 0;
+  int __pyx_v_socket_type;
+  CYTHON_UNUSED PyObject *__pyx_v_args = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwrags = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
+  __pyx_v_kwrags = PyDict_New(); if (unlikely(!__pyx_v_kwrags)) return -1;
+  __Pyx_GOTREF(__pyx_v_kwrags);
+  if (PyTuple_GET_SIZE(__pyx_args) > 2) {
+    __pyx_v_args = PyTuple_GetSlice(__pyx_args, 2, PyTuple_GET_SIZE(__pyx_args));
+    if (unlikely(!__pyx_v_args)) {
+      __Pyx_DECREF(__pyx_v_kwrags); __pyx_v_kwrags = 0;
+      __Pyx_RefNannyFinishContext();
+      return -1;
+    }
+    __Pyx_GOTREF(__pyx_v_args);
+  } else {
+    __pyx_v_args = __pyx_empty_tuple; __Pyx_INCREF(__pyx_empty_tuple);
+  }
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__context,&__pyx_n_s__socket_type,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        default:
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__context)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__socket_type)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t used_pos_args = (pos_args < 2) ? pos_args : 2;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwrags, values, used_pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) < 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_context = ((struct __pyx_obj_3zmq_4core_7context_Context *)values[0]);
+    __pyx_v_socket_type = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_socket_type == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_DECREF(__pyx_v_args); __pyx_v_args = 0;
+  __Pyx_DECREF(__pyx_v_kwrags); __pyx_v_kwrags = 0;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_context), __pyx_ptype_3zmq_4core_7context_Context, 1, "context", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket___cinit__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), __pyx_v_context, __pyx_v_socket_type, __pyx_v_args, __pyx_v_kwrags);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_args);
+  __Pyx_XDECREF(__pyx_v_kwrags);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":200
+ *     """
+ * 
+ *     def __cinit__(self, Context context, int socket_type, *args, **kwrags):             # <<<<<<<<<<<<<<
+ *         cdef Py_ssize_t c_handle
+ *         c_handle = context._handle
+ */
+
+static int __pyx_pf_3zmq_4core_6socket_6Socket___cinit__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_context, int __pyx_v_socket_type, CYTHON_UNUSED PyObject *__pyx_v_args, CYTHON_UNUSED PyObject *__pyx_v_kwrags) {
+  Py_ssize_t __pyx_v_c_handle;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__cinit__", 0);
+
+  /* "zmq/core/socket.pyx":202
+ *     def __cinit__(self, Context context, int socket_type, *args, **kwrags):
+ *         cdef Py_ssize_t c_handle
+ *         c_handle = context._handle             # <<<<<<<<<<<<<<
+ * 
+ *         self.handle = NULL
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_context), __pyx_n_s___handle); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_c_handle = __pyx_t_2;
+
+  /* "zmq/core/socket.pyx":204
+ *         c_handle = context._handle
+ * 
+ *         self.handle = NULL             # <<<<<<<<<<<<<<
+ *         self.context = context
+ *         self.socket_type = socket_type
+ */
+  __pyx_v_self->handle = NULL;
+
+  /* "zmq/core/socket.pyx":205
+ * 
+ *         self.handle = NULL
+ *         self.context = context             # <<<<<<<<<<<<<<
+ *         self.socket_type = socket_type
+ *         with nogil:
+ */
+  __Pyx_INCREF(((PyObject *)__pyx_v_context));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_context));
+  __Pyx_GOTREF(__pyx_v_self->context);
+  __Pyx_DECREF(((PyObject *)__pyx_v_self->context));
+  __pyx_v_self->context = __pyx_v_context;
+
+  /* "zmq/core/socket.pyx":206
+ *         self.handle = NULL
+ *         self.context = context
+ *         self.socket_type = socket_type             # <<<<<<<<<<<<<<
+ *         with nogil:
+ *             self.handle = zmq_socket(<void *>c_handle, socket_type)
+ */
+  __pyx_v_self->socket_type = __pyx_v_socket_type;
+
+  /* "zmq/core/socket.pyx":207
+ *         self.context = context
+ *         self.socket_type = socket_type
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             self.handle = zmq_socket(<void *>c_handle, socket_type)
+ *         if self.handle == NULL:
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/socket.pyx":208
+ *         self.socket_type = socket_type
+ *         with nogil:
+ *             self.handle = zmq_socket(<void *>c_handle, socket_type)             # <<<<<<<<<<<<<<
+ *         if self.handle == NULL:
+ *             raise ZMQError()
+ */
+        __pyx_v_self->handle = zmq_socket(((void *)__pyx_v_c_handle), __pyx_v_socket_type);
+      }
+
+      /* "zmq/core/socket.pyx":207
+ *         self.context = context
+ *         self.socket_type = socket_type
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             self.handle = zmq_socket(<void *>c_handle, socket_type)
+ *         if self.handle == NULL:
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/socket.pyx":209
+ *         with nogil:
+ *             self.handle = zmq_socket(<void *>c_handle, socket_type)
+ *         if self.handle == NULL:             # <<<<<<<<<<<<<<
+ *             raise ZMQError()
+ *         self._closed = False
+ */
+  __pyx_t_3 = (__pyx_v_self->handle == NULL);
+  if (__pyx_t_3) {
+
+    /* "zmq/core/socket.pyx":210
+ *             self.handle = zmq_socket(<void *>c_handle, socket_type)
+ *         if self.handle == NULL:
+ *             raise ZMQError()             # <<<<<<<<<<<<<<
+ *         self._closed = False
+ *         self._pid = getpid()
+ */
+    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_4 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "zmq/core/socket.pyx":211
+ *         if self.handle == NULL:
+ *             raise ZMQError()
+ *         self._closed = False             # <<<<<<<<<<<<<<
+ *         self._pid = getpid()
+ *         context._add_socket(self.handle)
+ */
+  __pyx_v_self->_closed = 0;
+
+  /* "zmq/core/socket.pyx":212
+ *             raise ZMQError()
+ *         self._closed = False
+ *         self._pid = getpid()             # <<<<<<<<<<<<<<
+ *         context._add_socket(self.handle)
+ * 
+ */
+  __pyx_v_self->_pid = getpid();
+
+  /* "zmq/core/socket.pyx":213
+ *         self._closed = False
+ *         self._pid = getpid()
+ *         context._add_socket(self.handle)             # <<<<<<<<<<<<<<
+ * 
+ *     def __dealloc__(self):
+ */
+  ((struct __pyx_vtabstruct_3zmq_4core_7context_Context *)__pyx_v_context->__pyx_vtab)->_add_socket(__pyx_v_context, __pyx_v_self->handle);
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static void __pyx_pw_3zmq_4core_6socket_6Socket_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
+static void __pyx_pw_3zmq_4core_6socket_6Socket_3__dealloc__(PyObject *__pyx_v_self) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
+  __pyx_pf_3zmq_4core_6socket_6Socket_2__dealloc__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "zmq/core/socket.pyx":215
+ *         context._add_socket(self.handle)
+ * 
+ *     def __dealloc__(self):             # <<<<<<<<<<<<<<
+ *         """close *and* remove from context's list
+ * 
+ */
+
+static void __pyx_pf_3zmq_4core_6socket_6Socket_2__dealloc__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self) {
+  int __pyx_v_rc;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__dealloc__", 0);
+
+  /* "zmq/core/socket.pyx":220
+ *         But be careful that context might not exist if called during gc
+ *         """
+ *         if self.handle != NULL and getpid() == self._pid:             # <<<<<<<<<<<<<<
+ *             rc = zmq_close(self.handle)
+ *             if rc != 0 and zmq_errno() != ENOTSOCK:
+ */
+  __pyx_t_1 = (__pyx_v_self->handle != NULL);
+  if (__pyx_t_1) {
+    __pyx_t_2 = (getpid() == __pyx_v_self->_pid);
+    __pyx_t_3 = __pyx_t_2;
+  } else {
+    __pyx_t_3 = __pyx_t_1;
+  }
+  if (__pyx_t_3) {
+
+    /* "zmq/core/socket.pyx":221
+ *         """
+ *         if self.handle != NULL and getpid() == self._pid:
+ *             rc = zmq_close(self.handle)             # <<<<<<<<<<<<<<
+ *             if rc != 0 and zmq_errno() != ENOTSOCK:
+ *                 # ignore ENOTSOCK (closed by Context)
+ */
+    __pyx_v_rc = zmq_close(__pyx_v_self->handle);
+
+    /* "zmq/core/socket.pyx":222
+ *         if self.handle != NULL and getpid() == self._pid:
+ *             rc = zmq_close(self.handle)
+ *             if rc != 0 and zmq_errno() != ENOTSOCK:             # <<<<<<<<<<<<<<
+ *                 # ignore ENOTSOCK (closed by Context)
+ *                 _check_rc(rc)
+ */
+    __pyx_t_3 = (__pyx_v_rc != 0);
+    if (__pyx_t_3) {
+      __pyx_t_4 = PyInt_FromLong(zmq_errno()); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s__ENOTSOCK); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = PyObject_RichCompare(__pyx_t_4, __pyx_t_5, Py_NE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __pyx_t_2 = __pyx_t_1;
+    } else {
+      __pyx_t_2 = __pyx_t_3;
+    }
+    if (__pyx_t_2) {
+
+      /* "zmq/core/socket.pyx":224
+ *             if rc != 0 and zmq_errno() != ENOTSOCK:
+ *                 # ignore ENOTSOCK (closed by Context)
+ *                 _check_rc(rc)             # <<<<<<<<<<<<<<
+ *             # during gc, self.context might be NULL
+ *             if self.context:
+ */
+      __pyx_t_7 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_7 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L4;
+    }
+    __pyx_L4:;
+
+    /* "zmq/core/socket.pyx":226
+ *                 _check_rc(rc)
+ *             # during gc, self.context might be NULL
+ *             if self.context:             # <<<<<<<<<<<<<<
+ *                 self.context._remove_socket(self.handle)
+ * 
+ */
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(((PyObject *)__pyx_v_self->context)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_2) {
+
+      /* "zmq/core/socket.pyx":227
+ *             # during gc, self.context might be NULL
+ *             if self.context:
+ *                 self.context._remove_socket(self.handle)             # <<<<<<<<<<<<<<
+ * 
+ *     def __init__(self, context, socket_type):
+ */
+      ((struct __pyx_vtabstruct_3zmq_4core_7context_Context *)__pyx_v_self->context->__pyx_vtab)->_remove_socket(__pyx_v_self->context, __pyx_v_self->handle);
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_6socket_6Socket_5__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3zmq_4core_6socket_6Socket_5__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  CYTHON_UNUSED PyObject *__pyx_v_context = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_socket_type = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__context,&__pyx_n_s__socket_type,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__context)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__socket_type)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_context = values[0];
+    __pyx_v_socket_type = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 229; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_4__init__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), __pyx_v_context, __pyx_v_socket_type);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":229
+ *                 self.context._remove_socket(self.handle)
+ * 
+ *     def __init__(self, context, socket_type):             # <<<<<<<<<<<<<<
+ *         pass
+ * 
+ */
+
+static int __pyx_pf_3zmq_4core_6socket_6Socket_4__init__(CYTHON_UNUSED struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_context, CYTHON_UNUSED PyObject *__pyx_v_socket_type) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__", 0);
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_7closed(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_7closed(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("closed (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_6closed(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":233
+ * 
+ *     @property
+ *     def closed(self):             # <<<<<<<<<<<<<<
+ *         return _check_closed(self, False)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_6closed(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("closed", 0);
+
+  /* "zmq/core/socket.pyx":234
+ *     @property
+ *     def closed(self):
+ *         return _check_closed(self, False)             # <<<<<<<<<<<<<<
+ * 
+ *     def close(self, linger=None):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.closed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_9close(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_8close[] = "s.close(linger=None)\n\n        Close the socket.\n        \n        If linger is specified, LINGER sockopt will be set prior to closing.\n\n        This can be called to close the socket by hand. If this is not\n        called, the socket will automatically be closed when it is\n        garbage collected.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_9close(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_linger = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("close (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__linger,0};
+    PyObject* values[1] = {0};
+
+    /* "zmq/core/socket.pyx":236
+ *         return _check_closed(self, False)
+ * 
+ *     def close(self, linger=None):             # <<<<<<<<<<<<<<
+ *         """s.close(linger=None)
+ * 
+ */
+    values[0] = ((PyObject *)Py_None);
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__linger);
+          if (value) { values[0] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "close") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_linger = values[0];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("close", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.close", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_8close(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), __pyx_v_linger);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_8close(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_linger) {
+  int __pyx_v_rc;
+  int __pyx_v_linger_c;
+  int __pyx_v_setlinger;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("close", 0);
+
+  /* "zmq/core/socket.pyx":247
+ *         garbage collected.
+ *         """
+ *         cdef int rc=0             # <<<<<<<<<<<<<<
+ *         cdef int linger_c
+ *         cdef bint setlinger=False
+ */
+  __pyx_v_rc = 0;
+
+  /* "zmq/core/socket.pyx":249
+ *         cdef int rc=0
+ *         cdef int linger_c
+ *         cdef bint setlinger=False             # <<<<<<<<<<<<<<
+ * 
+ *         if linger is not None:
+ */
+  __pyx_v_setlinger = 0;
+
+  /* "zmq/core/socket.pyx":251
+ *         cdef bint setlinger=False
+ * 
+ *         if linger is not None:             # <<<<<<<<<<<<<<
+ *             linger_c = linger
+ *             setlinger=True
+ */
+  __pyx_t_1 = (__pyx_v_linger != Py_None);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/socket.pyx":252
+ * 
+ *         if linger is not None:
+ *             linger_c = linger             # <<<<<<<<<<<<<<
+ *             setlinger=True
+ * 
+ */
+    __pyx_t_2 = __Pyx_PyInt_AsInt(__pyx_v_linger); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_linger_c = __pyx_t_2;
+
+    /* "zmq/core/socket.pyx":253
+ *         if linger is not None:
+ *             linger_c = linger
+ *             setlinger=True             # <<<<<<<<<<<<<<
+ * 
+ *         if self.handle != NULL and not self._closed and getpid() == self._pid:
+ */
+    __pyx_v_setlinger = 1;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":255
+ *             setlinger=True
+ * 
+ *         if self.handle != NULL and not self._closed and getpid() == self._pid:             # <<<<<<<<<<<<<<
+ *             if setlinger:
+ *                 zmq_setsockopt(self.handle, ZMQ_LINGER, &linger_c, sizeof(int))
+ */
+  __pyx_t_1 = (__pyx_v_self->handle != NULL);
+  if (__pyx_t_1) {
+    __pyx_t_3 = (!__pyx_v_self->_closed);
+    if (__pyx_t_3) {
+      __pyx_t_4 = (getpid() == __pyx_v_self->_pid);
+      __pyx_t_5 = __pyx_t_4;
+    } else {
+      __pyx_t_5 = __pyx_t_3;
+    }
+    __pyx_t_3 = __pyx_t_5;
+  } else {
+    __pyx_t_3 = __pyx_t_1;
+  }
+  if (__pyx_t_3) {
+
+    /* "zmq/core/socket.pyx":256
+ * 
+ *         if self.handle != NULL and not self._closed and getpid() == self._pid:
+ *             if setlinger:             # <<<<<<<<<<<<<<
+ *                 zmq_setsockopt(self.handle, ZMQ_LINGER, &linger_c, sizeof(int))
+ *             rc = zmq_close(self.handle)
+ */
+    if (__pyx_v_setlinger) {
+
+      /* "zmq/core/socket.pyx":257
+ *         if self.handle != NULL and not self._closed and getpid() == self._pid:
+ *             if setlinger:
+ *                 zmq_setsockopt(self.handle, ZMQ_LINGER, &linger_c, sizeof(int))             # <<<<<<<<<<<<<<
+ *             rc = zmq_close(self.handle)
+ *             if rc != 0 and zmq_errno() != ENOTSOCK:
+ */
+      zmq_setsockopt(__pyx_v_self->handle, ZMQ_LINGER, (&__pyx_v_linger_c), (sizeof(int)));
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "zmq/core/socket.pyx":258
+ *             if setlinger:
+ *                 zmq_setsockopt(self.handle, ZMQ_LINGER, &linger_c, sizeof(int))
+ *             rc = zmq_close(self.handle)             # <<<<<<<<<<<<<<
+ *             if rc != 0 and zmq_errno() != ENOTSOCK:
+ *                 # ignore ENOTSOCK (closed by Context)
+ */
+    __pyx_v_rc = zmq_close(__pyx_v_self->handle);
+
+    /* "zmq/core/socket.pyx":259
+ *                 zmq_setsockopt(self.handle, ZMQ_LINGER, &linger_c, sizeof(int))
+ *             rc = zmq_close(self.handle)
+ *             if rc != 0 and zmq_errno() != ENOTSOCK:             # <<<<<<<<<<<<<<
+ *                 # ignore ENOTSOCK (closed by Context)
+ *                 _check_rc(rc)
+ */
+    __pyx_t_3 = (__pyx_v_rc != 0);
+    if (__pyx_t_3) {
+      __pyx_t_6 = PyInt_FromLong(zmq_errno()); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_6);
+      __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s__ENOTSOCK); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_t_8 = PyObject_RichCompare(__pyx_t_6, __pyx_t_7, Py_NE); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_t_5 = __pyx_t_1;
+    } else {
+      __pyx_t_5 = __pyx_t_3;
+    }
+    if (__pyx_t_5) {
+
+      /* "zmq/core/socket.pyx":261
+ *             if rc != 0 and zmq_errno() != ENOTSOCK:
+ *                 # ignore ENOTSOCK (closed by Context)
+ *                 _check_rc(rc)             # <<<<<<<<<<<<<<
+ *             self._closed = True
+ *             # during gc, self.context might be NULL
+ */
+      __pyx_t_2 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L6;
+    }
+    __pyx_L6:;
+
+    /* "zmq/core/socket.pyx":262
+ *                 # ignore ENOTSOCK (closed by Context)
+ *                 _check_rc(rc)
+ *             self._closed = True             # <<<<<<<<<<<<<<
+ *             # during gc, self.context might be NULL
+ *             if self.context:
+ */
+    __pyx_v_self->_closed = 1;
+
+    /* "zmq/core/socket.pyx":264
+ *             self._closed = True
+ *             # during gc, self.context might be NULL
+ *             if self.context:             # <<<<<<<<<<<<<<
+ *                 self.context._remove_socket(self.handle)
+ *             self.handle = NULL
+ */
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(((PyObject *)__pyx_v_self->context)); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_5) {
+
+      /* "zmq/core/socket.pyx":265
+ *             # during gc, self.context might be NULL
+ *             if self.context:
+ *                 self.context._remove_socket(self.handle)             # <<<<<<<<<<<<<<
+ *             self.handle = NULL
+ * 
+ */
+      ((struct __pyx_vtabstruct_3zmq_4core_7context_Context *)__pyx_v_self->context->__pyx_vtab)->_remove_socket(__pyx_v_self->context, __pyx_v_self->handle);
+      goto __pyx_L7;
+    }
+    __pyx_L7:;
+
+    /* "zmq/core/socket.pyx":266
+ *             if self.context:
+ *                 self.context._remove_socket(self.handle)
+ *             self.handle = NULL             # <<<<<<<<<<<<<<
+ * 
+ *     def set(self, int option, optval):
+ */
+    __pyx_v_self->handle = NULL;
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.close", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_11set(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_10set[] = "s.set(option, optval)\n\n        Set socket options.\n\n        See the 0MQ API documentation for details on specific options.\n\n        Parameters\n        ----------\n        option : int\n            The option to set.  Available values will depend on your\n            version of libzmq.  Examples include::\n            \n                zmq.SUBSCRIBE, UNSUBSCRIBE, IDENTITY, HWM, LINGER, FD\n        \n        optval : int or bytes\n            The value of the option to set.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_11set(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_v_option;
+  PyObject *__pyx_v_optval = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("set (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__option,&__pyx_n_s__optval,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__option)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__optval)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("set", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_option = __Pyx_PyInt_AsInt(values[0]); if (unlikely((__pyx_v_option == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    __pyx_v_optval = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("set", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.set", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_10set(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), __pyx_v_option, __pyx_v_optval);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":268
+ *             self.handle = NULL
+ * 
+ *     def set(self, int option, optval):             # <<<<<<<<<<<<<<
+ *         """s.set(option, optval)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_10set(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, int __pyx_v_option, PyObject *__pyx_v_optval) {
+  pyzmq_int64_t __pyx_v_optval_int64_c;
+  int __pyx_v_optval_int_c;
+  int __pyx_v_rc;
+  char *__pyx_v_optval_c;
+  Py_ssize_t __pyx_v_sz;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  char *__pyx_t_6;
+  Py_ssize_t __pyx_t_7;
+  pyzmq_int64_t __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("set", 0);
+
+  /* "zmq/core/socket.pyx":292
+ *         cdef Py_ssize_t sz
+ * 
+ *         _check_closed(self, True)             # <<<<<<<<<<<<<<
+ *         if isinstance(optval, unicode):
+ *             raise TypeError("unicode not allowed, use setsockopt_string")
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":293
+ * 
+ *         _check_closed(self, True)
+ *         if isinstance(optval, unicode):             # <<<<<<<<<<<<<<
+ *             raise TypeError("unicode not allowed, use setsockopt_string")
+ * 
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_optval, __pyx_t_1); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "zmq/core/socket.pyx":294
+ *         _check_closed(self, True)
+ *         if isinstance(optval, unicode):
+ *             raise TypeError("unicode not allowed, use setsockopt_string")             # <<<<<<<<<<<<<<
+ * 
+ *         if option in zmq.constants.bytes_sockopts:
+ */
+    __pyx_t_1 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_k_tuple_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":296
+ *             raise TypeError("unicode not allowed, use setsockopt_string")
+ * 
+ *         if option in zmq.constants.bytes_sockopts:             # <<<<<<<<<<<<<<
+ *             if not isinstance(optval, bytes):
+ *                 raise TypeError('expected bytes, got: %r' % optval)
+ */
+  __pyx_t_1 = PyInt_FromLong(__pyx_v_option); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__zmq); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s__constants); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s__bytes_sockopts); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_2 = (__Pyx_PySequence_Contains(__pyx_t_1, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (__pyx_t_2) {
+
+    /* "zmq/core/socket.pyx":297
+ * 
+ *         if option in zmq.constants.bytes_sockopts:
+ *             if not isinstance(optval, bytes):             # <<<<<<<<<<<<<<
+ *                 raise TypeError('expected bytes, got: %r' % optval)
+ *             optval_c = PyBytes_AsString(optval)
+ */
+    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__bytes); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = PyObject_IsInstance(__pyx_v_optval, __pyx_t_3); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_5 = (!__pyx_t_2);
+    if (__pyx_t_5) {
+
+      /* "zmq/core/socket.pyx":298
+ *         if option in zmq.constants.bytes_sockopts:
+ *             if not isinstance(optval, bytes):
+ *                 raise TypeError('expected bytes, got: %r' % optval)             # <<<<<<<<<<<<<<
+ *             optval_c = PyBytes_AsString(optval)
+ *             sz = PyBytes_Size(optval)
+ */
+      __pyx_t_3 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_4), __pyx_v_optval); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+      __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_t_3));
+      __Pyx_GIVEREF(((PyObject *)__pyx_t_3));
+      __pyx_t_3 = 0;
+      __pyx_t_3 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "zmq/core/socket.pyx":299
+ *             if not isinstance(optval, bytes):
+ *                 raise TypeError('expected bytes, got: %r' % optval)
+ *             optval_c = PyBytes_AsString(optval)             # <<<<<<<<<<<<<<
+ *             sz = PyBytes_Size(optval)
+ *             with nogil:
+ */
+    __pyx_t_6 = PyBytes_AsString(__pyx_v_optval); if (unlikely(__pyx_t_6 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_optval_c = __pyx_t_6;
+
+    /* "zmq/core/socket.pyx":300
+ *                 raise TypeError('expected bytes, got: %r' % optval)
+ *             optval_c = PyBytes_AsString(optval)
+ *             sz = PyBytes_Size(optval)             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_setsockopt(
+ */
+    __pyx_t_7 = PyBytes_Size(__pyx_v_optval); if (unlikely(__pyx_t_7 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_sz = __pyx_t_7;
+
+    /* "zmq/core/socket.pyx":301
+ *             optval_c = PyBytes_AsString(optval)
+ *             sz = PyBytes_Size(optval)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_setsockopt(
+ *                     self.handle, option,
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/socket.pyx":305
+ *                     self.handle, option,
+ *                     optval_c, sz
+ *                 )             # <<<<<<<<<<<<<<
+ *         elif option in zmq.constants.int64_sockopts:
+ *             if not isinstance(optval, int):
+ */
+          __pyx_v_rc = zmq_setsockopt(__pyx_v_self->handle, __pyx_v_option, __pyx_v_optval_c, __pyx_v_sz);
+        }
+
+        /* "zmq/core/socket.pyx":301
+ *             optval_c = PyBytes_AsString(optval)
+ *             sz = PyBytes_Size(optval)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_setsockopt(
+ *                     self.handle, option,
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+    goto __pyx_L4;
+  }
+
+  /* "zmq/core/socket.pyx":306
+ *                     optval_c, sz
+ *                 )
+ *         elif option in zmq.constants.int64_sockopts:             # <<<<<<<<<<<<<<
+ *             if not isinstance(optval, int):
+ *                 raise TypeError('expected int, got: %r' % optval)
+ */
+  __pyx_t_3 = PyInt_FromLong(__pyx_v_option); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__zmq); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s__constants); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s__int64_sockopts); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_5 = (__Pyx_PySequence_Contains(__pyx_t_3, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_5) {
+
+    /* "zmq/core/socket.pyx":307
+ *                 )
+ *         elif option in zmq.constants.int64_sockopts:
+ *             if not isinstance(optval, int):             # <<<<<<<<<<<<<<
+ *                 raise TypeError('expected int, got: %r' % optval)
+ *             optval_int64_c = optval
+ */
+    __pyx_t_5 = PyInt_Check(__pyx_v_optval); 
+    __pyx_t_2 = (!__pyx_t_5);
+    if (__pyx_t_2) {
+
+      /* "zmq/core/socket.pyx":308
+ *         elif option in zmq.constants.int64_sockopts:
+ *             if not isinstance(optval, int):
+ *                 raise TypeError('expected int, got: %r' % optval)             # <<<<<<<<<<<<<<
+ *             optval_int64_c = optval
+ *             with nogil:
+ */
+      __pyx_t_1 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_5), __pyx_v_optval); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_1));
+      __Pyx_GIVEREF(((PyObject *)__pyx_t_1));
+      __pyx_t_1 = 0;
+      __pyx_t_1 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L9;
+    }
+    __pyx_L9:;
+
+    /* "zmq/core/socket.pyx":309
+ *             if not isinstance(optval, int):
+ *                 raise TypeError('expected int, got: %r' % optval)
+ *             optval_int64_c = optval             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_setsockopt(
+ */
+    __pyx_t_8 = __Pyx_PyInt_from_py_pyzmq_int64_t(__pyx_v_optval); if (unlikely((__pyx_t_8 == (pyzmq_int64_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 309; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_optval_int64_c = __pyx_t_8;
+
+    /* "zmq/core/socket.pyx":310
+ *                 raise TypeError('expected int, got: %r' % optval)
+ *             optval_int64_c = optval
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_setsockopt(
+ *                     self.handle, option,
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/socket.pyx":313
+ *                 rc = zmq_setsockopt(
+ *                     self.handle, option,
+ *                     &optval_int64_c, sizeof(int64_t)             # <<<<<<<<<<<<<<
+ *                 )
+ *         else:
+ */
+          __pyx_v_rc = zmq_setsockopt(__pyx_v_self->handle, __pyx_v_option, (&__pyx_v_optval_int64_c), (sizeof(pyzmq_int64_t)));
+        }
+
+        /* "zmq/core/socket.pyx":310
+ *                 raise TypeError('expected int, got: %r' % optval)
+ *             optval_int64_c = optval
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_setsockopt(
+ *                     self.handle, option,
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+    goto __pyx_L4;
+  }
+  /*else*/ {
+
+    /* "zmq/core/socket.pyx":321
+ *             # sockopts will still raise just the same, but it will be libzmq doing
+ *             # the raising.
+ *             if not isinstance(optval, int):             # <<<<<<<<<<<<<<
+ *                 raise TypeError('expected int, got: %r' % optval)
+ *             optval_int_c = optval
+ */
+    __pyx_t_2 = PyInt_Check(__pyx_v_optval); 
+    __pyx_t_5 = (!__pyx_t_2);
+    if (__pyx_t_5) {
+
+      /* "zmq/core/socket.pyx":322
+ *             # the raising.
+ *             if not isinstance(optval, int):
+ *                 raise TypeError('expected int, got: %r' % optval)             # <<<<<<<<<<<<<<
+ *             optval_int_c = optval
+ *             with nogil:
+ */
+      __pyx_t_1 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_5), __pyx_v_optval); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_1));
+      __Pyx_GIVEREF(((PyObject *)__pyx_t_1));
+      __pyx_t_1 = 0;
+      __pyx_t_1 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L13;
+    }
+    __pyx_L13:;
+
+    /* "zmq/core/socket.pyx":323
+ *             if not isinstance(optval, int):
+ *                 raise TypeError('expected int, got: %r' % optval)
+ *             optval_int_c = optval             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_setsockopt(
+ */
+    __pyx_t_9 = __Pyx_PyInt_AsInt(__pyx_v_optval); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_optval_int_c = __pyx_t_9;
+
+    /* "zmq/core/socket.pyx":324
+ *                 raise TypeError('expected int, got: %r' % optval)
+ *             optval_int_c = optval
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_setsockopt(
+ *                     self.handle, option,
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/socket.pyx":327
+ *                 rc = zmq_setsockopt(
+ *                     self.handle, option,
+ *                     &optval_int_c, sizeof(int)             # <<<<<<<<<<<<<<
+ *                 )
+ * 
+ */
+          __pyx_v_rc = zmq_setsockopt(__pyx_v_self->handle, __pyx_v_option, (&__pyx_v_optval_int_c), (sizeof(int)));
+        }
+
+        /* "zmq/core/socket.pyx":324
+ *                 raise TypeError('expected int, got: %r' % optval)
+ *             optval_int_c = optval
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_setsockopt(
+ *                     self.handle, option,
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/socket.pyx":330
+ *                 )
+ * 
+ *         _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *     def get(self, int option):
+ */
+  __pyx_t_9 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_9 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.set", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_13get(PyObject *__pyx_v_self, PyObject *__pyx_arg_option); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_12get[] = "s.get(option)\n\n        Get the value of a socket option.\n\n        See the 0MQ API documentation for details on specific options.\n\n        Parameters\n        ----------\n        option : int\n            The option to get.  Available values will depend on your\n            version of libzmq.  Examples include::\n            \n                zmq.IDENTITY, HWM, LINGER, FD, EVENTS\n\n        Returns\n        -------\n        optval : int or bytes\n            The value of the option as a bytestring or int.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_13get(PyObject *__pyx_v_self, PyObject *__pyx_arg_option) {
+  int __pyx_v_option;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get (wrapper)", 0);
+  assert(__pyx_arg_option); {
+    __pyx_v_option = __Pyx_PyInt_AsInt(__pyx_arg_option); if (unlikely((__pyx_v_option == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_12get(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), ((int)__pyx_v_option));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":332
+ *         _check_rc(rc)
+ * 
+ *     def get(self, int option):             # <<<<<<<<<<<<<<
+ *         """s.get(option)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_12get(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, int __pyx_v_option) {
+  pyzmq_int64_t __pyx_v_optval_int64_c;
+  int __pyx_v_optval_int_c;
+  ZMQ_FD_T __pyx_v_optval_fd_c;
+  char __pyx_v_identity_str_c[255];
+  size_t __pyx_v_sz;
+  int __pyx_v_rc;
+  PyObject *__pyx_v_result = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get", 0);
+
+  /* "zmq/core/socket.pyx":359
+ *         cdef int rc
+ * 
+ *         _check_closed(self, True)             # <<<<<<<<<<<<<<
+ * 
+ *         if option in zmq.constants.bytes_sockopts:
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":361
+ *         _check_closed(self, True)
+ * 
+ *         if option in zmq.constants.bytes_sockopts:             # <<<<<<<<<<<<<<
+ *             sz = 255
+ *             with nogil:
+ */
+  __pyx_t_1 = PyInt_FromLong(__pyx_v_option); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__zmq); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s__constants); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s__bytes_sockopts); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_4 = (__Pyx_PySequence_Contains(__pyx_t_1, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":362
+ * 
+ *         if option in zmq.constants.bytes_sockopts:
+ *             sz = 255             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>identity_str_c, &sz)
+ */
+    __pyx_v_sz = 255;
+
+    /* "zmq/core/socket.pyx":363
+ *         if option in zmq.constants.bytes_sockopts:
+ *             sz = 255
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>identity_str_c, &sz)
+ *             _check_rc(rc)
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/socket.pyx":364
+ *             sz = 255
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>identity_str_c, &sz)             # <<<<<<<<<<<<<<
+ *             _check_rc(rc)
+ *             result = PyBytes_FromStringAndSize(<char *>identity_str_c, sz)
+ */
+          __pyx_v_rc = zmq_getsockopt(__pyx_v_self->handle, __pyx_v_option, ((void *)__pyx_v_identity_str_c), (&__pyx_v_sz));
+        }
+
+        /* "zmq/core/socket.pyx":363
+ *         if option in zmq.constants.bytes_sockopts:
+ *             sz = 255
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>identity_str_c, &sz)
+ *             _check_rc(rc)
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+
+    /* "zmq/core/socket.pyx":365
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>identity_str_c, &sz)
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ *             result = PyBytes_FromStringAndSize(<char *>identity_str_c, sz)
+ *         elif option in zmq.constants.int64_sockopts:
+ */
+    __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 365; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "zmq/core/socket.pyx":366
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>identity_str_c, &sz)
+ *             _check_rc(rc)
+ *             result = PyBytes_FromStringAndSize(<char *>identity_str_c, sz)             # <<<<<<<<<<<<<<
+ *         elif option in zmq.constants.int64_sockopts:
+ *             sz = sizeof(int64_t)
+ */
+    __pyx_t_2 = ((PyObject *)PyBytes_FromStringAndSize(((char *)__pyx_v_identity_str_c), __pyx_v_sz)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_v_result = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L3;
+  }
+
+  /* "zmq/core/socket.pyx":367
+ *             _check_rc(rc)
+ *             result = PyBytes_FromStringAndSize(<char *>identity_str_c, sz)
+ *         elif option in zmq.constants.int64_sockopts:             # <<<<<<<<<<<<<<
+ *             sz = sizeof(int64_t)
+ *             with nogil:
+ */
+  __pyx_t_2 = PyInt_FromLong(__pyx_v_option); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__zmq); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s__constants); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s__int64_sockopts); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_4 = (__Pyx_PySequence_Contains(__pyx_t_2, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":368
+ *             result = PyBytes_FromStringAndSize(<char *>identity_str_c, sz)
+ *         elif option in zmq.constants.int64_sockopts:
+ *             sz = sizeof(int64_t)             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int64_c, &sz)
+ */
+    __pyx_v_sz = (sizeof(pyzmq_int64_t));
+
+    /* "zmq/core/socket.pyx":369
+ *         elif option in zmq.constants.int64_sockopts:
+ *             sz = sizeof(int64_t)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int64_c, &sz)
+ *             _check_rc(rc)
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/socket.pyx":370
+ *             sz = sizeof(int64_t)
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int64_c, &sz)             # <<<<<<<<<<<<<<
+ *             _check_rc(rc)
+ *             result = optval_int64_c
+ */
+          __pyx_v_rc = zmq_getsockopt(__pyx_v_self->handle, __pyx_v_option, ((void *)(&__pyx_v_optval_int64_c)), (&__pyx_v_sz));
+        }
+
+        /* "zmq/core/socket.pyx":369
+ *         elif option in zmq.constants.int64_sockopts:
+ *             sz = sizeof(int64_t)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int64_c, &sz)
+ *             _check_rc(rc)
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+
+    /* "zmq/core/socket.pyx":371
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int64_c, &sz)
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ *             result = optval_int64_c
+ *         elif option == ZMQ_FD:
+ */
+    __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "zmq/core/socket.pyx":372
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int64_c, &sz)
+ *             _check_rc(rc)
+ *             result = optval_int64_c             # <<<<<<<<<<<<<<
+ *         elif option == ZMQ_FD:
+ *             sz = sizeof(fd_t)
+ */
+    __pyx_t_1 = __Pyx_PyInt_to_py_pyzmq_int64_t(__pyx_v_optval_int64_c); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 372; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_v_result = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L3;
+  }
+
+  /* "zmq/core/socket.pyx":373
+ *             _check_rc(rc)
+ *             result = optval_int64_c
+ *         elif option == ZMQ_FD:             # <<<<<<<<<<<<<<
+ *             sz = sizeof(fd_t)
+ *             with nogil:
+ */
+  __pyx_t_4 = (__pyx_v_option == ZMQ_FD);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":374
+ *             result = optval_int64_c
+ *         elif option == ZMQ_FD:
+ *             sz = sizeof(fd_t)             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_fd_c, &sz)
+ */
+    __pyx_v_sz = (sizeof(ZMQ_FD_T));
+
+    /* "zmq/core/socket.pyx":375
+ *         elif option == ZMQ_FD:
+ *             sz = sizeof(fd_t)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_fd_c, &sz)
+ *             _check_rc(rc)
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/socket.pyx":376
+ *             sz = sizeof(fd_t)
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_fd_c, &sz)             # <<<<<<<<<<<<<<
+ *             _check_rc(rc)
+ *             result = optval_fd_c
+ */
+          __pyx_v_rc = zmq_getsockopt(__pyx_v_self->handle, __pyx_v_option, ((void *)(&__pyx_v_optval_fd_c)), (&__pyx_v_sz));
+        }
+
+        /* "zmq/core/socket.pyx":375
+ *         elif option == ZMQ_FD:
+ *             sz = sizeof(fd_t)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_fd_c, &sz)
+ *             _check_rc(rc)
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+
+    /* "zmq/core/socket.pyx":377
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_fd_c, &sz)
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ *             result = optval_fd_c
+ *         else:
+ */
+    __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "zmq/core/socket.pyx":378
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_fd_c, &sz)
+ *             _check_rc(rc)
+ *             result = optval_fd_c             # <<<<<<<<<<<<<<
+ *         else:
+ *             # default is to assume int, which is what most new sockopts will be
+ */
+    __pyx_t_1 = __Pyx_PyInt_to_py_ZMQ_FD_T(__pyx_v_optval_fd_c); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_v_result = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/socket.pyx":385
+ *             # sockopts will still raise just the same, but it will be libzmq doing
+ *             # the raising.
+ *             sz = sizeof(int)             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int_c, &sz)
+ */
+    __pyx_v_sz = (sizeof(int));
+
+    /* "zmq/core/socket.pyx":386
+ *             # the raising.
+ *             sz = sizeof(int)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int_c, &sz)
+ *             _check_rc(rc)
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/socket.pyx":387
+ *             sz = sizeof(int)
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int_c, &sz)             # <<<<<<<<<<<<<<
+ *             _check_rc(rc)
+ *             result = optval_int_c
+ */
+          __pyx_v_rc = zmq_getsockopt(__pyx_v_self->handle, __pyx_v_option, ((void *)(&__pyx_v_optval_int_c)), (&__pyx_v_sz));
+        }
+
+        /* "zmq/core/socket.pyx":386
+ *             # the raising.
+ *             sz = sizeof(int)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int_c, &sz)
+ *             _check_rc(rc)
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+
+    /* "zmq/core/socket.pyx":388
+ *             with nogil:
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int_c, &sz)
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ *             result = optval_int_c
+ * 
+ */
+    __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "zmq/core/socket.pyx":389
+ *                 rc = zmq_getsockopt(self.handle, option, <void *>&optval_int_c, &sz)
+ *             _check_rc(rc)
+ *             result = optval_int_c             # <<<<<<<<<<<<<<
+ * 
+ *         return result
+ */
+    __pyx_t_1 = PyInt_FromLong(__pyx_v_optval_int_c); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 389; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_v_result = __pyx_t_1;
+    __pyx_t_1 = 0;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":391
+ *             result = optval_int_c
+ * 
+ *         return result             # <<<<<<<<<<<<<<
+ * 
+ *     def bind(self, addr):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_result);
+  __pyx_r = __pyx_v_result;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_result);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_15bind(PyObject *__pyx_v_self, PyObject *__pyx_v_addr); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_14bind[] = "s.bind(addr)\n\n        Bind the socket to an address.\n\n        This causes the socket to listen on a network port. Sockets on the\n        other side of this connection will use ``Socket.connect(addr)`` to\n        connect to this socket.\n\n        Parameters\n        ----------\n        addr : str\n            The address string. This has the form 'protocol://interface:port',\n            for example 'tcp://127.0.0.1:5555'. Protocols supported include\n            tcp, udp, pgm, epgm, inproc and ipc. If the address is unicode, it is\n            encoded to utf-8 first.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_15bind(PyObject *__pyx_v_self, PyObject *__pyx_v_addr) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("bind (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_14bind(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), ((PyObject *)__pyx_v_addr));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":393
+ *         return result
+ * 
+ *     def bind(self, addr):             # <<<<<<<<<<<<<<
+ *         """s.bind(addr)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_14bind(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_addr) {
+  int __pyx_v_rc;
+  char *__pyx_v_c_addr;
+  PyObject *__pyx_v_path = NULL;
+  PyObject *__pyx_v_msg = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  char *__pyx_t_5;
+  int __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  int __pyx_t_8;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("bind", 0);
+  __Pyx_INCREF(__pyx_v_addr);
+
+  /* "zmq/core/socket.pyx":413
+ *         cdef char* c_addr
+ * 
+ *         _check_closed(self, True)             # <<<<<<<<<<<<<<
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":414
+ * 
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):             # <<<<<<<<<<<<<<
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_addr, __pyx_t_1); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "zmq/core/socket.pyx":415
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')             # <<<<<<<<<<<<<<
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ */
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_addr, __pyx_n_s__encode); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_k_tuple_7), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_v_addr);
+    __pyx_v_addr = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":416
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):             # <<<<<<<<<<<<<<
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr
+ */
+  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__bytes); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_addr, __pyx_t_3); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_4 = (!__pyx_t_2);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":417
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)             # <<<<<<<<<<<<<<
+ *         c_addr = addr
+ *         rc = zmq_bind(self.handle, c_addr)
+ */
+    __pyx_t_3 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_8), __pyx_v_addr); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_t_3));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_3));
+    __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/socket.pyx":418
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr             # <<<<<<<<<<<<<<
+ *         rc = zmq_bind(self.handle, c_addr)
+ *         if rc != 0:
+ */
+  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_addr); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_c_addr = __pyx_t_5;
+
+  /* "zmq/core/socket.pyx":419
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr
+ *         rc = zmq_bind(self.handle, c_addr)             # <<<<<<<<<<<<<<
+ *         if rc != 0:
+ *             if IPC_PATH_MAX_LEN and zmq_errno() == ENAMETOOLONG:
+ */
+  __pyx_v_rc = zmq_bind(__pyx_v_self->handle, __pyx_v_c_addr);
+
+  /* "zmq/core/socket.pyx":420
+ *         c_addr = addr
+ *         rc = zmq_bind(self.handle, c_addr)
+ *         if rc != 0:             # <<<<<<<<<<<<<<
+ *             if IPC_PATH_MAX_LEN and zmq_errno() == ENAMETOOLONG:
+ *                 # py3compat: addr is bytes, but msg wants str
+ */
+  __pyx_t_4 = (__pyx_v_rc != 0);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":421
+ *         rc = zmq_bind(self.handle, c_addr)
+ *         if rc != 0:
+ *             if IPC_PATH_MAX_LEN and zmq_errno() == ENAMETOOLONG:             # <<<<<<<<<<<<<<
+ *                 # py3compat: addr is bytes, but msg wants str
+ *                 if str is unicode:
+ */
+    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__IPC_PATH_MAX_LEN); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (__pyx_t_4) {
+      __pyx_t_2 = (zmq_errno() == ENAMETOOLONG);
+      __pyx_t_6 = __pyx_t_2;
+    } else {
+      __pyx_t_6 = __pyx_t_4;
+    }
+    if (__pyx_t_6) {
+
+      /* "zmq/core/socket.pyx":423
+ *             if IPC_PATH_MAX_LEN and zmq_errno() == ENAMETOOLONG:
+ *                 # py3compat: addr is bytes, but msg wants str
+ *                 if str is unicode:             # <<<<<<<<<<<<<<
+ *                     addr = addr.decode('utf-8', 'replace')
+ *                 path = addr.split('://', 1)[-1]
+ */
+      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_6 = (((PyObject*)(&PyString_Type)) == ((PyObject*)__pyx_t_3));
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (__pyx_t_6) {
+
+        /* "zmq/core/socket.pyx":424
+ *                 # py3compat: addr is bytes, but msg wants str
+ *                 if str is unicode:
+ *                     addr = addr.decode('utf-8', 'replace')             # <<<<<<<<<<<<<<
+ *                 path = addr.split('://', 1)[-1]
+ *                 msg = ('ipc path "{0}" is longer than {1} '
+ */
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_addr, __pyx_n_s__decode); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_1 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_k_tuple_9), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        __Pyx_DECREF(__pyx_v_addr);
+        __pyx_v_addr = __pyx_t_1;
+        __pyx_t_1 = 0;
+        goto __pyx_L7;
+      }
+      __pyx_L7:;
+
+      /* "zmq/core/socket.pyx":425
+ *                 if str is unicode:
+ *                     addr = addr.decode('utf-8', 'replace')
+ *                 path = addr.split('://', 1)[-1]             # <<<<<<<<<<<<<<
+ *                 msg = ('ipc path "{0}" is longer than {1} '
+ *                                 'characters (sizeof(sockaddr_un.sun_path)). '
+ */
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_addr, __pyx_n_s__split); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_k_tuple_11), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_3, -1, sizeof(long), PyInt_FromLong, 0, 1, 1); if (!__pyx_t_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_v_path = __pyx_t_1;
+      __pyx_t_1 = 0;
+
+      /* "zmq/core/socket.pyx":430
+ *                                 'zmq.IPC_PATH_MAX_LEN constant can be used '
+ *                                 'to check addr length (if it is defined).'
+ *                                 .format(path, IPC_PATH_MAX_LEN))             # <<<<<<<<<<<<<<
+ *                 raise ZMQError(msg=msg)
+ *         _check_rc(rc)
+ */
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_kp_s_12), __pyx_n_s__format); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__IPC_PATH_MAX_LEN); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_7);
+      __Pyx_INCREF(__pyx_v_path);
+      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_path);
+      __Pyx_GIVEREF(__pyx_v_path);
+      PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_3);
+      __pyx_t_3 = 0;
+      __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_7), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
+      __pyx_v_msg = __pyx_t_3;
+      __pyx_t_3 = 0;
+
+      /* "zmq/core/socket.pyx":431
+ *                                 'to check addr length (if it is defined).'
+ *                                 .format(path, IPC_PATH_MAX_LEN))
+ *                 raise ZMQError(msg=msg)             # <<<<<<<<<<<<<<
+ *         _check_rc(rc)
+ * 
+ */
+      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 431; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_7 = PyDict_New(); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 431; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_7));
+      if (PyDict_SetItem(__pyx_t_7, ((PyObject *)__pyx_n_s__msg), __pyx_v_msg) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 431; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), ((PyObject *)__pyx_t_7)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 431; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 431; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L6;
+    }
+    __pyx_L6:;
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
+
+  /* "zmq/core/socket.pyx":432
+ *                                 .format(path, IPC_PATH_MAX_LEN))
+ *                 raise ZMQError(msg=msg)
+ *         _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *     def connect(self, addr):
+ */
+  __pyx_t_8 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_8 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.bind", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_path);
+  __Pyx_XDECREF(__pyx_v_msg);
+  __Pyx_XDECREF(__pyx_v_addr);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_17connect(PyObject *__pyx_v_self, PyObject *__pyx_v_addr); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_16connect[] = "s.connect(addr)\n\n        Connect to a remote 0MQ socket.\n\n        Parameters\n        ----------\n        addr : str\n            The address string. This has the form 'protocol://interface:port',\n            for example 'tcp://127.0.0.1:5555'. Protocols supported are\n            tcp, upd, pgm, inproc and ipc. If the address is unicode, it is\n            encoded to utf-8 first.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_17connect(PyObject *__pyx_v_self, PyObject *__pyx_v_addr) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("connect (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_16connect(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), ((PyObject *)__pyx_v_addr));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":434
+ *         _check_rc(rc)
+ * 
+ *     def connect(self, addr):             # <<<<<<<<<<<<<<
+ *         """s.connect(addr)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_16connect(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_addr) {
+  int __pyx_v_rc;
+  char *__pyx_v_c_addr;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  char *__pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("connect", 0);
+  __Pyx_INCREF(__pyx_v_addr);
+
+  /* "zmq/core/socket.pyx":450
+ *         cdef char* c_addr
+ * 
+ *         _check_closed(self, True)             # <<<<<<<<<<<<<<
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":451
+ * 
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):             # <<<<<<<<<<<<<<
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_addr, __pyx_t_1); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "zmq/core/socket.pyx":452
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')             # <<<<<<<<<<<<<<
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ */
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_addr, __pyx_n_s__encode); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_k_tuple_13), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_v_addr);
+    __pyx_v_addr = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":453
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):             # <<<<<<<<<<<<<<
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr
+ */
+  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__bytes); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_addr, __pyx_t_3); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_4 = (!__pyx_t_2);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":454
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)             # <<<<<<<<<<<<<<
+ *         c_addr = addr
+ * 
+ */
+    __pyx_t_3 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_8), __pyx_v_addr); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_t_3));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_3));
+    __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/socket.pyx":455
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr             # <<<<<<<<<<<<<<
+ * 
+ *         rc = zmq_connect(self.handle, c_addr)
+ */
+  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_addr); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 455; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_c_addr = __pyx_t_5;
+
+  /* "zmq/core/socket.pyx":457
+ *         c_addr = addr
+ * 
+ *         rc = zmq_connect(self.handle, c_addr)             # <<<<<<<<<<<<<<
+ *         if rc != 0:
+ *             raise ZMQError()
+ */
+  __pyx_v_rc = zmq_connect(__pyx_v_self->handle, __pyx_v_c_addr);
+
+  /* "zmq/core/socket.pyx":458
+ * 
+ *         rc = zmq_connect(self.handle, c_addr)
+ *         if rc != 0:             # <<<<<<<<<<<<<<
+ *             raise ZMQError()
+ * 
+ */
+  __pyx_t_4 = (__pyx_v_rc != 0);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":459
+ *         rc = zmq_connect(self.handle, c_addr)
+ *         if rc != 0:
+ *             raise ZMQError()             # <<<<<<<<<<<<<<
+ * 
+ *     def unbind(self, addr):
+ */
+    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_1 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.connect", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_addr);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_19unbind(PyObject *__pyx_v_self, PyObject *__pyx_v_addr); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_18unbind[] = "s.unbind(addr)\n        \n        Unbind from an address (undoes a call to bind).\n        \n        This feature requires libzmq-3\n\n        Parameters\n        ----------\n        addr : str\n            The address string. This has the form 'protocol://interface:port',\n            for example 'tcp://127.0.0.1:5555'. Protocols supported are\n            tcp, upd, pgm, inproc and ipc. If the address is unicode, it is\n            encoded to utf-8 first.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_19unbind(PyObject *__pyx_v_self, PyObject *__pyx_v_addr) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("unbind (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_18unbind(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), ((PyObject *)__pyx_v_addr));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":461
+ *             raise ZMQError()
+ * 
+ *     def unbind(self, addr):             # <<<<<<<<<<<<<<
+ *         """s.unbind(addr)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_18unbind(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_addr) {
+  int __pyx_v_rc;
+  char *__pyx_v_c_addr;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  char *__pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("unbind", 0);
+  __Pyx_INCREF(__pyx_v_addr);
+
+  /* "zmq/core/socket.pyx":479
+ *         cdef char* c_addr
+ * 
+ *         if ZMQ_VERSION_MAJOR < 3:             # <<<<<<<<<<<<<<
+ *             raise NotImplementedError("unbind requires libzmq >= 3.0, have %s" % zmq.zmq_version())
+ * 
+ */
+  __pyx_t_1 = (ZMQ_VERSION_MAJOR < 3);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/socket.pyx":480
+ * 
+ *         if ZMQ_VERSION_MAJOR < 3:
+ *             raise NotImplementedError("unbind requires libzmq >= 3.0, have %s" % zmq.zmq_version())             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__zmq); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s__zmq_version); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_14), __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_t_3));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_3));
+    __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_NotImplementedError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":483
+ * 
+ * 
+ *         _check_closed(self, True)             # <<<<<<<<<<<<<<
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')
+ */
+  __pyx_t_3 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/socket.pyx":484
+ * 
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):             # <<<<<<<<<<<<<<
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):
+ */
+  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_addr, __pyx_t_3); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (__pyx_t_1) {
+
+    /* "zmq/core/socket.pyx":485
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')             # <<<<<<<<<<<<<<
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ */
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_addr, __pyx_n_s__encode); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_k_tuple_15), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_v_addr);
+    __pyx_v_addr = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/socket.pyx":486
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):             # <<<<<<<<<<<<<<
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr
+ */
+  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__bytes); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_addr, __pyx_t_2); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_4 = (!__pyx_t_1);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":487
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)             # <<<<<<<<<<<<<<
+ *         c_addr = addr
+ * 
+ */
+    __pyx_t_2 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_8), __pyx_v_addr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_2));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_2));
+    __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
+
+  /* "zmq/core/socket.pyx":488
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr             # <<<<<<<<<<<<<<
+ * 
+ *         rc = zmq_unbind(self.handle, c_addr)
+ */
+  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_addr); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_c_addr = __pyx_t_5;
+
+  /* "zmq/core/socket.pyx":490
+ *         c_addr = addr
+ * 
+ *         rc = zmq_unbind(self.handle, c_addr)             # <<<<<<<<<<<<<<
+ *         if rc != 0:
+ *             raise ZMQError()
+ */
+  __pyx_v_rc = zmq_unbind(__pyx_v_self->handle, __pyx_v_c_addr);
+
+  /* "zmq/core/socket.pyx":491
+ * 
+ *         rc = zmq_unbind(self.handle, c_addr)
+ *         if rc != 0:             # <<<<<<<<<<<<<<
+ *             raise ZMQError()
+ * 
+ */
+  __pyx_t_4 = (__pyx_v_rc != 0);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":492
+ *         rc = zmq_unbind(self.handle, c_addr)
+ *         if rc != 0:
+ *             raise ZMQError()             # <<<<<<<<<<<<<<
+ * 
+ *     def disconnect(self, addr):
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.unbind", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_addr);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_21disconnect(PyObject *__pyx_v_self, PyObject *__pyx_v_addr); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_20disconnect[] = "s.disconnect(addr)\n\n        Disconnect from a remote 0MQ socket (undoes a call to connect).\n        \n        This feature requires libzmq-3\n\n        Parameters\n        ----------\n        addr : str\n            The address string. This has the form 'protocol://interface:port',\n            for example 'tcp://127.0.0.1:5555'. Protocols supported are\n            tcp, upd, pgm, inproc and ipc. If the address is unicode, it is\n            encoded to utf-8 first.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_21disconnect(PyObject *__pyx_v_self, PyObject *__pyx_v_addr) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("disconnect (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_20disconnect(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), ((PyObject *)__pyx_v_addr));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":494
+ *             raise ZMQError()
+ * 
+ *     def disconnect(self, addr):             # <<<<<<<<<<<<<<
+ *         """s.disconnect(addr)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_20disconnect(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_addr) {
+  int __pyx_v_rc;
+  char *__pyx_v_c_addr;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  char *__pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("disconnect", 0);
+  __Pyx_INCREF(__pyx_v_addr);
+
+  /* "zmq/core/socket.pyx":512
+ *         cdef char* c_addr
+ * 
+ *         if ZMQ_VERSION_MAJOR < 3:             # <<<<<<<<<<<<<<
+ *             raise NotImplementedError("disconnect requires libzmq >= 3.0, have %s" % zmq.zmq_version())
+ * 
+ */
+  __pyx_t_1 = (ZMQ_VERSION_MAJOR < 3);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/socket.pyx":513
+ * 
+ *         if ZMQ_VERSION_MAJOR < 3:
+ *             raise NotImplementedError("disconnect requires libzmq >= 3.0, have %s" % zmq.zmq_version())             # <<<<<<<<<<<<<<
+ * 
+ *         _check_closed(self, True)
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__zmq); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s__zmq_version); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_16), __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_t_3));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_3));
+    __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_NotImplementedError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":515
+ *             raise NotImplementedError("disconnect requires libzmq >= 3.0, have %s" % zmq.zmq_version())
+ * 
+ *         _check_closed(self, True)             # <<<<<<<<<<<<<<
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')
+ */
+  __pyx_t_3 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "zmq/core/socket.pyx":516
+ * 
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):             # <<<<<<<<<<<<<<
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):
+ */
+  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_addr, __pyx_t_3); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (__pyx_t_1) {
+
+    /* "zmq/core/socket.pyx":517
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')             # <<<<<<<<<<<<<<
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ */
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_addr, __pyx_n_s__encode); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_k_tuple_17), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_v_addr);
+    __pyx_v_addr = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/socket.pyx":518
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):             # <<<<<<<<<<<<<<
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr
+ */
+  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__bytes); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_addr, __pyx_t_2); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_4 = (!__pyx_t_1);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":519
+ *             addr = addr.encode('utf-8')
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)             # <<<<<<<<<<<<<<
+ *         c_addr = addr
+ * 
+ */
+    __pyx_t_2 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_8), __pyx_v_addr); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_2));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_2));
+    __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
+
+  /* "zmq/core/socket.pyx":520
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ *         c_addr = addr             # <<<<<<<<<<<<<<
+ * 
+ *         rc = zmq_disconnect(self.handle, c_addr)
+ */
+  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_addr); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 520; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_c_addr = __pyx_t_5;
+
+  /* "zmq/core/socket.pyx":522
+ *         c_addr = addr
+ * 
+ *         rc = zmq_disconnect(self.handle, c_addr)             # <<<<<<<<<<<<<<
+ *         if rc != 0:
+ *             raise ZMQError()
+ */
+  __pyx_v_rc = zmq_disconnect(__pyx_v_self->handle, __pyx_v_c_addr);
+
+  /* "zmq/core/socket.pyx":523
+ * 
+ *         rc = zmq_disconnect(self.handle, c_addr)
+ *         if rc != 0:             # <<<<<<<<<<<<<<
+ *             raise ZMQError()
+ * 
+ */
+  __pyx_t_4 = (__pyx_v_rc != 0);
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":524
+ *         rc = zmq_disconnect(self.handle, c_addr)
+ *         if rc != 0:
+ *             raise ZMQError()             # <<<<<<<<<<<<<<
+ * 
+ *     #-------------------------------------------------------------------------
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.disconnect", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_addr);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":530
+ *     #-------------------------------------------------------------------------
+ * 
+ *     cpdef object send(self, object data, int flags=0, copy=True, track=False):             # <<<<<<<<<<<<<<
+ *         """s.send(data, flags=0, copy=True, track=False)
+ * 
+ */
+
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_23send(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_3zmq_4core_6socket_6Socket_send(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send *__pyx_optional_args) {
+  int __pyx_v_flags = ((int)0);
+  PyObject *__pyx_v_copy = __pyx_k_18;
+  PyObject *__pyx_v_track = __pyx_k_19;
+  PyObject *__pyx_v_msg = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  struct __pyx_opt_args_3zmq_4core_6socket__send_copy __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  struct __pyx_opt_args_3zmq_4core_6socket__send_frame __pyx_t_8;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("send", 0);
+  if (__pyx_optional_args) {
+    if (__pyx_optional_args->__pyx_n > 0) {
+      __pyx_v_flags = __pyx_optional_args->flags;
+      if (__pyx_optional_args->__pyx_n > 1) {
+        __pyx_v_copy = __pyx_optional_args->copy;
+        if (__pyx_optional_args->__pyx_n > 2) {
+          __pyx_v_track = __pyx_optional_args->track;
+        }
+      }
+    }
+  }
+  __Pyx_INCREF(__pyx_v_data);
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s__send); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_23send)) {
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyInt_FromLong(__pyx_v_flags); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_v_data);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_data);
+      __Pyx_GIVEREF(__pyx_v_data);
+      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_2);
+      __Pyx_INCREF(__pyx_v_copy);
+      PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_copy);
+      __Pyx_GIVEREF(__pyx_v_copy);
+      __Pyx_INCREF(__pyx_v_track);
+      PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_v_track);
+      __Pyx_GIVEREF(__pyx_v_track);
+      __pyx_t_2 = 0;
+      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      goto __pyx_L0;
+    }
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  }
+
+  /* "zmq/core/socket.pyx":567
+ * 
+ *         """
+ *         _check_closed(self, True)             # <<<<<<<<<<<<<<
+ * 
+ *         if isinstance(data, unicode):
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":569
+ *         _check_closed(self, True)
+ * 
+ *         if isinstance(data, unicode):             # <<<<<<<<<<<<<<
+ *             raise TypeError("unicode not allowed, use send_unicode")
+ * 
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = PyObject_IsInstance(__pyx_v_data, __pyx_t_1); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":570
+ * 
+ *         if isinstance(data, unicode):
+ *             raise TypeError("unicode not allowed, use send_unicode")             # <<<<<<<<<<<<<<
+ * 
+ *         if copy:
+ */
+    __pyx_t_1 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_k_tuple_21), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/socket.pyx":572
+ *             raise TypeError("unicode not allowed, use send_unicode")
+ * 
+ *         if copy:             # <<<<<<<<<<<<<<
+ *             # msg.bytes never returns the input data object
+ *             # it is always a copy, but always the same copy
+ */
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_copy); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":575
+ *             # msg.bytes never returns the input data object
+ *             # it is always a copy, but always the same copy
+ *             if isinstance(data, Frame):             # <<<<<<<<<<<<<<
+ *                 data = data.buffer
+ *             return _send_copy(self.handle, data, flags)
+ */
+    __pyx_t_4 = __Pyx_TypeCheck(__pyx_v_data, ((PyObject*)__pyx_ptype_3zmq_4core_7message_Frame)); 
+    if (__pyx_t_4) {
+
+      /* "zmq/core/socket.pyx":576
+ *             # it is always a copy, but always the same copy
+ *             if isinstance(data, Frame):
+ *                 data = data.buffer             # <<<<<<<<<<<<<<
+ *             return _send_copy(self.handle, data, flags)
+ *         else:
+ */
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s__buffer); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_v_data);
+      __pyx_v_data = __pyx_t_1;
+      __pyx_t_1 = 0;
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "zmq/core/socket.pyx":577
+ *             if isinstance(data, Frame):
+ *                 data = data.buffer
+ *             return _send_copy(self.handle, data, flags)             # <<<<<<<<<<<<<<
+ *         else:
+ *             if isinstance(data, Frame):
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_5.__pyx_n = 1;
+    __pyx_t_5.flags = __pyx_v_flags;
+    __pyx_t_1 = __pyx_f_3zmq_4core_6socket__send_copy(__pyx_v_self->handle, __pyx_v_data, &__pyx_t_5); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L4;
+  }
+  /*else*/ {
+
+    /* "zmq/core/socket.pyx":579
+ *             return _send_copy(self.handle, data, flags)
+ *         else:
+ *             if isinstance(data, Frame):             # <<<<<<<<<<<<<<
+ *                 if track and not data.tracker:
+ *                     raise ValueError('Not a tracked message')
+ */
+    __pyx_t_4 = __Pyx_TypeCheck(__pyx_v_data, ((PyObject*)__pyx_ptype_3zmq_4core_7message_Frame)); 
+    if (__pyx_t_4) {
+
+      /* "zmq/core/socket.pyx":580
+ *         else:
+ *             if isinstance(data, Frame):
+ *                 if track and not data.tracker:             # <<<<<<<<<<<<<<
+ *                     raise ValueError('Not a tracked message')
+ *                 msg = data
+ */
+      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_track); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      if (__pyx_t_4) {
+        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s__tracker); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        __pyx_t_7 = (!__pyx_t_6);
+        __pyx_t_6 = __pyx_t_7;
+      } else {
+        __pyx_t_6 = __pyx_t_4;
+      }
+      if (__pyx_t_6) {
+
+        /* "zmq/core/socket.pyx":581
+ *             if isinstance(data, Frame):
+ *                 if track and not data.tracker:
+ *                     raise ValueError('Not a tracked message')             # <<<<<<<<<<<<<<
+ *                 msg = data
+ *             else:
+ */
+        __pyx_t_1 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_23), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 581; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 581; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        goto __pyx_L7;
+      }
+      __pyx_L7:;
+
+      /* "zmq/core/socket.pyx":582
+ *                 if track and not data.tracker:
+ *                     raise ValueError('Not a tracked message')
+ *                 msg = data             # <<<<<<<<<<<<<<
+ *             else:
+ *                 msg = Frame(data, track=track)
+ */
+      __Pyx_INCREF(__pyx_v_data);
+      __pyx_v_msg = __pyx_v_data;
+      goto __pyx_L6;
+    }
+    /*else*/ {
+
+      /* "zmq/core/socket.pyx":584
+ *                 msg = data
+ *             else:
+ *                 msg = Frame(data, track=track)             # <<<<<<<<<<<<<<
+ *             return _send_frame(self.handle, msg, flags)
+ * 
+ */
+      __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_INCREF(__pyx_v_data);
+      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_data);
+      __Pyx_GIVEREF(__pyx_v_data);
+      __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+      if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_n_s__track), __pyx_v_track) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3zmq_4core_7message_Frame)), ((PyObject *)__pyx_t_1), ((PyObject *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+      __pyx_v_msg = __pyx_t_3;
+      __pyx_t_3 = 0;
+    }
+    __pyx_L6:;
+
+    /* "zmq/core/socket.pyx":585
+ *             else:
+ *                 msg = Frame(data, track=track)
+ *             return _send_frame(self.handle, msg, flags)             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef object recv(self, int flags=0, copy=True, track=False):
+ */
+    __Pyx_XDECREF(__pyx_r);
+    if (!(likely(((__pyx_v_msg) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_msg, __pyx_ptype_3zmq_4core_7message_Frame))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_8.__pyx_n = 1;
+    __pyx_t_8.flags = __pyx_v_flags;
+    __pyx_t_3 = __pyx_f_3zmq_4core_6socket__send_frame(__pyx_v_self->handle, ((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_msg), &__pyx_t_8); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L4:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.send", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_msg);
+  __Pyx_XDECREF(__pyx_v_data);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_23send(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_22send[] = "s.send(data, flags=0, copy=True, track=False)\n\n        Send a message on this socket.\n\n        This queues the message to be sent by the IO thread at a later time.\n\n        Parameters\n        ----------\n        data : object, str, Frame\n            The content of the message.\n        flags : int\n            Any supported flag: NOBLOCK, SNDMORE.\n        copy : bool\n            Should the message be sent in a copying or non-copying manner.\n        track : bool\n            Should the message be tracked for notification that ZMQ has\n            finished with it? (ignored if copy=True)\n\n        Returns\n        -------\n        None : if `copy` or not track\n            None if message was sent, raises an exception otherwise.\n        MessageTracker : if track and not copy\n            a MessageTracker object, whose `pending` property will\n            be True until the send is completed.\n        \n        Raises\n        ------\n        TypeError\n            If a unicode object is passed\n        ValueError\n            If `track=True`, but an untracked Frame is passed.\n        ZMQError\n            If the send does not succeed for any reason.\n        \n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_23send(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_data = 0;
+  int __pyx_v_flags;
+  PyObject *__pyx_v_copy = 0;
+  PyObject *__pyx_v_track = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("send (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__data,&__pyx_n_s__flags,&__pyx_n_s__copy,&__pyx_n_s__track,0};
+    PyObject* values[4] = {0,0,0,0};
+    values[2] = __pyx_k_18;
+    values[3] = __pyx_k_19;
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__data)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__flags);
+          if (value) { values[1] = value; kw_args--; }
+        }
+        case  2:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__copy);
+          if (value) { values[2] = value; kw_args--; }
+        }
+        case  3:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__track);
+          if (value) { values[3] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "send") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_data = values[0];
+    if (values[1]) {
+      __pyx_v_flags = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    } else {
+      __pyx_v_flags = ((int)0);
+    }
+    __pyx_v_copy = values[2];
+    __pyx_v_track = values[3];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("send", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.send", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_22send(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), __pyx_v_data, __pyx_v_flags, __pyx_v_copy, __pyx_v_track);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":530
+ *     #-------------------------------------------------------------------------
+ * 
+ *     cpdef object send(self, object data, int flags=0, copy=True, track=False):             # <<<<<<<<<<<<<<
+ *         """s.send(data, flags=0, copy=True, track=False)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_22send(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_v_flags, PyObject *__pyx_v_copy, PyObject *__pyx_v_track) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("send", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2.__pyx_n = 3;
+  __pyx_t_2.flags = __pyx_v_flags;
+  __pyx_t_2.copy = __pyx_v_copy;
+  __pyx_t_2.track = __pyx_v_track;
+  __pyx_t_1 = ((struct __pyx_vtabstruct_3zmq_4core_6socket_Socket *)__pyx_v_self->__pyx_vtab)->send(__pyx_v_self, __pyx_v_data, 1, &__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.send", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":587
+ *             return _send_frame(self.handle, msg, flags)
+ * 
+ *     cpdef object recv(self, int flags=0, copy=True, track=False):             # <<<<<<<<<<<<<<
+ *         """s.recv(flags=0, copy=True, track=False)
+ * 
+ */
+
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_25recv(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_f_3zmq_4core_6socket_6Socket_recv(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv *__pyx_optional_args) {
+  int __pyx_v_flags = ((int)0);
+  PyObject *__pyx_v_copy = __pyx_k_24;
+  PyObject *__pyx_v_track = __pyx_k_25;
+  struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_frame = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  struct __pyx_opt_args_3zmq_4core_6socket__recv_copy __pyx_t_5;
+  struct __pyx_opt_args_3zmq_4core_6socket__recv_frame __pyx_t_6;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("recv", 0);
+  if (__pyx_optional_args) {
+    if (__pyx_optional_args->__pyx_n > 0) {
+      __pyx_v_flags = __pyx_optional_args->flags;
+      if (__pyx_optional_args->__pyx_n > 1) {
+        __pyx_v_copy = __pyx_optional_args->copy;
+        if (__pyx_optional_args->__pyx_n > 2) {
+          __pyx_v_track = __pyx_optional_args->track;
+        }
+      }
+    }
+  }
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s__recv); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_25recv)) {
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyInt_FromLong(__pyx_v_flags); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_2);
+      __Pyx_INCREF(__pyx_v_copy);
+      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_copy);
+      __Pyx_GIVEREF(__pyx_v_copy);
+      __Pyx_INCREF(__pyx_v_track);
+      PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_track);
+      __Pyx_GIVEREF(__pyx_v_track);
+      __pyx_t_2 = 0;
+      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      goto __pyx_L0;
+    }
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  }
+
+  /* "zmq/core/socket.pyx":618
+ *             for any of the reasons zmq_msg_recv might fail.
+ *         """
+ *         _check_closed(self, True)             # <<<<<<<<<<<<<<
+ * 
+ *         if copy:
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_6socket__check_closed(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":620
+ *         _check_closed(self, True)
+ * 
+ *         if copy:             # <<<<<<<<<<<<<<
+ *             return _recv_copy(self.handle, flags)
+ *         else:
+ */
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_copy); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 620; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_4) {
+
+    /* "zmq/core/socket.pyx":621
+ * 
+ *         if copy:
+ *             return _recv_copy(self.handle, flags)             # <<<<<<<<<<<<<<
+ *         else:
+ *             frame = _recv_frame(self.handle, flags, track)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_5.__pyx_n = 1;
+    __pyx_t_5.flags = __pyx_v_flags;
+    __pyx_t_1 = __pyx_f_3zmq_4core_6socket__recv_copy(__pyx_v_self->handle, &__pyx_t_5); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/socket.pyx":623
+ *             return _recv_copy(self.handle, flags)
+ *         else:
+ *             frame = _recv_frame(self.handle, flags, track)             # <<<<<<<<<<<<<<
+ *             frame.more = self.getsockopt(zmq.RCVMORE)
+ *             return frame
+ */
+    __pyx_t_6.__pyx_n = 2;
+    __pyx_t_6.flags = __pyx_v_flags;
+    __pyx_t_6.track = __pyx_v_track;
+    __pyx_t_1 = ((PyObject *)__pyx_f_3zmq_4core_6socket__recv_frame(__pyx_v_self->handle, &__pyx_t_6)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 623; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_v_frame = ((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_t_1);
+    __pyx_t_1 = 0;
+
+    /* "zmq/core/socket.pyx":624
+ *         else:
+ *             frame = _recv_frame(self.handle, flags, track)
+ *             frame.more = self.getsockopt(zmq.RCVMORE)             # <<<<<<<<<<<<<<
+ *             return frame
+ * 
+ */
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s__getsockopt); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__zmq); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s__RCVMORE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
+    __Pyx_GIVEREF(__pyx_t_3);
+    __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_v_frame->more = __pyx_t_4;
+
+    /* "zmq/core/socket.pyx":625
+ *             frame = _recv_frame(self.handle, flags, track)
+ *             frame.more = self.getsockopt(zmq.RCVMORE)
+ *             return frame             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)__pyx_v_frame));
+    __pyx_r = ((PyObject *)__pyx_v_frame);
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.recv", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_frame);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_25recv(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_6socket_6Socket_24recv[] = "s.recv(flags=0, copy=True, track=False)\n\n        Receive a message.\n\n        Parameters\n        ----------\n        flags : int\n            Any supported flag: NOBLOCK. If NOBLOCK is set, this method\n            will raise a ZMQError with EAGAIN if a message is not ready.\n            If NOBLOCK is not set, then this method will block until a\n            message arrives.\n        copy : bool\n            Should the message be received in a copying or non-copying manner?\n            If False a Frame object is returned, if True a string copy of\n            message is returned.\n        track : bool\n            Should the message be tracked for notification that ZMQ has\n            finished with it? (ignored if copy=True)\n\n        Returns\n        -------\n        msg : bytes, Frame\n            The received message frame.  If `copy` is False, then it will be a Frame,\n            otherwise it will be bytes.\n            \n        Raises\n        ------\n        ZMQError\n            for any of the reasons zmq_msg_recv might fail.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_25recv(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_v_flags;
+  PyObject *__pyx_v_copy = 0;
+  PyObject *__pyx_v_track = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("recv (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__flags,&__pyx_n_s__copy,&__pyx_n_s__track,0};
+    PyObject* values[3] = {0,0,0};
+    values[1] = __pyx_k_24;
+    values[2] = __pyx_k_25;
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__flags);
+          if (value) { values[0] = value; kw_args--; }
+        }
+        case  1:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__copy);
+          if (value) { values[1] = value; kw_args--; }
+        }
+        case  2:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__track);
+          if (value) { values[2] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "recv") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    if (values[0]) {
+      __pyx_v_flags = __Pyx_PyInt_AsInt(values[0]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    } else {
+      __pyx_v_flags = ((int)0);
+    }
+    __pyx_v_copy = values[1];
+    __pyx_v_track = values[2];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("recv", 0, 0, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.recv", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_24recv(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), __pyx_v_flags, __pyx_v_copy, __pyx_v_track);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pyx":587
+ *             return _send_frame(self.handle, msg, flags)
+ * 
+ *     cpdef object recv(self, int flags=0, copy=True, track=False):             # <<<<<<<<<<<<<<
+ *         """s.recv(flags=0, copy=True, track=False)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_24recv(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, int __pyx_v_flags, PyObject *__pyx_v_copy, PyObject *__pyx_v_track) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("recv", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2.__pyx_n = 3;
+  __pyx_t_2.flags = __pyx_v_flags;
+  __pyx_t_2.copy = __pyx_v_copy;
+  __pyx_t_2.track = __pyx_v_track;
+  __pyx_t_1 = ((struct __pyx_vtabstruct_3zmq_4core_6socket_Socket *)__pyx_v_self->__pyx_vtab)->recv(__pyx_v_self, 1, &__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.recv", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_11socket_type_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_11socket_type_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_11socket_type___get__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pxd":38
+ *     cdef object __weakref__     # enable weakref
+ *     cdef void *handle           # The C handle for the underlying zmq object.
+ *     cdef public int socket_type # The 0MQ socket type - REQ,REP, etc.             # <<<<<<<<<<<<<<
+ *     # Hold on to a reference to the context to make sure it is not garbage
+ *     # collected until the socket it done with it.
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_11socket_type___get__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyInt_FromLong(__pyx_v_self->socket_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 38; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.socket.Socket.socket_type.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_6socket_6Socket_11socket_type_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
+static int __pyx_pw_3zmq_4core_6socket_6Socket_11socket_type_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_11socket_type_2__set__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), ((PyObject *)__pyx_v_value));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_6socket_6Socket_11socket_type_2__set__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__set__", 0);
+  __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_v_value); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 38; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_self->socket_type = __pyx_t_1;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.socket_type.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_7context_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_7context_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_7context___get__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pxd":41
+ *     # Hold on to a reference to the context to make sure it is not garbage
+ *     # collected until the socket it done with it.
+ *     cdef public Context context # The zmq Context object that owns this.             # <<<<<<<<<<<<<<
+ *     cdef public bint _closed    # bool property for a closed socket.
+ *     cdef int _pid               # the pid of the process which created me (for fork safety)
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_7context___get__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_self->context));
+  __pyx_r = ((PyObject *)__pyx_v_self->context);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_6socket_6Socket_7context_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
+static int __pyx_pw_3zmq_4core_6socket_6Socket_7context_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_7context_2__set__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), ((PyObject *)__pyx_v_value));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_6socket_6Socket_7context_2__set__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__set__", 0);
+  if (!(likely(((__pyx_v_value) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_value, __pyx_ptype_3zmq_4core_7context_Context))))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_INCREF(__pyx_v_value);
+  __Pyx_GIVEREF(__pyx_v_value);
+  __Pyx_GOTREF(__pyx_v_self->context);
+  __Pyx_DECREF(((PyObject *)__pyx_v_self->context));
+  __pyx_v_self->context = ((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_value);
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket.context.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_6socket_6Socket_7context_5__del__(PyObject *__pyx_v_self); /*proto*/
+static int __pyx_pw_3zmq_4core_6socket_6Socket_7context_5__del__(PyObject *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_7context_4__del__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_6socket_6Socket_7context_4__del__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__", 0);
+  __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(Py_None);
+  __Pyx_GOTREF(__pyx_v_self->context);
+  __Pyx_DECREF(((PyObject *)__pyx_v_self->context));
+  __pyx_v_self->context = ((struct __pyx_obj_3zmq_4core_7context_Context *)Py_None);
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_7_closed_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_6socket_6Socket_7_closed_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_7_closed___get__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/socket.pxd":42
+ *     # collected until the socket it done with it.
+ *     cdef public Context context # The zmq Context object that owns this.
+ *     cdef public bint _closed    # bool property for a closed socket.             # <<<<<<<<<<<<<<
+ *     cdef int _pid               # the pid of the process which created me (for fork safety)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_6socket_6Socket_7_closed___get__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->_closed); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.socket.Socket._closed.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_6socket_6Socket_7_closed_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
+static int __pyx_pw_3zmq_4core_6socket_6Socket_7_closed_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_6socket_6Socket_7_closed_2__set__(((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_self), ((PyObject *)__pyx_v_value));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_6socket_6Socket_7_closed_2__set__(struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__set__", 0);
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_self->_closed = __pyx_t_1;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("zmq.core.socket.Socket._closed.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/checkrc.pxd":5
+ * from libzmq cimport zmq_errno, ZMQ_ETERM
+ * 
+ * cdef inline int _check_rc(int rc) except -1:             # <<<<<<<<<<<<<<
+ *     """internal utility for checking zmq return condition
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int __pyx_v_rc) {
+  int __pyx_v_errno;
+  PyObject *__pyx_v_Again = NULL;
+  PyObject *__pyx_v_ContextTerminated = NULL;
+  PyObject *__pyx_v_ZMQError = NULL;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_check_rc", 0);
+
+  /* "zmq/core/checkrc.pxd":10
+ *     and raising the appropriate Exception class
+ *     """
+ *     cdef int errno = zmq_errno()             # <<<<<<<<<<<<<<
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ */
+  __pyx_v_errno = zmq_errno();
+
+  /* "zmq/core/checkrc.pxd":11
+ *     """
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()             # <<<<<<<<<<<<<<
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ */
+  __pyx_t_1 = PyErr_CheckSignals(); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/checkrc.pxd":12
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()
+ *     if rc < 0:             # <<<<<<<<<<<<<<
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ */
+  __pyx_t_2 = (__pyx_v_rc < 0);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+    switch (__pyx_v_errno) {
+
+      /* "zmq/core/checkrc.pxd":13
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ *         if errno == EAGAIN:             # <<<<<<<<<<<<<<
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ */
+      case EAGAIN:
+
+      /* "zmq/core/checkrc.pxd":14
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again             # <<<<<<<<<<<<<<
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__Again));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__Again));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Again));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_26), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__Again); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_Again = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":15
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ *             raise Again(errno)             # <<<<<<<<<<<<<<
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_Again, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+
+      /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+      case ETERM:
+
+      /* "zmq/core/checkrc.pxd":17
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated             # <<<<<<<<<<<<<<
+ *             raise ContextTerminated(errno)
+ *         else:
+ */
+      __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      PyList_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_n_s__ContextTerminated));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      __pyx_t_3 = __Pyx_Import(((PyObject *)__pyx_n_s_26), ((PyObject *)__pyx_t_4), -1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__ContextTerminated); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_4);
+      __pyx_v_ContextTerminated = __pyx_t_4;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+      /* "zmq/core/checkrc.pxd":18
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)             # <<<<<<<<<<<<<<
+ *         else:
+ *             from zmq.error import ZMQError
+ */
+      __pyx_t_3 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_3);
+      __pyx_t_3 = 0;
+      __pyx_t_3 = PyObject_Call(__pyx_v_ContextTerminated, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+      default:
+
+      /* "zmq/core/checkrc.pxd":20
+ *             raise ContextTerminated(errno)
+ *         else:
+ *             from zmq.error import ZMQError             # <<<<<<<<<<<<<<
+ *             raise ZMQError(errno)
+ *         # return -1
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQError));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__ZMQError));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQError));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_26), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__ZMQError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_ZMQError = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":21
+ *         else:
+ *             from zmq.error import ZMQError
+ *             raise ZMQError(errno)             # <<<<<<<<<<<<<<
+ *         # return -1
+ *     return 0
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_ZMQError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+    }
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/checkrc.pxd":23
+ *             raise ZMQError(errno)
+ *         # return -1
+ *     return 0             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = 0;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.checkrc._check_rc", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_Again);
+  __Pyx_XDECREF(__pyx_v_ContextTerminated);
+  __Pyx_XDECREF(__pyx_v_ZMQError);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "message.pxd":57
+ * 
+ * 
+ * cdef inline object copy_zmq_msg_bytes(zmq_msg_t *zmq_msg):             # <<<<<<<<<<<<<<
+ *     """ Copy the data from a zmq_msg_t """
+ *     cdef char *data_c = NULL
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_7message_copy_zmq_msg_bytes(zmq_msg_t *__pyx_v_zmq_msg) {
+  char *__pyx_v_data_c;
+  Py_ssize_t __pyx_v_data_len_c;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("copy_zmq_msg_bytes", 0);
+
+  /* "message.pxd":59
+ * cdef inline object copy_zmq_msg_bytes(zmq_msg_t *zmq_msg):
+ *     """ Copy the data from a zmq_msg_t """
+ *     cdef char *data_c = NULL             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t data_len_c
+ *     with nogil:
+ */
+  __pyx_v_data_c = NULL;
+
+  /* "message.pxd":61
+ *     cdef char *data_c = NULL
+ *     cdef Py_ssize_t data_len_c
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         data_c = <char *>zmq_msg_data(zmq_msg)
+ *         data_len_c = zmq_msg_size(zmq_msg)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "message.pxd":62
+ *     cdef Py_ssize_t data_len_c
+ *     with nogil:
+ *         data_c = <char *>zmq_msg_data(zmq_msg)             # <<<<<<<<<<<<<<
+ *         data_len_c = zmq_msg_size(zmq_msg)
+ *     return PyBytes_FromStringAndSize(data_c, data_len_c)
+ */
+        __pyx_v_data_c = ((char *)zmq_msg_data(__pyx_v_zmq_msg));
+
+        /* "message.pxd":63
+ *     with nogil:
+ *         data_c = <char *>zmq_msg_data(zmq_msg)
+ *         data_len_c = zmq_msg_size(zmq_msg)             # <<<<<<<<<<<<<<
+ *     return PyBytes_FromStringAndSize(data_c, data_len_c)
+ * 
+ */
+        __pyx_v_data_len_c = zmq_msg_size(__pyx_v_zmq_msg);
+      }
+
+      /* "message.pxd":61
+ *     cdef char *data_c = NULL
+ *     cdef Py_ssize_t data_len_c
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         data_c = <char *>zmq_msg_data(zmq_msg)
+ *         data_len_c = zmq_msg_size(zmq_msg)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "message.pxd":64
+ *         data_c = <char *>zmq_msg_data(zmq_msg)
+ *         data_len_c = zmq_msg_size(zmq_msg)
+ *     return PyBytes_FromStringAndSize(data_c, data_len_c)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = ((PyObject *)PyBytes_FromStringAndSize(__pyx_v_data_c, __pyx_v_data_len_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.message.copy_zmq_msg_bytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":88
+ * 
+ * 
+ * cdef inline int memoryview_available():             # <<<<<<<<<<<<<<
+ *     return PY_MAJOR_VERSION >= 3 or (PY_MAJOR_VERSION >=2 and PY_MINOR_VERSION >= 7)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7buffers_memoryview_available(void) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  int __pyx_t_4;
+  __Pyx_RefNannySetupContext("memoryview_available", 0);
+
+  /* "buffers.pxd":89
+ * 
+ * cdef inline int memoryview_available():
+ *     return PY_MAJOR_VERSION >= 3 or (PY_MAJOR_VERSION >=2 and PY_MINOR_VERSION >= 7)             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline int oldstyle_available():
+ */
+  __pyx_t_1 = (PY_MAJOR_VERSION >= 3);
+  if (!__pyx_t_1) {
+    __pyx_t_2 = (PY_MAJOR_VERSION >= 2);
+    if (__pyx_t_2) {
+      __pyx_t_3 = (PY_MINOR_VERSION >= 7);
+      __pyx_t_4 = __pyx_t_3;
+    } else {
+      __pyx_t_4 = __pyx_t_2;
+    }
+    __pyx_t_2 = __pyx_t_4;
+  } else {
+    __pyx_t_2 = __pyx_t_1;
+  }
+  __pyx_r = __pyx_t_2;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":91
+ *     return PY_MAJOR_VERSION >= 3 or (PY_MAJOR_VERSION >=2 and PY_MINOR_VERSION >= 7)
+ * 
+ * cdef inline int oldstyle_available():             # <<<<<<<<<<<<<<
+ *     return PY_MAJOR_VERSION < 3
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7buffers_oldstyle_available(void) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("oldstyle_available", 0);
+
+  /* "buffers.pxd":92
+ * 
+ * cdef inline int oldstyle_available():
+ *     return PY_MAJOR_VERSION < 3             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = (PY_MAJOR_VERSION < 3);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":95
+ * 
+ * 
+ * cdef inline int check_buffer(object ob):             # <<<<<<<<<<<<<<
+ *     """Version independent check for whether an object is a buffer.
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7buffers_check_buffer(PyObject *__pyx_v_ob) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  long __pyx_t_2;
+  __Pyx_RefNannySetupContext("check_buffer", 0);
+
+  /* "buffers.pxd":107
+ *     int : 0 if no buffer interface, 3 if newstyle buffer interface, 2 if oldstyle.
+ *     """
+ *     if PyObject_CheckBuffer(ob):             # <<<<<<<<<<<<<<
+ *         return 3
+ *     if oldstyle_available():
+ */
+  __pyx_t_1 = PyObject_CheckBuffer(__pyx_v_ob);
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":108
+ *     """
+ *     if PyObject_CheckBuffer(ob):
+ *         return 3             # <<<<<<<<<<<<<<
+ *     if oldstyle_available():
+ *         return PyObject_CheckReadBuffer(ob) and 2
+ */
+    __pyx_r = 3;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "buffers.pxd":109
+ *     if PyObject_CheckBuffer(ob):
+ *         return 3
+ *     if oldstyle_available():             # <<<<<<<<<<<<<<
+ *         return PyObject_CheckReadBuffer(ob) and 2
+ *     return 0
+ */
+  __pyx_t_1 = __pyx_f_7buffers_oldstyle_available();
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":110
+ *         return 3
+ *     if oldstyle_available():
+ *         return PyObject_CheckReadBuffer(ob) and 2             # <<<<<<<<<<<<<<
+ *     return 0
+ * 
+ */
+    __pyx_t_1 = PyObject_CheckReadBuffer(__pyx_v_ob);
+    if (__pyx_t_1) {
+      __pyx_t_2 = 2;
+    } else {
+      __pyx_t_2 = __pyx_t_1;
+    }
+    __pyx_r = __pyx_t_2;
+    goto __pyx_L0;
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "buffers.pxd":111
+ *     if oldstyle_available():
+ *         return PyObject_CheckReadBuffer(ob) and 2
+ *     return 0             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = 0;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":114
+ * 
+ * 
+ * cdef inline object asbuffer(object ob, int writable, int format,             # <<<<<<<<<<<<<<
+ *                             void **base, Py_ssize_t *size,
+ *                             Py_ssize_t *itemsize):
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer(PyObject *__pyx_v_ob, int __pyx_v_writable, int __pyx_v_format, void **__pyx_v_base, Py_ssize_t *__pyx_v_size, Py_ssize_t *__pyx_v_itemsize) {
+  void *__pyx_v_bptr;
+  Py_ssize_t __pyx_v_blen;
+  Py_ssize_t __pyx_v_bitemlen;
+  Py_buffer __pyx_v_view;
+  int __pyx_v_flags;
+  int __pyx_v_mode;
+  PyObject *__pyx_v_bfmt = NULL;
+  PyObject *__pyx_v_dtype = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  void *__pyx_t_5;
+  Py_ssize_t __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  PyObject *__pyx_t_13 = NULL;
+  PyObject *__pyx_t_14 = NULL;
+  PyObject *__pyx_t_15 = NULL;
+  PyObject *__pyx_t_16 = NULL;
+  int __pyx_t_17;
+  int __pyx_t_18;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("asbuffer", 0);
+
+  /* "buffers.pxd":141
+ *     """
+ * 
+ *     cdef void *bptr = NULL             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t blen = 0, bitemlen = 0
+ *     cdef Py_buffer view
+ */
+  __pyx_v_bptr = NULL;
+
+  /* "buffers.pxd":142
+ * 
+ *     cdef void *bptr = NULL
+ *     cdef Py_ssize_t blen = 0, bitemlen = 0             # <<<<<<<<<<<<<<
+ *     cdef Py_buffer view
+ *     cdef int flags = PyBUF_SIMPLE
+ */
+  __pyx_v_blen = 0;
+  __pyx_v_bitemlen = 0;
+
+  /* "buffers.pxd":144
+ *     cdef Py_ssize_t blen = 0, bitemlen = 0
+ *     cdef Py_buffer view
+ *     cdef int flags = PyBUF_SIMPLE             # <<<<<<<<<<<<<<
+ *     cdef int mode = 0
+ * 
+ */
+  __pyx_v_flags = PyBUF_SIMPLE;
+
+  /* "buffers.pxd":145
+ *     cdef Py_buffer view
+ *     cdef int flags = PyBUF_SIMPLE
+ *     cdef int mode = 0             # <<<<<<<<<<<<<<
+ * 
+ *     bfmt = None
+ */
+  __pyx_v_mode = 0;
+
+  /* "buffers.pxd":147
+ *     cdef int mode = 0
+ * 
+ *     bfmt = None             # <<<<<<<<<<<<<<
+ * 
+ *     mode = check_buffer(ob)
+ */
+  __Pyx_INCREF(Py_None);
+  __pyx_v_bfmt = Py_None;
+
+  /* "buffers.pxd":149
+ *     bfmt = None
+ * 
+ *     mode = check_buffer(ob)             # <<<<<<<<<<<<<<
+ *     if mode == 0:
+ *         raise TypeError("%r does not provide a buffer interface."%ob)
+ */
+  __pyx_v_mode = __pyx_f_7buffers_check_buffer(__pyx_v_ob);
+
+  /* "buffers.pxd":150
+ * 
+ *     mode = check_buffer(ob)
+ *     if mode == 0:             # <<<<<<<<<<<<<<
+ *         raise TypeError("%r does not provide a buffer interface."%ob)
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_mode == 0);
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":151
+ *     mode = check_buffer(ob)
+ *     if mode == 0:
+ *         raise TypeError("%r does not provide a buffer interface."%ob)             # <<<<<<<<<<<<<<
+ * 
+ *     if mode == 3:
+ */
+    __pyx_t_2 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_27), __pyx_v_ob); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_2));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_2));
+    __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[4]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "buffers.pxd":153
+ *         raise TypeError("%r does not provide a buffer interface."%ob)
+ * 
+ *     if mode == 3:             # <<<<<<<<<<<<<<
+ *         flags = PyBUF_ANY_CONTIGUOUS
+ *         if writable:
+ */
+  __pyx_t_1 = (__pyx_v_mode == 3);
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":154
+ * 
+ *     if mode == 3:
+ *         flags = PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
+ *         if writable:
+ *             flags |= PyBUF_WRITABLE
+ */
+    __pyx_v_flags = PyBUF_ANY_CONTIGUOUS;
+
+    /* "buffers.pxd":155
+ *     if mode == 3:
+ *         flags = PyBUF_ANY_CONTIGUOUS
+ *         if writable:             # <<<<<<<<<<<<<<
+ *             flags |= PyBUF_WRITABLE
+ *         if format:
+ */
+    if (__pyx_v_writable) {
+
+      /* "buffers.pxd":156
+ *         flags = PyBUF_ANY_CONTIGUOUS
+ *         if writable:
+ *             flags |= PyBUF_WRITABLE             # <<<<<<<<<<<<<<
+ *         if format:
+ *             flags |= PyBUF_FORMAT
+ */
+      __pyx_v_flags = (__pyx_v_flags | PyBUF_WRITABLE);
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "buffers.pxd":157
+ *         if writable:
+ *             flags |= PyBUF_WRITABLE
+ *         if format:             # <<<<<<<<<<<<<<
+ *             flags |= PyBUF_FORMAT
+ *         PyObject_GetBuffer(ob, &view, flags)
+ */
+    if (__pyx_v_format) {
+
+      /* "buffers.pxd":158
+ *             flags |= PyBUF_WRITABLE
+ *         if format:
+ *             flags |= PyBUF_FORMAT             # <<<<<<<<<<<<<<
+ *         PyObject_GetBuffer(ob, &view, flags)
+ *         bptr = view.buf
+ */
+      __pyx_v_flags = (__pyx_v_flags | PyBUF_FORMAT);
+      goto __pyx_L6;
+    }
+    __pyx_L6:;
+
+    /* "buffers.pxd":159
+ *         if format:
+ *             flags |= PyBUF_FORMAT
+ *         PyObject_GetBuffer(ob, &view, flags)             # <<<<<<<<<<<<<<
+ *         bptr = view.buf
+ *         blen = view.len
+ */
+    __pyx_t_4 = PyObject_GetBuffer(__pyx_v_ob, (&__pyx_v_view), __pyx_v_flags); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "buffers.pxd":160
+ *             flags |= PyBUF_FORMAT
+ *         PyObject_GetBuffer(ob, &view, flags)
+ *         bptr = view.buf             # <<<<<<<<<<<<<<
+ *         blen = view.len
+ *         if format:
+ */
+    __pyx_t_5 = __pyx_v_view.buf;
+    __pyx_v_bptr = __pyx_t_5;
+
+    /* "buffers.pxd":161
+ *         PyObject_GetBuffer(ob, &view, flags)
+ *         bptr = view.buf
+ *         blen = view.len             # <<<<<<<<<<<<<<
+ *         if format:
+ *             if view.format != NULL:
+ */
+    __pyx_t_6 = __pyx_v_view.len;
+    __pyx_v_blen = __pyx_t_6;
+
+    /* "buffers.pxd":162
+ *         bptr = view.buf
+ *         blen = view.len
+ *         if format:             # <<<<<<<<<<<<<<
+ *             if view.format != NULL:
+ *                 bfmt = view.format
+ */
+    if (__pyx_v_format) {
+
+      /* "buffers.pxd":163
+ *         blen = view.len
+ *         if format:
+ *             if view.format != NULL:             # <<<<<<<<<<<<<<
+ *                 bfmt = view.format
+ *                 bitemlen = view.itemsize
+ */
+      __pyx_t_1 = (__pyx_v_view.format != NULL);
+      if (__pyx_t_1) {
+
+        /* "buffers.pxd":164
+ *         if format:
+ *             if view.format != NULL:
+ *                 bfmt = view.format             # <<<<<<<<<<<<<<
+ *                 bitemlen = view.itemsize
+ *         PyBuffer_Release(&view)
+ */
+        __pyx_t_2 = __Pyx_PyBytes_FromString(__pyx_v_view.format); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+        __Pyx_DECREF(__pyx_v_bfmt);
+        __pyx_v_bfmt = ((PyObject *)__pyx_t_2);
+        __pyx_t_2 = 0;
+
+        /* "buffers.pxd":165
+ *             if view.format != NULL:
+ *                 bfmt = view.format
+ *                 bitemlen = view.itemsize             # <<<<<<<<<<<<<<
+ *         PyBuffer_Release(&view)
+ *     else: # oldstyle
+ */
+        __pyx_t_6 = __pyx_v_view.itemsize;
+        __pyx_v_bitemlen = __pyx_t_6;
+        goto __pyx_L8;
+      }
+      __pyx_L8:;
+      goto __pyx_L7;
+    }
+    __pyx_L7:;
+
+    /* "buffers.pxd":166
+ *                 bfmt = view.format
+ *                 bitemlen = view.itemsize
+ *         PyBuffer_Release(&view)             # <<<<<<<<<<<<<<
+ *     else: # oldstyle
+ *         if writable:
+ */
+    PyBuffer_Release((&__pyx_v_view));
+    goto __pyx_L4;
+  }
+  /*else*/ {
+
+    /* "buffers.pxd":168
+ *         PyBuffer_Release(&view)
+ *     else: # oldstyle
+ *         if writable:             # <<<<<<<<<<<<<<
+ *             PyObject_AsWriteBuffer(ob, &bptr, &blen)
+ *         else:
+ */
+    if (__pyx_v_writable) {
+
+      /* "buffers.pxd":169
+ *     else: # oldstyle
+ *         if writable:
+ *             PyObject_AsWriteBuffer(ob, &bptr, &blen)             # <<<<<<<<<<<<<<
+ *         else:
+ *             PyObject_AsReadBuffer(ob, <const_void **>&bptr, &blen)
+ */
+      __pyx_t_4 = PyObject_AsWriteBuffer(__pyx_v_ob, (&__pyx_v_bptr), (&__pyx_v_blen)); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L9;
+    }
+    /*else*/ {
+
+      /* "buffers.pxd":171
+ *             PyObject_AsWriteBuffer(ob, &bptr, &blen)
+ *         else:
+ *             PyObject_AsReadBuffer(ob, <const_void **>&bptr, &blen)             # <<<<<<<<<<<<<<
+ *         if format:
+ *             try: # numpy.ndarray
+ */
+      __pyx_t_4 = PyObject_AsReadBuffer(__pyx_v_ob, ((const void **)(&__pyx_v_bptr)), (&__pyx_v_blen)); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    __pyx_L9:;
+
+    /* "buffers.pxd":172
+ *         else:
+ *             PyObject_AsReadBuffer(ob, <const_void **>&bptr, &blen)
+ *         if format:             # <<<<<<<<<<<<<<
+ *             try: # numpy.ndarray
+ *                 dtype = ob.dtype
+ */
+    if (__pyx_v_format) {
+
+      /* "buffers.pxd":173
+ *             PyObject_AsReadBuffer(ob, <const_void **>&bptr, &blen)
+ *         if format:
+ *             try: # numpy.ndarray             # <<<<<<<<<<<<<<
+ *                 dtype = ob.dtype
+ *                 bfmt = dtype.char
+ */
+      {
+        __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
+        __Pyx_XGOTREF(__pyx_t_7);
+        __Pyx_XGOTREF(__pyx_t_8);
+        __Pyx_XGOTREF(__pyx_t_9);
+        /*try:*/ {
+
+          /* "buffers.pxd":174
+ *         if format:
+ *             try: # numpy.ndarray
+ *                 dtype = ob.dtype             # <<<<<<<<<<<<<<
+ *                 bfmt = dtype.char
+ *                 bitemlen = dtype.itemsize
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_ob, __pyx_n_s__dtype); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L11_error;}
+          __Pyx_GOTREF(__pyx_t_2);
+          __pyx_v_dtype = __pyx_t_2;
+          __pyx_t_2 = 0;
+
+          /* "buffers.pxd":175
+ *             try: # numpy.ndarray
+ *                 dtype = ob.dtype
+ *                 bfmt = dtype.char             # <<<<<<<<<<<<<<
+ *                 bitemlen = dtype.itemsize
+ *             except AttributeError:
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_dtype, __pyx_n_s__char); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L11_error;}
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_v_bfmt);
+          __pyx_v_bfmt = __pyx_t_2;
+          __pyx_t_2 = 0;
+
+          /* "buffers.pxd":176
+ *                 dtype = ob.dtype
+ *                 bfmt = dtype.char
+ *                 bitemlen = dtype.itemsize             # <<<<<<<<<<<<<<
+ *             except AttributeError:
+ *                 try: # array.array
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_dtype, __pyx_n_s__itemsize); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L11_error;}
+          __Pyx_GOTREF(__pyx_t_2);
+          __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_t_2); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L11_error;}
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __pyx_v_bitemlen = __pyx_t_6;
+        }
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
+        goto __pyx_L18_try_end;
+        __pyx_L11_error:;
+        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+        /* "buffers.pxd":177
+ *                 bfmt = dtype.char
+ *                 bitemlen = dtype.itemsize
+ *             except AttributeError:             # <<<<<<<<<<<<<<
+ *                 try: # array.array
+ *                     bfmt = ob.typecode
+ */
+        __pyx_t_4 = PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
+        if (__pyx_t_4) {
+          __Pyx_AddTraceback("buffers.asbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+          if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_3, &__pyx_t_10) < 0) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L13_except_error;}
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_GOTREF(__pyx_t_3);
+          __Pyx_GOTREF(__pyx_t_10);
+
+          /* "buffers.pxd":178
+ *                 bitemlen = dtype.itemsize
+ *             except AttributeError:
+ *                 try: # array.array             # <<<<<<<<<<<<<<
+ *                     bfmt = ob.typecode
+ *                     bitemlen = ob.itemsize
+ */
+          {
+            __Pyx_ExceptionSave(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
+            __Pyx_XGOTREF(__pyx_t_11);
+            __Pyx_XGOTREF(__pyx_t_12);
+            __Pyx_XGOTREF(__pyx_t_13);
+            /*try:*/ {
+
+              /* "buffers.pxd":179
+ *             except AttributeError:
+ *                 try: # array.array
+ *                     bfmt = ob.typecode             # <<<<<<<<<<<<<<
+ *                     bitemlen = ob.itemsize
+ *                 except AttributeError:
+ */
+              __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_v_ob, __pyx_n_s__typecode); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
+              __Pyx_GOTREF(__pyx_t_14);
+              __Pyx_DECREF(__pyx_v_bfmt);
+              __pyx_v_bfmt = __pyx_t_14;
+              __pyx_t_14 = 0;
+
+              /* "buffers.pxd":180
+ *                 try: # array.array
+ *                     bfmt = ob.typecode
+ *                     bitemlen = ob.itemsize             # <<<<<<<<<<<<<<
+ *                 except AttributeError:
+ *                     if isinstance(ob, bytes):
+ */
+              __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_v_ob, __pyx_n_s__itemsize); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
+              __Pyx_GOTREF(__pyx_t_14);
+              __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_t_14); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
+              __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+              __pyx_v_bitemlen = __pyx_t_6;
+            }
+            __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+            __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+            __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
+            goto __pyx_L28_try_end;
+            __pyx_L21_error:;
+            __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
+
+            /* "buffers.pxd":181
+ *                     bfmt = ob.typecode
+ *                     bitemlen = ob.itemsize
+ *                 except AttributeError:             # <<<<<<<<<<<<<<
+ *                     if isinstance(ob, bytes):
+ *                         bfmt = b"B"
+ */
+            __pyx_t_4 = PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
+            if (__pyx_t_4) {
+              __Pyx_AddTraceback("buffers.asbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+              if (__Pyx_GetException(&__pyx_t_14, &__pyx_t_15, &__pyx_t_16) < 0) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L23_except_error;}
+              __Pyx_GOTREF(__pyx_t_14);
+              __Pyx_GOTREF(__pyx_t_15);
+              __Pyx_GOTREF(__pyx_t_16);
+
+              /* "buffers.pxd":182
+ *                     bitemlen = ob.itemsize
+ *                 except AttributeError:
+ *                     if isinstance(ob, bytes):             # <<<<<<<<<<<<<<
+ *                         bfmt = b"B"
+ *                         bitemlen = 1
+ */
+              __pyx_t_1 = PyBytes_Check(__pyx_v_ob); 
+              if (__pyx_t_1) {
+
+                /* "buffers.pxd":183
+ *                 except AttributeError:
+ *                     if isinstance(ob, bytes):
+ *                         bfmt = b"B"             # <<<<<<<<<<<<<<
+ *                         bitemlen = 1
+ *                     else:
+ */
+                __Pyx_INCREF(((PyObject *)__pyx_n_b__B));
+                __Pyx_DECREF(__pyx_v_bfmt);
+                __pyx_v_bfmt = ((PyObject *)__pyx_n_b__B);
+
+                /* "buffers.pxd":184
+ *                     if isinstance(ob, bytes):
+ *                         bfmt = b"B"
+ *                         bitemlen = 1             # <<<<<<<<<<<<<<
+ *                     else:
+ *                         # nothing found
+ */
+                __pyx_v_bitemlen = 1;
+                goto __pyx_L31;
+              }
+              /*else*/ {
+
+                /* "buffers.pxd":187
+ *                     else:
+ *                         # nothing found
+ *                         bfmt = None             # <<<<<<<<<<<<<<
+ *                         bitemlen = 0
+ *     if base: base[0] = <void *>bptr
+ */
+                __Pyx_INCREF(Py_None);
+                __Pyx_DECREF(__pyx_v_bfmt);
+                __pyx_v_bfmt = Py_None;
+
+                /* "buffers.pxd":188
+ *                         # nothing found
+ *                         bfmt = None
+ *                         bitemlen = 0             # <<<<<<<<<<<<<<
+ *     if base: base[0] = <void *>bptr
+ *     if size: size[0] = <Py_ssize_t>blen
+ */
+                __pyx_v_bitemlen = 0;
+              }
+              __pyx_L31:;
+              __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+              __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+              __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+              goto __pyx_L22_exception_handled;
+            }
+            __pyx_L23_except_error:;
+            __Pyx_XGIVEREF(__pyx_t_11);
+            __Pyx_XGIVEREF(__pyx_t_12);
+            __Pyx_XGIVEREF(__pyx_t_13);
+            __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);
+            goto __pyx_L13_except_error;
+            __pyx_L22_exception_handled:;
+            __Pyx_XGIVEREF(__pyx_t_11);
+            __Pyx_XGIVEREF(__pyx_t_12);
+            __Pyx_XGIVEREF(__pyx_t_13);
+            __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);
+            __pyx_L28_try_end:;
+          }
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+          goto __pyx_L12_exception_handled;
+        }
+        __pyx_L13_except_error:;
+        __Pyx_XGIVEREF(__pyx_t_7);
+        __Pyx_XGIVEREF(__pyx_t_8);
+        __Pyx_XGIVEREF(__pyx_t_9);
+        __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+        goto __pyx_L1_error;
+        __pyx_L12_exception_handled:;
+        __Pyx_XGIVEREF(__pyx_t_7);
+        __Pyx_XGIVEREF(__pyx_t_8);
+        __Pyx_XGIVEREF(__pyx_t_9);
+        __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+        __pyx_L18_try_end:;
+      }
+      goto __pyx_L10;
+    }
+    __pyx_L10:;
+  }
+  __pyx_L4:;
+
+  /* "buffers.pxd":189
+ *                         bfmt = None
+ *                         bitemlen = 0
+ *     if base: base[0] = <void *>bptr             # <<<<<<<<<<<<<<
+ *     if size: size[0] = <Py_ssize_t>blen
+ *     if itemsize: itemsize[0] = <Py_ssize_t>bitemlen
+ */
+  __pyx_t_1 = (__pyx_v_base != 0);
+  if (__pyx_t_1) {
+    (__pyx_v_base[0]) = ((void *)__pyx_v_bptr);
+    goto __pyx_L32;
+  }
+  __pyx_L32:;
+
+  /* "buffers.pxd":190
+ *                         bitemlen = 0
+ *     if base: base[0] = <void *>bptr
+ *     if size: size[0] = <Py_ssize_t>blen             # <<<<<<<<<<<<<<
+ *     if itemsize: itemsize[0] = <Py_ssize_t>bitemlen
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_size != 0);
+  if (__pyx_t_1) {
+    (__pyx_v_size[0]) = ((Py_ssize_t)__pyx_v_blen);
+    goto __pyx_L33;
+  }
+  __pyx_L33:;
+
+  /* "buffers.pxd":191
+ *     if base: base[0] = <void *>bptr
+ *     if size: size[0] = <Py_ssize_t>blen
+ *     if itemsize: itemsize[0] = <Py_ssize_t>bitemlen             # <<<<<<<<<<<<<<
+ * 
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:
+ */
+  __pyx_t_1 = (__pyx_v_itemsize != 0);
+  if (__pyx_t_1) {
+    (__pyx_v_itemsize[0]) = ((Py_ssize_t)__pyx_v_bitemlen);
+    goto __pyx_L34;
+  }
+  __pyx_L34:;
+
+  /* "buffers.pxd":193
+ *     if itemsize: itemsize[0] = <Py_ssize_t>bitemlen
+ * 
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:             # <<<<<<<<<<<<<<
+ *         return bfmt.decode('ascii')
+ *     return bfmt
+ */
+  __pyx_t_1 = (PY_MAJOR_VERSION >= 3);
+  if (__pyx_t_1) {
+    __pyx_t_17 = (__pyx_v_bfmt != Py_None);
+    __pyx_t_18 = __pyx_t_17;
+  } else {
+    __pyx_t_18 = __pyx_t_1;
+  }
+  if (__pyx_t_18) {
+
+    /* "buffers.pxd":194
+ * 
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:
+ *         return bfmt.decode('ascii')             # <<<<<<<<<<<<<<
+ *     return bfmt
+ * 
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_v_bfmt, __pyx_n_s__decode); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_10);
+    __pyx_t_3 = PyObject_Call(__pyx_t_10, ((PyObject *)__pyx_k_tuple_28), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L0;
+    goto __pyx_L35;
+  }
+  __pyx_L35:;
+
+  /* "buffers.pxd":195
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:
+ *         return bfmt.decode('ascii')
+ *     return bfmt             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_bfmt);
+  __pyx_r = __pyx_v_bfmt;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_XDECREF(__pyx_t_14);
+  __Pyx_XDECREF(__pyx_t_15);
+  __Pyx_XDECREF(__pyx_t_16);
+  __Pyx_AddTraceback("buffers.asbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_bfmt);
+  __Pyx_XDECREF(__pyx_v_dtype);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":198
+ * 
+ * 
+ * cdef inline object asbuffer_r(object ob, void **base, Py_ssize_t *size):             # <<<<<<<<<<<<<<
+ *     """Wrapper for standard calls to asbuffer with a readonly buffer."""
+ *     asbuffer(ob, 0, 0, base, size, NULL)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer_r(PyObject *__pyx_v_ob, void **__pyx_v_base, Py_ssize_t *__pyx_v_size) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("asbuffer_r", 0);
+
+  /* "buffers.pxd":200
+ * cdef inline object asbuffer_r(object ob, void **base, Py_ssize_t *size):
+ *     """Wrapper for standard calls to asbuffer with a readonly buffer."""
+ *     asbuffer(ob, 0, 0, base, size, NULL)             # <<<<<<<<<<<<<<
+ *     return ob
+ * 
+ */
+  __pyx_t_1 = __pyx_f_7buffers_asbuffer(__pyx_v_ob, 0, 0, __pyx_v_base, __pyx_v_size, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "buffers.pxd":201
+ *     """Wrapper for standard calls to asbuffer with a readonly buffer."""
+ *     asbuffer(ob, 0, 0, base, size, NULL)
+ *     return ob             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_ob);
+  __pyx_r = __pyx_v_ob;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.asbuffer_r", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":204
+ * 
+ * 
+ * cdef inline object asbuffer_w(object ob, void **base, Py_ssize_t *size):             # <<<<<<<<<<<<<<
+ *     """Wrapper for standard calls to asbuffer with a writable buffer."""
+ *     asbuffer(ob, 1, 0, base, size, NULL)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer_w(PyObject *__pyx_v_ob, void **__pyx_v_base, Py_ssize_t *__pyx_v_size) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("asbuffer_w", 0);
+
+  /* "buffers.pxd":206
+ * cdef inline object asbuffer_w(object ob, void **base, Py_ssize_t *size):
+ *     """Wrapper for standard calls to asbuffer with a writable buffer."""
+ *     asbuffer(ob, 1, 0, base, size, NULL)             # <<<<<<<<<<<<<<
+ *     return ob
+ * 
+ */
+  __pyx_t_1 = __pyx_f_7buffers_asbuffer(__pyx_v_ob, 1, 0, __pyx_v_base, __pyx_v_size, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "buffers.pxd":207
+ *     """Wrapper for standard calls to asbuffer with a writable buffer."""
+ *     asbuffer(ob, 1, 0, base, size, NULL)
+ *     return ob             # <<<<<<<<<<<<<<
+ * 
+ * #------------------------------------------------------------------------------
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_ob);
+  __pyx_r = __pyx_v_ob;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.asbuffer_w", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":214
+ * 
+ * 
+ * cdef inline object frombuffer_3(void *ptr, Py_ssize_t s, int readonly):             # <<<<<<<<<<<<<<
+ *     """Python 3 version of frombuffer.
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_3(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s, int __pyx_v_readonly) {
+  Py_buffer __pyx_v_pybuf;
+  Py_ssize_t *__pyx_v_shape;
+  PyObject *__pyx_v_astr = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  Py_ssize_t __pyx_t_1[1];
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer_3", 0);
+
+  /* "buffers.pxd":221
+ *     """
+ *     cdef Py_buffer pybuf
+ *     cdef Py_ssize_t *shape = [s]             # <<<<<<<<<<<<<<
+ *     cdef str astr=""
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)
+ */
+  __pyx_t_1[0] = __pyx_v_s;
+  __pyx_v_shape = __pyx_t_1;
+
+  /* "buffers.pxd":222
+ *     cdef Py_buffer pybuf
+ *     cdef Py_ssize_t *shape = [s]
+ *     cdef str astr=""             # <<<<<<<<<<<<<<
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)
+ *     pybuf.format = "B"
+ */
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_29));
+  __pyx_v_astr = __pyx_kp_s_29;
+
+  /* "buffers.pxd":223
+ *     cdef Py_ssize_t *shape = [s]
+ *     cdef str astr=""
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)             # <<<<<<<<<<<<<<
+ *     pybuf.format = "B"
+ *     pybuf.shape = shape
+ */
+  __pyx_t_2 = PyBuffer_FillInfo((&__pyx_v_pybuf), ((PyObject *)__pyx_v_astr), __pyx_v_ptr, __pyx_v_s, __pyx_v_readonly, PyBUF_SIMPLE); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "buffers.pxd":224
+ *     cdef str astr=""
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)
+ *     pybuf.format = "B"             # <<<<<<<<<<<<<<
+ *     pybuf.shape = shape
+ *     return PyMemoryView_FromBuffer(&pybuf)
+ */
+  __pyx_v_pybuf.format = __pyx_k__B;
+
+  /* "buffers.pxd":225
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)
+ *     pybuf.format = "B"
+ *     pybuf.shape = shape             # <<<<<<<<<<<<<<
+ *     return PyMemoryView_FromBuffer(&pybuf)
+ * 
+ */
+  __pyx_v_pybuf.shape = __pyx_v_shape;
+
+  /* "buffers.pxd":226
+ *     pybuf.format = "B"
+ *     pybuf.shape = shape
+ *     return PyMemoryView_FromBuffer(&pybuf)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_3 = PyMemoryView_FromBuffer((&__pyx_v_pybuf)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("buffers.frombuffer_3", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_astr);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":229
+ * 
+ * 
+ * cdef inline object frombuffer_2(void *ptr, Py_ssize_t s, int readonly):             # <<<<<<<<<<<<<<
+ *     """Python 2 version of frombuffer.
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_2(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s, int __pyx_v_readonly) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer_2", 0);
+
+  /* "buffers.pxd":235
+ *     """
+ * 
+ *     if oldstyle_available():             # <<<<<<<<<<<<<<
+ *         if readonly:
+ *             return PyBuffer_FromMemory(ptr, s)
+ */
+  __pyx_t_1 = __pyx_f_7buffers_oldstyle_available();
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":236
+ * 
+ *     if oldstyle_available():
+ *         if readonly:             # <<<<<<<<<<<<<<
+ *             return PyBuffer_FromMemory(ptr, s)
+ *         else:
+ */
+    if (__pyx_v_readonly) {
+
+      /* "buffers.pxd":237
+ *     if oldstyle_available():
+ *         if readonly:
+ *             return PyBuffer_FromMemory(ptr, s)             # <<<<<<<<<<<<<<
+ *         else:
+ *             return PyBuffer_FromReadWriteMemory(ptr, s)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyBuffer_FromMemory(__pyx_v_ptr, __pyx_v_s); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+      goto __pyx_L4;
+    }
+    /*else*/ {
+
+      /* "buffers.pxd":239
+ *             return PyBuffer_FromMemory(ptr, s)
+ *         else:
+ *             return PyBuffer_FromReadWriteMemory(ptr, s)             # <<<<<<<<<<<<<<
+ *     else:
+ *         raise NotImplementedError("Old style buffers not available.")
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyBuffer_FromReadWriteMemory(__pyx_v_ptr, __pyx_v_s); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+    }
+    __pyx_L4:;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "buffers.pxd":241
+ *             return PyBuffer_FromReadWriteMemory(ptr, s)
+ *     else:
+ *         raise NotImplementedError("Old style buffers not available.")             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_NotImplementedError, ((PyObject *)__pyx_k_tuple_31), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[4]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("buffers.frombuffer_2", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":244
+ * 
+ * 
+ * cdef inline object frombuffer(void *ptr, Py_ssize_t s, int readonly):             # <<<<<<<<<<<<<<
+ *     """Create a Python Buffer/View of a C array.
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s, int __pyx_v_readonly) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer", 0);
+
+  /* "buffers.pxd":261
+ *     """
+ *     # oldstyle first priority for now
+ *     if oldstyle_available():             # <<<<<<<<<<<<<<
+ *         return frombuffer_2(ptr, s, readonly)
+ *     else:
+ */
+  __pyx_t_1 = __pyx_f_7buffers_oldstyle_available();
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":262
+ *     # oldstyle first priority for now
+ *     if oldstyle_available():
+ *         return frombuffer_2(ptr, s, readonly)             # <<<<<<<<<<<<<<
+ *     else:
+ *         return frombuffer_3(ptr, s, readonly)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = __pyx_f_7buffers_frombuffer_2(__pyx_v_ptr, __pyx_v_s, __pyx_v_readonly); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "buffers.pxd":264
+ *         return frombuffer_2(ptr, s, readonly)
+ *     else:
+ *         return frombuffer_3(ptr, s, readonly)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = __pyx_f_7buffers_frombuffer_3(__pyx_v_ptr, __pyx_v_s, __pyx_v_readonly); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("buffers.frombuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":267
+ * 
+ * 
+ * cdef inline object frombuffer_r(void *ptr, Py_ssize_t s):             # <<<<<<<<<<<<<<
+ *     """Wrapper for readonly view frombuffer."""
+ *     return frombuffer(ptr, s, 1)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_r(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer_r", 0);
+
+  /* "buffers.pxd":269
+ * cdef inline object frombuffer_r(void *ptr, Py_ssize_t s):
+ *     """Wrapper for readonly view frombuffer."""
+ *     return frombuffer(ptr, s, 1)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_7buffers_frombuffer(__pyx_v_ptr, __pyx_v_s, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.frombuffer_r", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":272
+ * 
+ * 
+ * cdef inline object frombuffer_w(void *ptr, Py_ssize_t s):             # <<<<<<<<<<<<<<
+ *     """Wrapper for writable view frombuffer."""
+ *     return frombuffer(ptr, s, 0)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_w(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer_w", 0);
+
+  /* "buffers.pxd":274
+ * cdef inline object frombuffer_w(void *ptr, Py_ssize_t s):
+ *     """Wrapper for writable view frombuffer."""
+ *     return frombuffer(ptr, s, 0)             # <<<<<<<<<<<<<<
+ * 
+ * #------------------------------------------------------------------------------
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_7buffers_frombuffer(__pyx_v_ptr, __pyx_v_s, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.frombuffer_w", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":281
+ * #------------------------------------------------------------------------------
+ * 
+ * cdef inline object viewfromobject(object obj, int readonly):             # <<<<<<<<<<<<<<
+ *     """Construct a Python Buffer/View object from another Python object.
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject(PyObject *__pyx_v_obj, int __pyx_v_readonly) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("viewfromobject", 0);
+
+  /* "buffers.pxd":297
+ *     Buffer/View of the original object.
+ *     """
+ *     if not memoryview_available():             # <<<<<<<<<<<<<<
+ *         if readonly:
+ *             return PyBuffer_FromObject(obj, 0, Py_END_OF_BUFFER)
+ */
+  __pyx_t_1 = (!__pyx_f_7buffers_memoryview_available());
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":298
+ *     """
+ *     if not memoryview_available():
+ *         if readonly:             # <<<<<<<<<<<<<<
+ *             return PyBuffer_FromObject(obj, 0, Py_END_OF_BUFFER)
+ *         else:
+ */
+    if (__pyx_v_readonly) {
+
+      /* "buffers.pxd":299
+ *     if not memoryview_available():
+ *         if readonly:
+ *             return PyBuffer_FromObject(obj, 0, Py_END_OF_BUFFER)             # <<<<<<<<<<<<<<
+ *         else:
+ *             return PyBuffer_FromReadWriteObject(obj, 0, Py_END_OF_BUFFER)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyBuffer_FromObject(__pyx_v_obj, 0, Py_END_OF_BUFFER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+      goto __pyx_L4;
+    }
+    /*else*/ {
+
+      /* "buffers.pxd":301
+ *             return PyBuffer_FromObject(obj, 0, Py_END_OF_BUFFER)
+ *         else:
+ *             return PyBuffer_FromReadWriteObject(obj, 0, Py_END_OF_BUFFER)             # <<<<<<<<<<<<<<
+ *     else:
+ *         return PyMemoryView_FromObject(obj)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyBuffer_FromReadWriteObject(__pyx_v_obj, 0, Py_END_OF_BUFFER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+    }
+    __pyx_L4:;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "buffers.pxd":303
+ *             return PyBuffer_FromReadWriteObject(obj, 0, Py_END_OF_BUFFER)
+ *     else:
+ *         return PyMemoryView_FromObject(obj)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = PyMemoryView_FromObject(__pyx_v_obj); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("buffers.viewfromobject", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":306
+ * 
+ * 
+ * cdef inline object viewfromobject_r(object obj):             # <<<<<<<<<<<<<<
+ *     """Wrapper for readonly viewfromobject."""
+ *     return viewfromobject(obj, 1)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject_r(PyObject *__pyx_v_obj) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("viewfromobject_r", 0);
+
+  /* "buffers.pxd":308
+ * cdef inline object viewfromobject_r(object obj):
+ *     """Wrapper for readonly viewfromobject."""
+ *     return viewfromobject(obj, 1)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_7buffers_viewfromobject(__pyx_v_obj, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.viewfromobject_r", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":311
+ * 
+ * 
+ * cdef inline object viewfromobject_w(object obj):             # <<<<<<<<<<<<<<
+ *     """Wrapper for writable viewfromobject."""
+ *     return viewfromobject(obj, 0)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject_w(PyObject *__pyx_v_obj) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("viewfromobject_w", 0);
+
+  /* "buffers.pxd":313
+ * cdef inline object viewfromobject_w(object obj):
+ *     """Wrapper for writable viewfromobject."""
+ *     return viewfromobject(obj, 0)             # <<<<<<<<<<<<<<
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_7buffers_viewfromobject(__pyx_v_obj, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.viewfromobject_w", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":104
+ * # Datetime C API initialization function.
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():             # <<<<<<<<<<<<<<
+ *     PyDateTime_IMPORT
+ * 
+ */
+
+static CYTHON_INLINE void __pyx_f_7cpython_8datetime_import_datetime(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("import_datetime", 0);
+
+  /* "cpython/datetime.pxd":105
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():
+ *     PyDateTime_IMPORT             # <<<<<<<<<<<<<<
+ * 
+ * # Create date object using DateTime CAPI factory function.
+ */
+  PyDateTime_IMPORT;
+
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "cpython/datetime.pxd":109
+ * # Create date object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_date_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("date_new", 0);
+
+  /* "cpython/datetime.pxd":110
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create time object using DateTime CAPI factory function
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Date_FromDate(__pyx_v_year, __pyx_v_month, __pyx_v_day, PyDateTimeAPI->DateType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.date_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":114
+ * # Create time object using DateTime CAPI factory function
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_new(int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("time_new", 0);
+
+  /* "cpython/datetime.pxd":115
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create datetime object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Time_FromTime(__pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->TimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.time_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":119
+ * # Create datetime object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day, int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("datetime_new", 0);
+
+  /* "cpython/datetime.pxd":120
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create timedelta object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->DateTime_FromDateAndTime(__pyx_v_year, __pyx_v_month, __pyx_v_day, __pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->DateTimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.datetime_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":124
+ * # Create timedelta object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_timedelta_new(int __pyx_v_days, int __pyx_v_seconds, int __pyx_v_useconds) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("timedelta_new", 0);
+
+  /* "cpython/datetime.pxd":125
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)             # <<<<<<<<<<<<<<
+ * 
+ * # More recognizable getters for date/time/datetime/timedelta.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Delta_FromDelta(__pyx_v_days, __pyx_v_seconds, __pyx_v_useconds, 1, PyDateTimeAPI->DeltaType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.timedelta_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":133
+ * 
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":134
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_Time *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":135
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":137
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get tzinfo of datetime
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":140
+ * 
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":141
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_DateTime *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":142
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":144
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of date
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":147
+ * 
+ * # Get year of date
+ * cdef inline int date_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_year", 0);
+
+  /* "cpython/datetime.pxd":148
+ * # Get year of date
+ * cdef inline int date_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of date
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":151
+ * 
+ * # Get month of date
+ * cdef inline int date_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_month", 0);
+
+  /* "cpython/datetime.pxd":152
+ * # Get month of date
+ * cdef inline int date_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of date
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":155
+ * 
+ * # Get day of date
+ * cdef inline int date_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_day", 0);
+
+  /* "cpython/datetime.pxd":156
+ * # Get day of date
+ * cdef inline int date_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of datetime
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":159
+ * 
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_year", 0);
+
+  /* "cpython/datetime.pxd":160
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of datetime
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":163
+ * 
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_month", 0);
+
+  /* "cpython/datetime.pxd":164
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of datetime
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":167
+ * 
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_day", 0);
+
+  /* "cpython/datetime.pxd":168
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of time
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":171
+ * 
+ * # Get hour of time
+ * cdef inline int time_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_hour", 0);
+
+  /* "cpython/datetime.pxd":172
+ * # Get hour of time
+ * cdef inline int time_hour(object o):
+ *     return PyDateTime_TIME_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":175
+ * 
+ * # Get minute of time
+ * cdef inline int time_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_minute", 0);
+
+  /* "cpython/datetime.pxd":176
+ * # Get minute of time
+ * cdef inline int time_minute(object o):
+ *     return PyDateTime_TIME_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":179
+ * 
+ * # Get second of time
+ * cdef inline int time_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_second", 0);
+
+  /* "cpython/datetime.pxd":180
+ * # Get second of time
+ * cdef inline int time_second(object o):
+ *     return PyDateTime_TIME_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":183
+ * 
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_microsecond", 0);
+
+  /* "cpython/datetime.pxd":184
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of datetime
+ */
+  __pyx_r = PyDateTime_TIME_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":187
+ * 
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_hour", 0);
+
+  /* "cpython/datetime.pxd":188
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):
+ *     return PyDateTime_DATE_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":191
+ * 
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_minute", 0);
+
+  /* "cpython/datetime.pxd":192
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):
+ *     return PyDateTime_DATE_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":195
+ * 
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_second", 0);
+
+  /* "cpython/datetime.pxd":196
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):
+ *     return PyDateTime_DATE_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":199
+ * 
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_microsecond", 0);
+
+  /* "cpython/datetime.pxd":200
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get days of timedelta
+ */
+  __pyx_r = PyDateTime_DATE_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":203
+ * 
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).days
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_days(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_days", 0);
+
+  /* "cpython/datetime.pxd":204
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):
+ *     return (<PyDateTime_Delta*>o).days             # <<<<<<<<<<<<<<
+ * 
+ * # Get seconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->days;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":207
+ * 
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).seconds
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_seconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_seconds", 0);
+
+  /* "cpython/datetime.pxd":208
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):
+ *     return (<PyDateTime_Delta*>o).seconds             # <<<<<<<<<<<<<<
+ * 
+ * # Get microseconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->seconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_microseconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_microseconds", 0);
+
+  /* "cpython/datetime.pxd":212
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):
+ *     return (<PyDateTime_Delta*>o).microseconds             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->microseconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+static struct __pyx_vtabstruct_3zmq_4core_6socket_Socket __pyx_vtable_3zmq_4core_6socket_Socket;
+
+static PyObject *__pyx_tp_new_3zmq_4core_6socket_Socket(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_3zmq_4core_6socket_Socket *p;
+  PyObject *o;
+  o = (*t->tp_alloc)(t, 0);
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_3zmq_4core_6socket_Socket *)o);
+  p->__pyx_vtab = __pyx_vtabptr_3zmq_4core_6socket_Socket;
+  p->__weakref__ = 0;
+  p->context = ((struct __pyx_obj_3zmq_4core_7context_Context *)Py_None); Py_INCREF(Py_None);
+  if (unlikely(__pyx_pw_3zmq_4core_6socket_6Socket_1__cinit__(o, a, k) < 0)) {
+    Py_DECREF(o); o = 0;
+  }
+  return o;
+}
+
+static void __pyx_tp_dealloc_3zmq_4core_6socket_Socket(PyObject *o) {
+  struct __pyx_obj_3zmq_4core_6socket_Socket *p = (struct __pyx_obj_3zmq_4core_6socket_Socket *)o;
+  PyObject_GC_UnTrack(o);
+  {
+    PyObject *etype, *eval, *etb;
+    PyErr_Fetch(&etype, &eval, &etb);
+    ++Py_REFCNT(o);
+    __pyx_pw_3zmq_4core_6socket_6Socket_3__dealloc__(o);
+    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
+    --Py_REFCNT(o);
+    PyErr_Restore(etype, eval, etb);
+  }
+  if (p->__weakref__) PyObject_ClearWeakRefs(o);
+  Py_CLEAR(p->context);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static int __pyx_tp_traverse_3zmq_4core_6socket_Socket(PyObject *o, visitproc v, void *a) {
+  int e;
+  struct __pyx_obj_3zmq_4core_6socket_Socket *p = (struct __pyx_obj_3zmq_4core_6socket_Socket *)o;
+  if (p->context) {
+    e = (*v)(((PyObject*)p->context), a); if (e) return e;
+  }
+  return 0;
+}
+
+static int __pyx_tp_clear_3zmq_4core_6socket_Socket(PyObject *o) {
+  struct __pyx_obj_3zmq_4core_6socket_Socket *p = (struct __pyx_obj_3zmq_4core_6socket_Socket *)o;
+  PyObject* tmp;
+  tmp = ((PyObject*)p->context);
+  p->context = ((struct __pyx_obj_3zmq_4core_7context_Context *)Py_None); Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  return 0;
+}
+
+static PyObject *__pyx_getprop_3zmq_4core_6socket_6Socket_socket_type(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3zmq_4core_6socket_6Socket_11socket_type_1__get__(o);
+}
+
+static int __pyx_setprop_3zmq_4core_6socket_6Socket_socket_type(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
+  if (v) {
+    return __pyx_pw_3zmq_4core_6socket_6Socket_11socket_type_3__set__(o, v);
+  }
+  else {
+    PyErr_SetString(PyExc_NotImplementedError, "__del__");
+    return -1;
+  }
+}
+
+static PyObject *__pyx_getprop_3zmq_4core_6socket_6Socket_context(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3zmq_4core_6socket_6Socket_7context_1__get__(o);
+}
+
+static int __pyx_setprop_3zmq_4core_6socket_6Socket_context(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
+  if (v) {
+    return __pyx_pw_3zmq_4core_6socket_6Socket_7context_3__set__(o, v);
+  }
+  else {
+    return __pyx_pw_3zmq_4core_6socket_6Socket_7context_5__del__(o);
+  }
+}
+
+static PyObject *__pyx_getprop_3zmq_4core_6socket_6Socket__closed(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3zmq_4core_6socket_6Socket_7_closed_1__get__(o);
+}
+
+static int __pyx_setprop_3zmq_4core_6socket_6Socket__closed(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
+  if (v) {
+    return __pyx_pw_3zmq_4core_6socket_6Socket_7_closed_3__set__(o, v);
+  }
+  else {
+    PyErr_SetString(PyExc_NotImplementedError, "__del__");
+    return -1;
+  }
+}
+
+static PyMethodDef __pyx_methods_3zmq_4core_6socket_Socket[] = {
+  {__Pyx_NAMESTR("closed"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_7closed, METH_NOARGS, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("close"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_9close, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_8close)},
+  {__Pyx_NAMESTR("set"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_11set, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_10set)},
+  {__Pyx_NAMESTR("get"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_13get, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_12get)},
+  {__Pyx_NAMESTR("bind"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_15bind, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_14bind)},
+  {__Pyx_NAMESTR("connect"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_17connect, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_16connect)},
+  {__Pyx_NAMESTR("unbind"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_19unbind, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_18unbind)},
+  {__Pyx_NAMESTR("disconnect"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_21disconnect, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_20disconnect)},
+  {__Pyx_NAMESTR("send"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_23send, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_22send)},
+  {__Pyx_NAMESTR("recv"), (PyCFunction)__pyx_pw_3zmq_4core_6socket_6Socket_25recv, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_6socket_6Socket_24recv)},
+  {0, 0, 0, 0}
+};
+
+static struct PyGetSetDef __pyx_getsets_3zmq_4core_6socket_Socket[] = {
+  {(char *)"socket_type", __pyx_getprop_3zmq_4core_6socket_6Socket_socket_type, __pyx_setprop_3zmq_4core_6socket_6Socket_socket_type, 0, 0},
+  {(char *)"context", __pyx_getprop_3zmq_4core_6socket_6Socket_context, __pyx_setprop_3zmq_4core_6socket_6Socket_context, 0, 0},
+  {(char *)"_closed", __pyx_getprop_3zmq_4core_6socket_6Socket__closed, __pyx_setprop_3zmq_4core_6socket_6Socket__closed, 0, 0},
+  {0, 0, 0, 0, 0}
+};
+
+static PyNumberMethods __pyx_tp_as_number_Socket = {
+  0, /*nb_add*/
+  0, /*nb_subtract*/
+  0, /*nb_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_divide*/
+  #endif
+  0, /*nb_remainder*/
+  0, /*nb_divmod*/
+  0, /*nb_power*/
+  0, /*nb_negative*/
+  0, /*nb_positive*/
+  0, /*nb_absolute*/
+  0, /*nb_nonzero*/
+  0, /*nb_invert*/
+  0, /*nb_lshift*/
+  0, /*nb_rshift*/
+  0, /*nb_and*/
+  0, /*nb_xor*/
+  0, /*nb_or*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_coerce*/
+  #endif
+  0, /*nb_int*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_long*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*nb_float*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_oct*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_hex*/
+  #endif
+  0, /*nb_inplace_add*/
+  0, /*nb_inplace_subtract*/
+  0, /*nb_inplace_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_inplace_divide*/
+  #endif
+  0, /*nb_inplace_remainder*/
+  0, /*nb_inplace_power*/
+  0, /*nb_inplace_lshift*/
+  0, /*nb_inplace_rshift*/
+  0, /*nb_inplace_and*/
+  0, /*nb_inplace_xor*/
+  0, /*nb_inplace_or*/
+  0, /*nb_floor_divide*/
+  0, /*nb_true_divide*/
+  0, /*nb_inplace_floor_divide*/
+  0, /*nb_inplace_true_divide*/
+  #if PY_VERSION_HEX >= 0x02050000
+  0, /*nb_index*/
+  #endif
+};
+
+static PySequenceMethods __pyx_tp_as_sequence_Socket = {
+  0, /*sq_length*/
+  0, /*sq_concat*/
+  0, /*sq_repeat*/
+  0, /*sq_item*/
+  0, /*sq_slice*/
+  0, /*sq_ass_item*/
+  0, /*sq_ass_slice*/
+  0, /*sq_contains*/
+  0, /*sq_inplace_concat*/
+  0, /*sq_inplace_repeat*/
+};
+
+static PyMappingMethods __pyx_tp_as_mapping_Socket = {
+  0, /*mp_length*/
+  0, /*mp_subscript*/
+  0, /*mp_ass_subscript*/
+};
+
+static PyBufferProcs __pyx_tp_as_buffer_Socket = {
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getreadbuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getwritebuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getsegcount*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getcharbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_getbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_releasebuffer*/
+  #endif
+};
+
+static PyTypeObject __pyx_type_3zmq_4core_6socket_Socket = {
+  PyVarObject_HEAD_INIT(0, 0)
+  __Pyx_NAMESTR("zmq.core.socket.Socket"), /*tp_name*/
+  sizeof(struct __pyx_obj_3zmq_4core_6socket_Socket), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_3zmq_4core_6socket_Socket, /*tp_dealloc*/
+  0, /*tp_print*/
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*tp_repr*/
+  &__pyx_tp_as_number_Socket, /*tp_as_number*/
+  &__pyx_tp_as_sequence_Socket, /*tp_as_sequence*/
+  &__pyx_tp_as_mapping_Socket, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  &__pyx_tp_as_buffer_Socket, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  __Pyx_DOCSTR("Socket(context, socket_type)\n\n    A 0MQ socket.\n\n    These objects will generally be constructed via the socket() method of a Context object.\n    \n    Note: 0MQ Sockets are *not* threadsafe. **DO NOT** share them across threads.\n    \n    Parameters\n    ----------\n    context : Context\n        The 0MQ Context this Socket belongs to.\n    socket_type : int\n        The socket type, which can be any of the 0MQ socket types: \n        REQ, REP, PUB, SUB, PAIR, DEALER, ROUTER, PULL, PUSH, XPUB, XSUB.\n    \n    See Also\n    --------\n    .Context.socket : method for creating a socket bound to a Context.\n    "), /*tp_doc*/
+  __pyx_tp_traverse_3zmq_4core_6socket_Socket, /*tp_traverse*/
+  __pyx_tp_clear_3zmq_4core_6socket_Socket, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_3zmq_4core_6socket_Socket, /*tp_methods*/
+  0, /*tp_members*/
+  __pyx_getsets_3zmq_4core_6socket_Socket, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  __pyx_pw_3zmq_4core_6socket_6Socket_5__init__, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_3zmq_4core_6socket_Socket, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*tp_version_tag*/
+  #endif
+};
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+static char* __pyx_import_star_type_names[] = {
+  "__pyx_opt_args_3zmq_4core_6socket__send_copy",
+  "Socket",
+  "__pyx_opt_args_3zmq_4core_6socket__recv_frame",
+  "__pyx_opt_args_3zmq_4core_6socket_6Socket_send",
+  "zmq_pollitem_t",
+  "const_void_ptr",
+  "Context",
+  "fd_t",
+  "zmq_free_fn",
+  "zmq_msg_t",
+  "Frame",
+  "__pyx_opt_args_3zmq_4core_6socket__send_frame",
+  "int64_t",
+  "__pyx_opt_args_3zmq_4core_6socket_6Socket_recv",
+  "__pyx_opt_args_3zmq_4core_6socket__recv_copy",
+  "Py_ssize_t",
+  0
+};
+
+static int __pyx_import_star_set(PyObject *o, PyObject* py_name, char *name) {
+  char** type_name = __pyx_import_star_type_names;
+  while (*type_name) {
+    if (__Pyx_StrEq(name, *type_name)) {
+      PyErr_Format(PyExc_TypeError, "Cannot overwrite C type %s", name);
+      goto bad;
+    }
+    type_name++;
+  }
+  if (0);
+  else {
+    if (PyObject_SetAttr(__pyx_m, py_name, o) < 0) goto bad;
+  }
+  return 0;
+  bad:
+  return -1;
+}
+
+
+/* import_all_from is an unexposed function from ceval.c */
+
+static int
+__Pyx_import_all_from(PyObject *locals, PyObject *v)
+{
+    PyObject *all = __Pyx_GetAttrString(v, "__all__");
+    PyObject *dict, *name, *value;
+    int skip_leading_underscores = 0;
+    int pos, err;
+
+    if (all == NULL) {
+        if (!PyErr_ExceptionMatches(PyExc_AttributeError))
+            return -1; /* Unexpected error */
+        PyErr_Clear();
+        dict = __Pyx_GetAttrString(v, "__dict__");
+        if (dict == NULL) {
+            if (!PyErr_ExceptionMatches(PyExc_AttributeError))
+                return -1;
+            PyErr_SetString(PyExc_ImportError,
+            "from-import-* object has no __dict__ and no __all__");
+            return -1;
+        }
+#if PY_MAJOR_VERSION < 3
+        all = PyObject_CallMethod(dict, (char *)"keys", NULL);
+#else
+        all = PyMapping_Keys(dict);
+#endif
+        Py_DECREF(dict);
+        if (all == NULL)
+            return -1;
+        skip_leading_underscores = 1;
+    }
+
+    for (pos = 0, err = 0; ; pos++) {
+        name = PySequence_GetItem(all, pos);
+        if (name == NULL) {
+            if (!PyErr_ExceptionMatches(PyExc_IndexError))
+                err = -1;
+            else
+                PyErr_Clear();
+            break;
+        }
+        if (skip_leading_underscores &&
+#if PY_MAJOR_VERSION < 3
+            PyString_Check(name) &&
+            PyString_AS_STRING(name)[0] == '_')
+#else
+            PyUnicode_Check(name) &&
+            PyUnicode_AS_UNICODE(name)[0] == '_')
+#endif
+        {
+            Py_DECREF(name);
+            continue;
+        }
+        value = PyObject_GetAttr(v, name);
+        if (value == NULL)
+            err = -1;
+        else if (PyDict_CheckExact(locals))
+            err = PyDict_SetItem(locals, name, value);
+        else
+            err = PyObject_SetItem(locals, name, value);
+        Py_DECREF(name);
+        Py_XDECREF(value);
+        if (err != 0)
+            break;
+    }
+    Py_DECREF(all);
+    return err;
+}
+
+
+static int __pyx_import_star(PyObject* m) {
+
+    int i;
+    int ret = -1;
+    char* s;
+    PyObject *locals = 0;
+    PyObject *list = 0;
+#if PY_MAJOR_VERSION >= 3
+    PyObject *utf8_name = 0;
+#endif
+    PyObject *name;
+    PyObject *item;
+
+    locals = PyDict_New();              if (!locals) goto bad;
+    if (__Pyx_import_all_from(locals, m) < 0) goto bad;
+    list = PyDict_Items(locals);        if (!list) goto bad;
+
+    for(i=0; i<PyList_GET_SIZE(list); i++) {
+        name = PyTuple_GET_ITEM(PyList_GET_ITEM(list, i), 0);
+        item = PyTuple_GET_ITEM(PyList_GET_ITEM(list, i), 1);
+#if PY_MAJOR_VERSION >= 3
+        utf8_name = PyUnicode_AsUTF8String(name);
+        if (!utf8_name) goto bad;
+        s = PyBytes_AS_STRING(utf8_name);
+        if (__pyx_import_star_set(item, name, s) < 0) goto bad;
+        Py_DECREF(utf8_name); utf8_name = 0;
+#else
+        s = PyString_AsString(name);
+        if (!s) goto bad;
+        if (__pyx_import_star_set(item, name, s) < 0) goto bad;
+#endif
+    }
+    ret = 0;
+
+bad:
+    Py_XDECREF(locals);
+    Py_XDECREF(list);
+#if PY_MAJOR_VERSION >= 3
+    Py_XDECREF(utf8_name);
+#endif
+    return ret;
+}
+
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("socket"),
+    __Pyx_DOCSTR(__pyx_k_32), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_s_10, __pyx_k_10, sizeof(__pyx_k_10), 0, 0, 1, 0},
+  {&__pyx_kp_s_12, __pyx_k_12, sizeof(__pyx_k_12), 0, 0, 1, 0},
+  {&__pyx_kp_s_14, __pyx_k_14, sizeof(__pyx_k_14), 0, 0, 1, 0},
+  {&__pyx_kp_s_16, __pyx_k_16, sizeof(__pyx_k_16), 0, 0, 1, 0},
+  {&__pyx_kp_s_2, __pyx_k_2, sizeof(__pyx_k_2), 0, 0, 1, 0},
+  {&__pyx_kp_s_20, __pyx_k_20, sizeof(__pyx_k_20), 0, 0, 1, 0},
+  {&__pyx_kp_s_22, __pyx_k_22, sizeof(__pyx_k_22), 0, 0, 1, 0},
+  {&__pyx_n_s_26, __pyx_k_26, sizeof(__pyx_k_26), 0, 0, 1, 1},
+  {&__pyx_kp_s_27, __pyx_k_27, sizeof(__pyx_k_27), 0, 0, 1, 0},
+  {&__pyx_kp_s_29, __pyx_k_29, sizeof(__pyx_k_29), 0, 0, 1, 0},
+  {&__pyx_kp_s_30, __pyx_k_30, sizeof(__pyx_k_30), 0, 0, 1, 0},
+  {&__pyx_n_s_33, __pyx_k_33, sizeof(__pyx_k_33), 0, 0, 1, 1},
+  {&__pyx_n_s_34, __pyx_k_34, sizeof(__pyx_k_34), 0, 0, 1, 1},
+  {&__pyx_n_s_35, __pyx_k_35, sizeof(__pyx_k_35), 0, 0, 1, 1},
+  {&__pyx_n_s_36, __pyx_k_36, sizeof(__pyx_k_36), 0, 0, 1, 1},
+  {&__pyx_n_s_37, __pyx_k_37, sizeof(__pyx_k_37), 0, 0, 1, 1},
+  {&__pyx_kp_s_4, __pyx_k_4, sizeof(__pyx_k_4), 0, 0, 1, 0},
+  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
+  {&__pyx_kp_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 0},
+  {&__pyx_kp_s_8, __pyx_k_8, sizeof(__pyx_k_8), 0, 0, 1, 0},
+  {&__pyx_n_s__Again, __pyx_k__Again, sizeof(__pyx_k__Again), 0, 0, 1, 1},
+  {&__pyx_n_s__AttributeError, __pyx_k__AttributeError, sizeof(__pyx_k__AttributeError), 0, 0, 1, 1},
+  {&__pyx_n_b__B, __pyx_k__B, sizeof(__pyx_k__B), 0, 0, 0, 1},
+  {&__pyx_n_s__ContextTerminated, __pyx_k__ContextTerminated, sizeof(__pyx_k__ContextTerminated), 0, 0, 1, 1},
+  {&__pyx_n_s__ENOTSOCK, __pyx_k__ENOTSOCK, sizeof(__pyx_k__ENOTSOCK), 0, 0, 1, 1},
+  {&__pyx_n_s__ENOTSUP, __pyx_k__ENOTSUP, sizeof(__pyx_k__ENOTSUP), 0, 0, 1, 1},
+  {&__pyx_n_s__IPC_PATH_MAX_LEN, __pyx_k__IPC_PATH_MAX_LEN, sizeof(__pyx_k__IPC_PATH_MAX_LEN), 0, 0, 1, 1},
+  {&__pyx_n_s__NotImplementedError, __pyx_k__NotImplementedError, sizeof(__pyx_k__NotImplementedError), 0, 0, 1, 1},
+  {&__pyx_n_s__RCVMORE, __pyx_k__RCVMORE, sizeof(__pyx_k__RCVMORE), 0, 0, 1, 1},
+  {&__pyx_n_s__Socket, __pyx_k__Socket, sizeof(__pyx_k__Socket), 0, 0, 1, 1},
+  {&__pyx_n_s__TypeError, __pyx_k__TypeError, sizeof(__pyx_k__TypeError), 0, 0, 1, 1},
+  {&__pyx_n_s__ValueError, __pyx_k__ValueError, sizeof(__pyx_k__ValueError), 0, 0, 1, 1},
+  {&__pyx_n_s__ZMQBindError, __pyx_k__ZMQBindError, sizeof(__pyx_k__ZMQBindError), 0, 0, 1, 1},
+  {&__pyx_n_s__ZMQError, __pyx_k__ZMQError, sizeof(__pyx_k__ZMQError), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s___handle, __pyx_k___handle, sizeof(__pyx_k___handle), 0, 0, 1, 1},
+  {&__pyx_n_s__ascii, __pyx_k__ascii, sizeof(__pyx_k__ascii), 0, 0, 1, 1},
+  {&__pyx_n_s__basestring, __pyx_k__basestring, sizeof(__pyx_k__basestring), 0, 0, 1, 1},
+  {&__pyx_n_s__buffer, __pyx_k__buffer, sizeof(__pyx_k__buffer), 0, 0, 1, 1},
+  {&__pyx_n_s__bytes, __pyx_k__bytes, sizeof(__pyx_k__bytes), 0, 0, 1, 1},
+  {&__pyx_n_s__bytes_sockopts, __pyx_k__bytes_sockopts, sizeof(__pyx_k__bytes_sockopts), 0, 0, 1, 1},
+  {&__pyx_n_s__cPickle, __pyx_k__cPickle, sizeof(__pyx_k__cPickle), 0, 0, 1, 1},
+  {&__pyx_n_s__char, __pyx_k__char, sizeof(__pyx_k__char), 0, 0, 1, 1},
+  {&__pyx_n_s__closed, __pyx_k__closed, sizeof(__pyx_k__closed), 0, 0, 1, 1},
+  {&__pyx_n_s__codecs, __pyx_k__codecs, sizeof(__pyx_k__codecs), 0, 0, 1, 1},
+  {&__pyx_n_s__constants, __pyx_k__constants, sizeof(__pyx_k__constants), 0, 0, 1, 1},
+  {&__pyx_n_s__context, __pyx_k__context, sizeof(__pyx_k__context), 0, 0, 1, 1},
+  {&__pyx_n_s__copy, __pyx_k__copy, sizeof(__pyx_k__copy), 0, 0, 1, 1},
+  {&__pyx_n_s__copy_mod, __pyx_k__copy_mod, sizeof(__pyx_k__copy_mod), 0, 0, 1, 1},
+  {&__pyx_n_s__data, __pyx_k__data, sizeof(__pyx_k__data), 0, 0, 1, 1},
+  {&__pyx_n_s__decode, __pyx_k__decode, sizeof(__pyx_k__decode), 0, 0, 1, 1},
+  {&__pyx_n_s__dtype, __pyx_k__dtype, sizeof(__pyx_k__dtype), 0, 0, 1, 1},
+  {&__pyx_n_s__encode, __pyx_k__encode, sizeof(__pyx_k__encode), 0, 0, 1, 1},
+  {&__pyx_n_s__flags, __pyx_k__flags, sizeof(__pyx_k__flags), 0, 0, 1, 1},
+  {&__pyx_n_s__format, __pyx_k__format, sizeof(__pyx_k__format), 0, 0, 1, 1},
+  {&__pyx_n_s__getsockopt, __pyx_k__getsockopt, sizeof(__pyx_k__getsockopt), 0, 0, 1, 1},
+  {&__pyx_n_s__int64_sockopts, __pyx_k__int64_sockopts, sizeof(__pyx_k__int64_sockopts), 0, 0, 1, 1},
+  {&__pyx_n_s__itemsize, __pyx_k__itemsize, sizeof(__pyx_k__itemsize), 0, 0, 1, 1},
+  {&__pyx_n_s__jsonapi, __pyx_k__jsonapi, sizeof(__pyx_k__jsonapi), 0, 0, 1, 1},
+  {&__pyx_n_s__linger, __pyx_k__linger, sizeof(__pyx_k__linger), 0, 0, 1, 1},
+  {&__pyx_n_s__msg, __pyx_k__msg, sizeof(__pyx_k__msg), 0, 0, 1, 1},
+  {&__pyx_n_s__option, __pyx_k__option, sizeof(__pyx_k__option), 0, 0, 1, 1},
+  {&__pyx_n_s__optval, __pyx_k__optval, sizeof(__pyx_k__optval), 0, 0, 1, 1},
+  {&__pyx_n_s__pickle, __pyx_k__pickle, sizeof(__pyx_k__pickle), 0, 0, 1, 1},
+  {&__pyx_n_s__property, __pyx_k__property, sizeof(__pyx_k__property), 0, 0, 1, 1},
+  {&__pyx_n_s__random, __pyx_k__random, sizeof(__pyx_k__random), 0, 0, 1, 1},
+  {&__pyx_n_s__recv, __pyx_k__recv, sizeof(__pyx_k__recv), 0, 0, 1, 1},
+  {&__pyx_n_s__replace, __pyx_k__replace, sizeof(__pyx_k__replace), 0, 0, 1, 1},
+  {&__pyx_n_s__send, __pyx_k__send, sizeof(__pyx_k__send), 0, 0, 1, 1},
+  {&__pyx_n_s__socket_type, __pyx_k__socket_type, sizeof(__pyx_k__socket_type), 0, 0, 1, 1},
+  {&__pyx_n_s__split, __pyx_k__split, sizeof(__pyx_k__split), 0, 0, 1, 1},
+  {&__pyx_n_s__struct, __pyx_k__struct, sizeof(__pyx_k__struct), 0, 0, 1, 1},
+  {&__pyx_n_s__sys, __pyx_k__sys, sizeof(__pyx_k__sys), 0, 0, 1, 1},
+  {&__pyx_n_s__time, __pyx_k__time, sizeof(__pyx_k__time), 0, 0, 1, 1},
+  {&__pyx_n_s__track, __pyx_k__track, sizeof(__pyx_k__track), 0, 0, 1, 1},
+  {&__pyx_n_s__tracker, __pyx_k__tracker, sizeof(__pyx_k__tracker), 0, 0, 1, 1},
+  {&__pyx_n_s__typecode, __pyx_k__typecode, sizeof(__pyx_k__typecode), 0, 0, 1, 1},
+  {&__pyx_n_s__unicode, __pyx_k__unicode, sizeof(__pyx_k__unicode), 0, 0, 1, 1},
+  {&__pyx_n_s__zmq, __pyx_k__zmq, sizeof(__pyx_k__zmq), 0, 0, 1, 1},
+  {&__pyx_n_s__zmq_version, __pyx_k__zmq_version, sizeof(__pyx_k__zmq_version), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s__property); if (!__pyx_builtin_property) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s__TypeError); if (!__pyx_builtin_TypeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s__NotImplementedError); if (!__pyx_builtin_NotImplementedError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s__ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 581; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s__AttributeError); if (!__pyx_builtin_AttributeError) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/socket.pyx":294
+ *         _check_closed(self, True)
+ *         if isinstance(optval, unicode):
+ *             raise TypeError("unicode not allowed, use setsockopt_string")             # <<<<<<<<<<<<<<
+ * 
+ *         if option in zmq.constants.bytes_sockopts:
+ */
+  __pyx_k_tuple_3 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_2)); if (unlikely(!__pyx_k_tuple_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_3);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_3));
+
+  /* "zmq/core/socket.pyx":415
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')             # <<<<<<<<<<<<<<
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ */
+  __pyx_k_tuple_7 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_6)); if (unlikely(!__pyx_k_tuple_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_7);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_7));
+
+  /* "zmq/core/socket.pyx":424
+ *                 # py3compat: addr is bytes, but msg wants str
+ *                 if str is unicode:
+ *                     addr = addr.decode('utf-8', 'replace')             # <<<<<<<<<<<<<<
+ *                 path = addr.split('://', 1)[-1]
+ *                 msg = ('ipc path "{0}" is longer than {1} '
+ */
+  __pyx_k_tuple_9 = PyTuple_Pack(2, ((PyObject *)__pyx_kp_s_6), ((PyObject *)__pyx_n_s__replace)); if (unlikely(!__pyx_k_tuple_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_9);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_9));
+
+  /* "zmq/core/socket.pyx":425
+ *                 if str is unicode:
+ *                     addr = addr.decode('utf-8', 'replace')
+ *                 path = addr.split('://', 1)[-1]             # <<<<<<<<<<<<<<
+ *                 msg = ('ipc path "{0}" is longer than {1} '
+ *                                 'characters (sizeof(sockaddr_un.sun_path)). '
+ */
+  __pyx_k_tuple_11 = PyTuple_Pack(2, ((PyObject *)__pyx_kp_s_10), __pyx_int_1); if (unlikely(!__pyx_k_tuple_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_11);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_11));
+
+  /* "zmq/core/socket.pyx":452
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')             # <<<<<<<<<<<<<<
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ */
+  __pyx_k_tuple_13 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_6)); if (unlikely(!__pyx_k_tuple_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_13);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_13));
+
+  /* "zmq/core/socket.pyx":485
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')             # <<<<<<<<<<<<<<
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ */
+  __pyx_k_tuple_15 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_6)); if (unlikely(!__pyx_k_tuple_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_15);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_15));
+
+  /* "zmq/core/socket.pyx":517
+ *         _check_closed(self, True)
+ *         if isinstance(addr, unicode):
+ *             addr = addr.encode('utf-8')             # <<<<<<<<<<<<<<
+ *         if not isinstance(addr, bytes):
+ *             raise TypeError('expected str, got: %r' % addr)
+ */
+  __pyx_k_tuple_17 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_6)); if (unlikely(!__pyx_k_tuple_17)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_17);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_17));
+
+  /* "zmq/core/socket.pyx":570
+ * 
+ *         if isinstance(data, unicode):
+ *             raise TypeError("unicode not allowed, use send_unicode")             # <<<<<<<<<<<<<<
+ * 
+ *         if copy:
+ */
+  __pyx_k_tuple_21 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_20)); if (unlikely(!__pyx_k_tuple_21)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_21);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_21));
+
+  /* "zmq/core/socket.pyx":581
+ *             if isinstance(data, Frame):
+ *                 if track and not data.tracker:
+ *                     raise ValueError('Not a tracked message')             # <<<<<<<<<<<<<<
+ *                 msg = data
+ *             else:
+ */
+  __pyx_k_tuple_23 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_22)); if (unlikely(!__pyx_k_tuple_23)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 581; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_23);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_23));
+
+  /* "buffers.pxd":194
+ * 
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:
+ *         return bfmt.decode('ascii')             # <<<<<<<<<<<<<<
+ *     return bfmt
+ * 
+ */
+  __pyx_k_tuple_28 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__ascii)); if (unlikely(!__pyx_k_tuple_28)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_28);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_28));
+
+  /* "buffers.pxd":241
+ *             return PyBuffer_FromReadWriteMemory(ptr, s)
+ *     else:
+ *         raise NotImplementedError("Old style buffers not available.")             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_k_tuple_31 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_30)); if (unlikely(!__pyx_k_tuple_31)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_31);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_31));
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC initsocket(void); /*proto*/
+PyMODINIT_FUNC initsocket(void)
+#else
+PyMODINIT_FUNC PyInit_socket(void); /*proto*/
+PyMODINIT_FUNC PyInit_socket(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_socket(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("socket"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_32), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core.socket")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core.socket", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core__socket) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  __pyx_vtabptr_3zmq_4core_6socket_Socket = &__pyx_vtable_3zmq_4core_6socket_Socket;
+  __pyx_vtable_3zmq_4core_6socket_Socket.send = (PyObject *(*)(struct __pyx_obj_3zmq_4core_6socket_Socket *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send *__pyx_optional_args))__pyx_f_3zmq_4core_6socket_6Socket_send;
+  __pyx_vtable_3zmq_4core_6socket_Socket.recv = (PyObject *(*)(struct __pyx_obj_3zmq_4core_6socket_Socket *, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv *__pyx_optional_args))__pyx_f_3zmq_4core_6socket_6Socket_recv;
+  if (PyType_Ready(&__pyx_type_3zmq_4core_6socket_Socket) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetVtable(__pyx_type_3zmq_4core_6socket_Socket.tp_dict, __pyx_vtabptr_3zmq_4core_6socket_Socket) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetAttrString(__pyx_m, "Socket", (PyObject *)&__pyx_type_3zmq_4core_6socket_Socket) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_type_3zmq_4core_6socket_Socket.tp_weaklistoffset == 0) __pyx_type_3zmq_4core_6socket_Socket.tp_weaklistoffset = offsetof(struct __pyx_obj_3zmq_4core_6socket_Socket, __weakref__);
+  __pyx_ptype_3zmq_4core_6socket_Socket = &__pyx_type_3zmq_4core_6socket_Socket;
+  /*--- Type import code ---*/
+  __pyx_ptype_3zmq_4core_7context_Context = __Pyx_ImportType("zmq.core.context", "Context", sizeof(struct __pyx_obj_3zmq_4core_7context_Context), 1); if (unlikely(!__pyx_ptype_3zmq_4core_7context_Context)) {__pyx_filename = __pyx_f[6]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_vtabptr_3zmq_4core_7context_Context = (struct __pyx_vtabstruct_3zmq_4core_7context_Context*)__Pyx_GetVtable(__pyx_ptype_3zmq_4core_7context_Context->tp_dict); if (unlikely(!__pyx_vtabptr_3zmq_4core_7context_Context)) {__pyx_filename = __pyx_f[6]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
+  #if CYTHON_COMPILING_IN_PYPY
+  sizeof(PyTypeObject),
+  #else
+  sizeof(PyHeapTypeObject),
+  #endif
+  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[7]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), 0); if (unlikely(!__pyx_ptype_7cpython_4bool_bool)) {__pyx_filename = __pyx_f[8]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), 0); if (unlikely(!__pyx_ptype_7cpython_7complex_complex)) {__pyx_filename = __pyx_f[9]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_date = __Pyx_ImportType("datetime", "date", sizeof(PyDateTime_Date), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_date)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_time = __Pyx_ImportType("datetime", "time", sizeof(PyDateTime_Time), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_time)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_datetime = __Pyx_ImportType("datetime", "datetime", sizeof(PyDateTime_DateTime), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_datetime)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_timedelta = __Pyx_ImportType("datetime", "timedelta", sizeof(PyDateTime_Delta), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_timedelta)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_tzinfo = __Pyx_ImportType("datetime", "tzinfo", sizeof(PyDateTime_TZInfo), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_tzinfo)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_3zmq_4core_7message_MessageTracker = __Pyx_ImportType("zmq.core.message", "MessageTracker", sizeof(struct __pyx_obj_3zmq_4core_7message_MessageTracker), 1); if (unlikely(!__pyx_ptype_3zmq_4core_7message_MessageTracker)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_3zmq_4core_7message_Frame = __Pyx_ImportType("zmq.core.message", "Frame", sizeof(struct __pyx_obj_3zmq_4core_7message_Frame), 1); if (unlikely(!__pyx_ptype_3zmq_4core_7message_Frame)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_vtabptr_3zmq_4core_7message_Frame = (struct __pyx_vtabstruct_3zmq_4core_7message_Frame*)__Pyx_GetVtable(__pyx_ptype_3zmq_4core_7message_Frame->tp_dict); if (unlikely(!__pyx_vtabptr_3zmq_4core_7message_Frame)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/socket.pyx":58
+ * #-----------------------------------------------------------------------------
+ * 
+ * import copy as copy_mod             # <<<<<<<<<<<<<<
+ * import time
+ * import sys
+ */
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__copy), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__copy_mod, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":59
+ * 
+ * import copy as copy_mod
+ * import time             # <<<<<<<<<<<<<<
+ * import sys
+ * import random
+ */
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__time), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__time, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":60
+ * import copy as copy_mod
+ * import time
+ * import sys             # <<<<<<<<<<<<<<
+ * import random
+ * import struct
+ */
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__sys), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sys, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":61
+ * import time
+ * import sys
+ * import random             # <<<<<<<<<<<<<<
+ * import struct
+ * import codecs
+ */
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__random), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__random, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":62
+ * import sys
+ * import random
+ * import struct             # <<<<<<<<<<<<<<
+ * import codecs
+ * 
+ */
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__struct), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__struct, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":63
+ * import random
+ * import struct
+ * import codecs             # <<<<<<<<<<<<<<
+ * 
+ * from zmq.utils import jsonapi
+ */
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__codecs), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__codecs, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":65
+ * import codecs
+ * 
+ * from zmq.utils import jsonapi             # <<<<<<<<<<<<<<
+ * 
+ * try:
+ */
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 65; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__jsonapi));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__jsonapi));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__jsonapi));
+  __pyx_t_2 = __Pyx_Import(((PyObject *)__pyx_n_s_33), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 65; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s__jsonapi); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 65; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__jsonapi, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 65; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "zmq/core/socket.pyx":67
+ * from zmq.utils import jsonapi
+ * 
+ * try:             # <<<<<<<<<<<<<<
+ *     import cPickle
+ *     pickle = cPickle
+ */
+  {
+    __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
+    __Pyx_XGOTREF(__pyx_t_3);
+    __Pyx_XGOTREF(__pyx_t_4);
+    __Pyx_XGOTREF(__pyx_t_5);
+    /*try:*/ {
+
+      /* "zmq/core/socket.pyx":68
+ * 
+ * try:
+ *     import cPickle             # <<<<<<<<<<<<<<
+ *     pickle = cPickle
+ * except:
+ */
+      __pyx_t_2 = __Pyx_Import(((PyObject *)__pyx_n_s__cPickle), 0, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      if (PyDict_SetItem(__pyx_d, __pyx_n_s__cPickle, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+      /* "zmq/core/socket.pyx":69
+ * try:
+ *     import cPickle
+ *     pickle = cPickle             # <<<<<<<<<<<<<<
+ * except:
+ *     cPickle = None
+ */
+      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__cPickle); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      if (PyDict_SetItem(__pyx_d, __pyx_n_s__pickle, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    }
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    goto __pyx_L9_try_end;
+    __pyx_L2_error:;
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+    /* "zmq/core/socket.pyx":70
+ *     import cPickle
+ *     pickle = cPickle
+ * except:             # <<<<<<<<<<<<<<
+ *     cPickle = None
+ *     import pickle
+ */
+    /*except:*/ {
+      __Pyx_AddTraceback("zmq.core.socket", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_1, &__pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_GOTREF(__pyx_t_6);
+
+      /* "zmq/core/socket.pyx":71
+ *     pickle = cPickle
+ * except:
+ *     cPickle = None             # <<<<<<<<<<<<<<
+ *     import pickle
+ * 
+ */
+      if (PyDict_SetItem(__pyx_d, __pyx_n_s__cPickle, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 71; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+
+      /* "zmq/core/socket.pyx":72
+ * except:
+ *     cPickle = None
+ *     import pickle             # <<<<<<<<<<<<<<
+ * 
+ * import zmq
+ */
+      __pyx_t_7 = __Pyx_Import(((PyObject *)__pyx_n_s__pickle), 0, -1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+      __Pyx_GOTREF(__pyx_t_7);
+      if (PyDict_SetItem(__pyx_d, __pyx_n_s__pickle, __pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      goto __pyx_L3_exception_handled;
+    }
+    __pyx_L4_except_error:;
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_XGIVEREF(__pyx_t_4);
+    __Pyx_XGIVEREF(__pyx_t_5);
+    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
+    goto __pyx_L1_error;
+    __pyx_L3_exception_handled:;
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_XGIVEREF(__pyx_t_4);
+    __Pyx_XGIVEREF(__pyx_t_5);
+    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
+    __pyx_L9_try_end:;
+  }
+
+  /* "zmq/core/socket.pyx":74
+ *     import pickle
+ * 
+ * import zmq             # <<<<<<<<<<<<<<
+ * from zmq.core import constants
+ * from zmq.core.constants import *
+ */
+  __pyx_t_6 = __Pyx_Import(((PyObject *)__pyx_n_s__zmq), 0, -1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__zmq, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+
+  /* "zmq/core/socket.pyx":75
+ * 
+ * import zmq
+ * from zmq.core import constants             # <<<<<<<<<<<<<<
+ * from zmq.core.constants import *
+ * from zmq.core.checkrc cimport _check_rc
+ */
+  __pyx_t_6 = PyList_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__constants));
+  PyList_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_n_s__constants));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__constants));
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s_34), ((PyObject *)__pyx_t_6), -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+  __pyx_t_6 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s__constants); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__constants, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":76
+ * import zmq
+ * from zmq.core import constants
+ * from zmq.core.constants import *             # <<<<<<<<<<<<<<
+ * from zmq.core.checkrc cimport _check_rc
+ * from zmq.error import ZMQError, ZMQBindError
+ */
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s_36));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s_36));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s_36));
+  __pyx_t_6 = __Pyx_Import(((PyObject *)__pyx_n_s_35), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  if (__pyx_import_star(__pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+
+  /* "zmq/core/socket.pyx":78
+ * from zmq.core.constants import *
+ * from zmq.core.checkrc cimport _check_rc
+ * from zmq.error import ZMQError, ZMQBindError             # <<<<<<<<<<<<<<
+ * from zmq.utils.strtypes import bytes,unicode,basestring
+ * 
+ */
+  __pyx_t_6 = PyList_New(2); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQError));
+  PyList_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_n_s__ZMQError));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQError));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQBindError));
+  PyList_SET_ITEM(__pyx_t_6, 1, ((PyObject *)__pyx_n_s__ZMQBindError));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQBindError));
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s_26), ((PyObject *)__pyx_t_6), -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+  __pyx_t_6 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s__ZMQError); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ZMQError, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_6 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s__ZMQBindError); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ZMQBindError, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/socket.pyx":79
+ * from zmq.core.checkrc cimport _check_rc
+ * from zmq.error import ZMQError, ZMQBindError
+ * from zmq.utils.strtypes import bytes,unicode,basestring             # <<<<<<<<<<<<<<
+ * 
+ * #-----------------------------------------------------------------------------
+ */
+  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__bytes));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__bytes));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__bytes));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__unicode));
+  PyList_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_n_s__unicode));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__unicode));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__basestring));
+  PyList_SET_ITEM(__pyx_t_1, 2, ((PyObject *)__pyx_n_s__basestring));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__basestring));
+  __pyx_t_6 = __Pyx_Import(((PyObject *)__pyx_n_s_37), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_6, __pyx_n_s__bytes); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__bytes, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_6, __pyx_n_s__unicode); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__unicode, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_6, __pyx_n_s__basestring); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__basestring, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+
+  /* "zmq/core/socket.pyx":85
+ * #-----------------------------------------------------------------------------
+ * 
+ * IPC_PATH_MAX_LEN = get_ipc_path_max_len()             # <<<<<<<<<<<<<<
+ * 
+ * # inline some small socket submethods:
+ */
+  __pyx_t_6 = PyInt_FromLong(get_ipc_path_max_len()); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__IPC_PATH_MAX_LEN, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+
+  /* "zmq/core/socket.pyx":112
+ *     return False
+ * 
+ * cdef inline Frame _recv_frame(void *handle, int flags=0, track=False):             # <<<<<<<<<<<<<<
+ *     """Receive a message in a non-copying manner and return a Frame."""
+ *     cdef int rc
+ */
+  __pyx_t_6 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_k_1 = __pyx_t_6;
+  __Pyx_GIVEREF(__pyx_t_6);
+  __pyx_t_6 = 0;
+
+  /* "zmq/core/socket.pyx":233
+ * 
+ *     @property
+ *     def closed(self):             # <<<<<<<<<<<<<<
+ *         return _check_closed(self, False)
+ * 
+ */
+  __pyx_t_6 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3zmq_4core_6socket_Socket, __pyx_n_s__closed); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_6);
+  __Pyx_GIVEREF(__pyx_t_6);
+  __pyx_t_6 = 0;
+  __pyx_t_6 = PyObject_Call(__pyx_builtin_property, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3zmq_4core_6socket_Socket->tp_dict, __pyx_n_s__closed, __pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  PyType_Modified(__pyx_ptype_3zmq_4core_6socket_Socket);
+
+  /* "zmq/core/socket.pyx":530
+ *     #-------------------------------------------------------------------------
+ * 
+ *     cpdef object send(self, object data, int flags=0, copy=True, track=False):             # <<<<<<<<<<<<<<
+ *         """s.send(data, flags=0, copy=True, track=False)
+ * 
+ */
+  __pyx_t_6 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_k_18 = __pyx_t_6;
+  __Pyx_GIVEREF(__pyx_t_6);
+  __pyx_t_6 = 0;
+  __pyx_t_6 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_k_19 = __pyx_t_6;
+  __Pyx_GIVEREF(__pyx_t_6);
+  __pyx_t_6 = 0;
+
+  /* "zmq/core/socket.pyx":587
+ *             return _send_frame(self.handle, msg, flags)
+ * 
+ *     cpdef object recv(self, int flags=0, copy=True, track=False):             # <<<<<<<<<<<<<<
+ *         """s.recv(flags=0, copy=True, track=False)
+ * 
+ */
+  __pyx_t_6 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_k_24 = __pyx_t_6;
+  __Pyx_GIVEREF(__pyx_t_6);
+  __pyx_t_6 = 0;
+  __pyx_t_6 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __pyx_k_25 = __pyx_t_6;
+  __Pyx_GIVEREF(__pyx_t_6);
+  __pyx_t_6 = 0;
+
+  /* "zmq/core/socket.pyx":628
+ * 
+ * 
+ * __all__ = ['Socket', 'IPC_PATH_MAX_LEN']             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_6 = PyList_New(2); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__Socket));
+  PyList_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_n_s__Socket));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Socket));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__IPC_PATH_MAX_LEN));
+  PyList_SET_ITEM(__pyx_t_6, 1, ((PyObject *)__pyx_n_s__IPC_PATH_MAX_LEN));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__IPC_PATH_MAX_LEN));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_6)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+
+  /* "zmq/core/socket.pyx":1
+ * """0MQ Socket class."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_6 = PyDict_New(); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_6));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_6)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
+
+  /* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core.socket", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core.socket");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON
+    result = PyDict_GetItem(__pyx_d, name);
+    if (result) {
+        Py_INCREF(result);
+    } else {
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    if (!result) {
+        PyErr_Clear();
+#endif
+        result = __Pyx_GetBuiltinName(name);
+    }
+    return result;
+}
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_Restore(type, value, tb);
+#endif
+}
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(type, value, tb);
+#endif
+}
+
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
+    Py_XINCREF(type);
+    if (!value || value == Py_None)
+        value = NULL;
+    else
+        Py_INCREF(value);
+    if (!tb || tb == Py_None)
+        tb = NULL;
+    else {
+        Py_INCREF(tb);
+        if (!PyTraceBack_Check(tb)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: arg 3 must be a traceback or None");
+            goto raise_error;
+        }
+    }
+    #if PY_VERSION_HEX < 0x02050000
+    if (PyClass_Check(type)) {
+    #else
+    if (PyType_Check(type)) {
+    #endif
+#if CYTHON_COMPILING_IN_PYPY
+        if (!value) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+#endif
+        PyErr_NormalizeException(&type, &value, &tb);
+    } else {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        value = type;
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyInstance_Check(type)) {
+            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+            Py_INCREF(type);
+        } else {
+            type = 0;
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception must be an old-style class or instance");
+            goto raise_error;
+        }
+        #else
+        type = (PyObject*) Py_TYPE(type);
+        Py_INCREF(type);
+        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception class must be a subclass of BaseException");
+            goto raise_error;
+        }
+        #endif
+    }
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+#else /* Python 3+ */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    PyObject* owned_instance = NULL;
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
+    }
+    if (value == Py_None)
+        value = 0;
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (PyExceptionClass_Check(type)) {
+        PyObject *args;
+        if (!value)
+            args = PyTuple_New(0);
+        else if (PyTuple_Check(value)) {
+            Py_INCREF(value);
+            args = value;
+        } else
+            args = PyTuple_Pack(1, value);
+        if (!args)
+            goto bad;
+        owned_instance = PyEval_CallObject(type, args);
+        Py_DECREF(args);
+        if (!owned_instance)
+            goto bad;
+        value = owned_instance;
+        if (!PyExceptionInstance_Check(value)) {
+            PyErr_Format(PyExc_TypeError,
+                         "calling %R should have returned an instance of "
+                         "BaseException, not %R",
+                         type, Py_TYPE(value));
+            goto bad;
+        }
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
+    }
+#if PY_VERSION_HEX >= 0x03030000
+    if (cause) {
+#else
+    if (cause && cause != Py_None) {
+#endif
+        PyObject *fixed_cause;
+        if (cause == Py_None) {
+            fixed_cause = NULL;
+        } else if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        } else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+    PyErr_SetObject(type, value);
+    if (tb) {
+        PyThreadState *tstate = PyThreadState_GET();
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
+    }
+bad:
+    Py_XDECREF(owned_instance);
+    return;
+}
+#endif
+
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
+}
+
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name,
+    PyObject* kw_name)
+{
+    PyErr_Format(PyExc_TypeError,
+        #if PY_MAJOR_VERSION >= 3
+        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
+        #else
+        "%s() got multiple values for keyword argument '%s'", func_name,
+        PyString_AsString(kw_name));
+        #endif
+}
+
+static int __Pyx_ParseOptionalKeywords(
+    PyObject *kwds,
+    PyObject **argnames[],
+    PyObject *kwds2,
+    PyObject *values[],
+    Py_ssize_t num_pos_args,
+    const char* function_name)
+{
+    PyObject *key = 0, *value = 0;
+    Py_ssize_t pos = 0;
+    PyObject*** name;
+    PyObject*** first_kw_arg = argnames + num_pos_args;
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
+        name = first_kw_arg;
+        while (*name && (**name != key)) name++;
+        if (*name) {
+            values[name-argnames] = value;
+            continue;
+        }
+        name = first_kw_arg;
+        #if PY_MAJOR_VERSION < 3
+        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
+            while (*name) {
+                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
+                        && _PyString_Eq(**name, key)) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    if ((**argname == key) || (
+                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
+                             && _PyString_Eq(**argname, key))) {
+                        goto arg_passed_twice;
+                    }
+                    argname++;
+                }
+            }
+        } else
+        #endif
+        if (likely(PyUnicode_Check(key))) {
+            while (*name) {
+                int cmp = (**name == key) ? 0 :
+                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
+                #endif
+                    PyUnicode_Compare(**name, key);
+                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                if (cmp == 0) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    int cmp = (**argname == key) ? 0 :
+                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
+                    #endif
+                        PyUnicode_Compare(**argname, key);
+                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                    if (cmp == 0) goto arg_passed_twice;
+                    argname++;
+                }
+            }
+        } else
+            goto invalid_keyword_type;
+        if (kwds2) {
+            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+        } else {
+            goto invalid_keyword;
+        }
+    }
+    return 0;
+arg_passed_twice:
+    __Pyx_RaiseDoubleKeywordsError(function_name, key);
+    goto bad;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%s() keywords must be strings", function_name);
+    goto bad;
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%s() got an unexpected keyword argument '%s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+bad:
+    return -1;
+}
+
+static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
+    const char *name, int exact)
+{
+    if (!type) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (none_allowed && obj == Py_None) return 1;
+    else if (exact) {
+        if (Py_TYPE(obj) == type) return 1;
+    }
+    else {
+        if (PyObject_TypeCheck(obj, type)) return 1;
+    }
+    PyErr_Format(PyExc_TypeError,
+        "Argument '%s' has incorrect type (expected %s, got %s)",
+        name, type->tp_name, Py_TYPE(obj)->tp_name);
+    return 0;
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
+    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+        PyObject *r = PyList_GET_ITEM(o, i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
+    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+        PyObject *r = PyTuple_GET_ITEM(o, i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (is_list || PyList_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
+        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
+            PyObject *r = PyList_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    else if (PyTuple_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
+        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    } else {
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
+                if (likely(l >= 0)) {
+                    i += l;
+                } else {
+                    if (PyErr_ExceptionMatches(PyExc_OverflowError))
+                        PyErr_Clear();
+                    else
+                        return NULL;
+                }
+            }
+            return m->sq_item(o, i);
+        }
+    }
+#else
+    if (is_list || PySequence_Check(o)) {
+        return PySequence_GetItem(o, i);
+    }
+#endif
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
+
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    if (unlikely(!type)) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (likely(PyObject_TypeCheck(obj, type)))
+        return 1;
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
+    return 0;
+}
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
+    PyObject *local_type, *local_value, *local_tb;
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    local_type = tstate->curexc_type;
+    local_value = tstate->curexc_value;
+    local_tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(&local_type, &local_value, &local_tb);
+#endif
+    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (unlikely(tstate->curexc_type))
+#else
+    if (unlikely(PyErr_Occurred()))
+#endif
+        goto bad;
+    #if PY_MAJOR_VERSION >= 3
+    if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
+        goto bad;
+    #endif
+    Py_INCREF(local_type);
+    Py_INCREF(local_value);
+    Py_INCREF(local_tb);
+    *type = local_type;
+    *value = local_value;
+    *tb = local_tb;
+#if CYTHON_COMPILING_IN_CPYTHON
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = local_type;
+    tstate->exc_value = local_value;
+    tstate->exc_traceback = local_tb;
+    /* Make sure tstate is in a consistent state when we XDECREF
+       these objects (DECREF may run arbitrary code). */
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(local_type, local_value, local_tb);
+#endif
+    return 0;
+bad:
+    *type = 0;
+    *value = 0;
+    *tb = 0;
+    Py_XDECREF(local_type);
+    Py_XDECREF(local_value);
+    Py_XDECREF(local_tb);
+    return -1;
+}
+
+static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name) {
+    PyObject *result;
+    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
+    if (!result)
+        result = __Pyx_GetModuleGlobalName(name);
+    return result;
+}
+
+static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+#else
+    PyErr_GetExcInfo(type, value, tb);
+#endif
+}
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(type, value, tb);
+#endif
+}
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_VERSION_HEX < 0x03030000
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    #if PY_VERSION_HEX >= 0x02050000
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if (strchr(__Pyx_MODULE_NAME, '.')) {
+                #if PY_VERSION_HEX < 0x03030000
+                PyObject *py_level = PyInt_FromLong(1);
+                if (!py_level)
+                    goto bad;
+                module = PyObject_CallFunctionObjArgs(py_import,
+                    name, global_dict, empty_dict, list, py_level, NULL);
+                Py_DECREF(py_level);
+                #else
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                #endif
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0; /* try absolute import on failure */
+        }
+        #endif
+        if (!module) {
+            #if PY_VERSION_HEX < 0x03030000
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+    #else
+    if (level>0) {
+        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
+        goto bad;
+    }
+    module = PyObject_CallFunctionObjArgs(py_import,
+        name, global_dict, empty_dict, list, NULL);
+    #endif
+bad:
+    #if PY_VERSION_HEX < 0x03030000
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static CYTHON_INLINE pyzmq_int64_t __Pyx_PyInt_from_py_pyzmq_int64_t(PyObject* x) {
+    const pyzmq_int64_t neg_one = (pyzmq_int64_t)-1, const_zero = (pyzmq_int64_t)0;
+    const int is_unsigned = const_zero < neg_one;
+    if (sizeof(pyzmq_int64_t) == sizeof(char)) {
+        if (is_unsigned)
+            return (pyzmq_int64_t)__Pyx_PyInt_AsUnsignedChar(x);
+        else
+            return (pyzmq_int64_t)__Pyx_PyInt_AsSignedChar(x);
+    } else if (sizeof(pyzmq_int64_t) == sizeof(short)) {
+        if (is_unsigned)
+            return (pyzmq_int64_t)__Pyx_PyInt_AsUnsignedShort(x);
+        else
+            return (pyzmq_int64_t)__Pyx_PyInt_AsSignedShort(x);
+    } else if (sizeof(pyzmq_int64_t) == sizeof(int)) {
+        if (is_unsigned)
+            return (pyzmq_int64_t)__Pyx_PyInt_AsUnsignedInt(x);
+        else
+            return (pyzmq_int64_t)__Pyx_PyInt_AsSignedInt(x);
+    } else if (sizeof(pyzmq_int64_t) == sizeof(long)) {
+        if (is_unsigned)
+            return (pyzmq_int64_t)__Pyx_PyInt_AsUnsignedLong(x);
+        else
+            return (pyzmq_int64_t)__Pyx_PyInt_AsSignedLong(x);
+    } else if (sizeof(pyzmq_int64_t) == sizeof(PY_LONG_LONG)) {
+        if (is_unsigned)
+            return (pyzmq_int64_t)__Pyx_PyInt_AsUnsignedLongLong(x);
+        else
+            return (pyzmq_int64_t)__Pyx_PyInt_AsSignedLongLong(x);
+    }  else {
+        #if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+        PyErr_SetString(PyExc_RuntimeError,
+                        "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+        #else
+        pyzmq_int64_t val;
+        PyObject *v = __Pyx_PyNumber_Int(x);
+        #if PY_MAJOR_VERSION < 3
+        if (likely(v) && !PyLong_Check(v)) {
+            PyObject *tmp = v;
+            v = PyNumber_Long(tmp);
+            Py_DECREF(tmp);
+        }
+        #endif
+        if (likely(v)) {
+            int one = 1; int is_little = (int)*(unsigned char *)&one;
+            unsigned char *bytes = (unsigned char *)&val;
+            int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                          bytes, sizeof(val),
+                                          is_little, !is_unsigned);
+            Py_DECREF(v);
+            if (likely(!ret))
+                return val;
+        }
+        #endif
+        return (pyzmq_int64_t)-1;
+    }
+}
+
+static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_pyzmq_int64_t(pyzmq_int64_t val) {
+    const pyzmq_int64_t neg_one = (pyzmq_int64_t)-1, const_zero = (pyzmq_int64_t)0;
+    const int is_unsigned = const_zero < neg_one;
+    if ((sizeof(pyzmq_int64_t) == sizeof(char))  ||
+        (sizeof(pyzmq_int64_t) == sizeof(short))) {
+        return PyInt_FromLong((long)val);
+    } else if ((sizeof(pyzmq_int64_t) == sizeof(int)) ||
+               (sizeof(pyzmq_int64_t) == sizeof(long))) {
+        if (is_unsigned)
+            return PyLong_FromUnsignedLong((unsigned long)val);
+        else
+            return PyInt_FromLong((long)val);
+    } else if (sizeof(pyzmq_int64_t) == sizeof(PY_LONG_LONG)) {
+        if (is_unsigned)
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
+        else
+            return PyLong_FromLongLong((PY_LONG_LONG)val);
+    } else {
+        int one = 1; int little = (int)*(unsigned char *)&one;
+        unsigned char *bytes = (unsigned char *)&val;
+        return _PyLong_FromByteArray(bytes, sizeof(pyzmq_int64_t),
+                                     little, !is_unsigned);
+    }
+}
+
+static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_ZMQ_FD_T(ZMQ_FD_T val) {
+    const ZMQ_FD_T neg_one = (ZMQ_FD_T)-1, const_zero = (ZMQ_FD_T)0;
+    const int is_unsigned = const_zero < neg_one;
+    if ((sizeof(ZMQ_FD_T) == sizeof(char))  ||
+        (sizeof(ZMQ_FD_T) == sizeof(short))) {
+        return PyInt_FromLong((long)val);
+    } else if ((sizeof(ZMQ_FD_T) == sizeof(int)) ||
+               (sizeof(ZMQ_FD_T) == sizeof(long))) {
+        if (is_unsigned)
+            return PyLong_FromUnsignedLong((unsigned long)val);
+        else
+            return PyInt_FromLong((long)val);
+    } else if (sizeof(ZMQ_FD_T) == sizeof(PY_LONG_LONG)) {
+        if (is_unsigned)
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
+        else
+            return PyLong_FromLongLong((PY_LONG_LONG)val);
+    } else {
+        int one = 1; int little = (int)*(unsigned char *)&one;
+        unsigned char *bytes = (unsigned char *)&val;
+        return _PyLong_FromByteArray(bytes, sizeof(ZMQ_FD_T),
+                                     little, !is_unsigned);
+    }
+}
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static CYTHON_INLINE int __Pyx_StrEq(const char *s1, const char *s2) {
+     while (*s1 != '\0' && *s1 == *s2) { s1++; s2++; }
+     return *s1 == *s2;
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
+#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
+    PyObject *ob = PyCapsule_New(vtable, 0, 0);
+#else
+    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
+#endif
+    if (!ob)
+        goto bad;
+    if (PyDict_SetItemString(dict, "__pyx_vtable__", ob) < 0)
+        goto bad;
+    Py_DECREF(ob);
+    return 0;
+bad:
+    Py_XDECREF(ob);
+    return -1;
+}
+
+#ifndef __PYX_HAVE_RT_ImportModule
+#define __PYX_HAVE_RT_ImportModule
+static PyObject *__Pyx_ImportModule(const char *name) {
+    PyObject *py_name = 0;
+    PyObject *py_module = 0;
+    py_name = __Pyx_PyIdentifier_FromString(name);
+    if (!py_name)
+        goto bad;
+    py_module = PyImport_Import(py_name);
+    Py_DECREF(py_name);
+    return py_module;
+bad:
+    Py_XDECREF(py_name);
+    return 0;
+}
+#endif
+
+#ifndef __PYX_HAVE_RT_ImportType
+#define __PYX_HAVE_RT_ImportType
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
+    size_t size, int strict)
+{
+    PyObject *py_module = 0;
+    PyObject *result = 0;
+    PyObject *py_name = 0;
+    char warning[200];
+    Py_ssize_t basicsize;
+#ifdef Py_LIMITED_API
+    PyObject *py_basicsize;
+#endif
+    py_module = __Pyx_ImportModule(module_name);
+    if (!py_module)
+        goto bad;
+    py_name = __Pyx_PyIdentifier_FromString(class_name);
+    if (!py_name)
+        goto bad;
+    result = PyObject_GetAttr(py_module, py_name);
+    Py_DECREF(py_name);
+    py_name = 0;
+    Py_DECREF(py_module);
+    py_module = 0;
+    if (!result)
+        goto bad;
+    if (!PyType_Check(result)) {
+        PyErr_Format(PyExc_TypeError,
+            "%s.%s is not a type object",
+            module_name, class_name);
+        goto bad;
+    }
+#ifndef Py_LIMITED_API
+    basicsize = ((PyTypeObject *)result)->tp_basicsize;
+#else
+    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
+    if (!py_basicsize)
+        goto bad;
+    basicsize = PyLong_AsSsize_t(py_basicsize);
+    Py_DECREF(py_basicsize);
+    py_basicsize = 0;
+    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
+#endif
+    if (!strict && (size_t)basicsize > size) {
+        PyOS_snprintf(warning, sizeof(warning),
+            "%s.%s size changed, may indicate binary incompatibility",
+            module_name, class_name);
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyErr_Warn(NULL, warning) < 0) goto bad;
+        #else
+        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
+        #endif
+    }
+    else if ((size_t)basicsize != size) {
+        PyErr_Format(PyExc_ValueError,
+            "%s.%s has the wrong size, try recompiling",
+            module_name, class_name);
+        goto bad;
+    }
+    return (PyTypeObject *)result;
+bad:
+    Py_XDECREF(py_module);
+    Py_XDECREF(result);
+    return NULL;
+}
+#endif
+
+static void* __Pyx_GetVtable(PyObject *dict) {
+    void* ptr;
+    PyObject *ob = PyMapping_GetItemString(dict, (char *)"__pyx_vtable__");
+    if (!ob)
+        goto bad;
+#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
+    ptr = PyCapsule_GetPointer(ob, 0);
+#else
+    ptr = PyCObject_AsVoidPtr(ob);
+#endif
+    if (!ptr && !PyErr_Occurred())
+        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
+    Py_DECREF(ob);
+    return ptr;
+bad:
+    Py_XDECREF(ob);
+    return NULL;
+}
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
--- /dev/null
+++ pyzmq-13.1.0/zmq/core/_poll.c
@@ -0,0 +1,4802 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core___poll
+#define __PYX_HAVE_API__zmq__core___poll
+#include "string.h"
+#include "stdlib.h"
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#include "errno.h"
+#include "stdio.h"
+#include "pythread.h"
+#include "datetime.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "_poll.pyx",
+  "checkrc.pxd",
+  "datetime.pxd",
+  "context.pxd",
+  "socket.pxd",
+  "type.pxd",
+  "bool.pxd",
+  "complex.pxd",
+};
+
+/*--- Type declarations ---*/
+struct __pyx_obj_3zmq_4core_6socket_Socket;
+struct __pyx_obj_3zmq_4core_7context_Context;
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send;
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv;
+
+/* "socket.pxd":46
+ * 
+ *     # cpdef methods for direct-cython access:
+ *     cpdef object send(self, object data, int flags=*, copy=*, track=*)             # <<<<<<<<<<<<<<
+ *     cpdef object recv(self, int flags=*, copy=*, track=*)
+ * 
+ */
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send {
+  int __pyx_n;
+  int flags;
+  PyObject *copy;
+  PyObject *track;
+};
+
+/* "socket.pxd":47
+ *     # cpdef methods for direct-cython access:
+ *     cpdef object send(self, object data, int flags=*, copy=*, track=*)
+ *     cpdef object recv(self, int flags=*, copy=*, track=*)             # <<<<<<<<<<<<<<
+ * 
+ */
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv {
+  int __pyx_n;
+  int flags;
+  PyObject *copy;
+  PyObject *track;
+};
+
+/* "socket.pxd":33
+ * 
+ * 
+ * cdef class Socket:             # <<<<<<<<<<<<<<
+ *     """A 0MQ socket."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_6socket_Socket {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_6socket_Socket *__pyx_vtab;
+  PyObject *__weakref__;
+  void *handle;
+  int socket_type;
+  struct __pyx_obj_3zmq_4core_7context_Context *context;
+  int _closed;
+  int _pid;
+};
+
+
+/* "context.pxd":26
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class Context:             # <<<<<<<<<<<<<<
+ *     """Manage the lifecycle of a 0MQ context."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_7context_Context {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_7context_Context *__pyx_vtab;
+  PyObject *__weakref__;
+  void *handle;
+  void **_sockets;
+  size_t _n_sockets;
+  size_t _max_sockets;
+  int _pid;
+  PyObject *closed;
+};
+
+
+
+/* "socket.pxd":33
+ * 
+ * 
+ * cdef class Socket:             # <<<<<<<<<<<<<<
+ *     """A 0MQ socket."""
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_6socket_Socket {
+  PyObject *(*send)(struct __pyx_obj_3zmq_4core_6socket_Socket *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send *__pyx_optional_args);
+  PyObject *(*recv)(struct __pyx_obj_3zmq_4core_6socket_Socket *, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv *__pyx_optional_args);
+};
+static struct __pyx_vtabstruct_3zmq_4core_6socket_Socket *__pyx_vtabptr_3zmq_4core_6socket_Socket;
+
+
+/* "context.pxd":26
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class Context:             # <<<<<<<<<<<<<<
+ *     """Manage the lifecycle of a 0MQ context."""
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_7context_Context {
+  void (*_add_socket)(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+  void (*_remove_socket)(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+};
+static struct __pyx_vtabstruct_3zmq_4core_7context_Context *__pyx_vtabptr_3zmq_4core_7context_Context;
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/
+
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
+    const char* function_name); /*proto*/
+
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
+
+#define __Pyx_GetItemInt(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_Fast(o, i, is_list, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+#define __Pyx_GetItemInt_List(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_List_Fast(o, i, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+#define __Pyx_GetItemInt_Tuple(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_Tuple_Fast(o, i, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck);
+
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
+    PyListObject* L = (PyListObject*) list;
+    Py_ssize_t len = Py_SIZE(list);
+    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
+        Py_INCREF(x);
+        PyList_SET_ITEM(list, len, x);
+        Py_SIZE(list) = len+1;
+        return 0;
+    }
+    return PyList_Append(list, x);
+}
+#else
+#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
+#endif
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+
+#ifndef __PYX_FORCE_INIT_THREADS
+  #define __PYX_FORCE_INIT_THREADS 0
+#endif
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static int __Pyx_check_binary_version(void);
+
+#if !defined(__Pyx_PyIdentifier_FromString)
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
+#else
+  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
+#endif
+#endif
+
+static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
+
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/
+
+static void* __Pyx_GetVtable(PyObject *dict); /*proto*/
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'libc.string' */
+
+/* Module declarations from 'libc.stdlib' */
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'zmq.core.context' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_7context_Context = 0;
+
+/* Module declarations from 'zmq.core.socket' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_6socket_Socket = 0;
+
+/* Module declarations from 'libc.errno' */
+
+/* Module declarations from 'cpython.version' */
+
+/* Module declarations from 'cpython.ref' */
+
+/* Module declarations from 'cpython.exc' */
+
+/* Module declarations from 'cpython.module' */
+
+/* Module declarations from 'cpython.mem' */
+
+/* Module declarations from 'cpython.tuple' */
+
+/* Module declarations from 'cpython.list' */
+
+/* Module declarations from 'libc.stdio' */
+
+/* Module declarations from 'cpython.object' */
+
+/* Module declarations from 'cpython.sequence' */
+
+/* Module declarations from 'cpython.mapping' */
+
+/* Module declarations from 'cpython.iterator' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.type' */
+static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
+
+/* Module declarations from 'cpython.number' */
+
+/* Module declarations from 'cpython.int' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.bool' */
+static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;
+
+/* Module declarations from 'cpython.long' */
+
+/* Module declarations from 'cpython.float' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.complex' */
+static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;
+
+/* Module declarations from 'cpython.string' */
+
+/* Module declarations from 'cpython.unicode' */
+
+/* Module declarations from 'cpython.dict' */
+
+/* Module declarations from 'cpython.instance' */
+
+/* Module declarations from 'cpython.function' */
+
+/* Module declarations from 'cpython.method' */
+
+/* Module declarations from 'cpython.weakref' */
+
+/* Module declarations from 'cpython.getargs' */
+
+/* Module declarations from 'cpython.pythread' */
+
+/* Module declarations from 'cpython.pystate' */
+
+/* Module declarations from 'cpython.cobject' */
+
+/* Module declarations from 'cpython.oldbuffer' */
+
+/* Module declarations from 'cpython.set' */
+
+/* Module declarations from 'cpython.buffer' */
+
+/* Module declarations from 'cpython.bytes' */
+
+/* Module declarations from 'cpython.pycapsule' */
+
+/* Module declarations from 'datetime' */
+
+/* Module declarations from 'cpython.datetime' */
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_date = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_time = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_datetime = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_timedelta = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_tzinfo = 0;
+
+/* Module declarations from 'cpython' */
+
+/* Module declarations from 'zmq.core.checkrc' */
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int); /*proto*/
+
+/* Module declarations from 'zmq.core._poll' */
+#define __Pyx_MODULE_NAME "zmq.core._poll"
+int __pyx_module_is_main_zmq__core___poll = 0;
+
+/* Implementation of 'zmq.core._poll' */
+static PyObject *__pyx_builtin_MemoryError;
+static PyObject *__pyx_builtin_range;
+static PyObject *__pyx_builtin_ValueError;
+static PyObject *__pyx_builtin_TypeError;
+static PyObject *__pyx_pf_3zmq_4core_5_poll_zmq_poll(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_sockets, long __pyx_v_timeout); /* proto */
+static char __pyx_k_1[] = "Could not allocate poll items";
+static char __pyx_k_3[] = "fileno() must return an valid integer fd";
+static char __pyx_k_5[] = "Socket must be a 0MQ socket, an integer fd or have a fileno() method: %r";
+static char __pyx_k_6[] = "zmq.error";
+static char __pyx_k_7[] = "0MQ polling related functions and classes.";
+static char __pyx_k_10[] = "/private/tmp/pyzmq/zmq/core/_poll.pyx";
+static char __pyx_k_11[] = "zmq.core._poll";
+static char __pyx_k__i[] = "i";
+static char __pyx_k__s[] = "s";
+static char __pyx_k__rc[] = "rc";
+static char __pyx_k__sys[] = "sys";
+static char __pyx_k__Again[] = "Again";
+static char __pyx_k__int_t[] = "int_t";
+static char __pyx_k__range[] = "range";
+static char __pyx_k__events[] = "events";
+static char __pyx_k__fileno[] = "fileno";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k__results[] = "results";
+static char __pyx_k__revents[] = "revents";
+static char __pyx_k__sockets[] = "sockets";
+static char __pyx_k__timeout[] = "timeout";
+static char __pyx_k__ZMQError[] = "ZMQError";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__nsockets[] = "nsockets";
+static char __pyx_k__zmq_poll[] = "zmq_poll";
+static char __pyx_k__TypeError[] = "TypeError";
+static char __pyx_k__pollitems[] = "pollitems";
+static char __pyx_k__ValueError[] = "ValueError";
+static char __pyx_k____import__[] = "__import__";
+static char __pyx_k__MemoryError[] = "MemoryError";
+static char __pyx_k__version_info[] = "version_info";
+static char __pyx_k__current_socket[] = "current_socket";
+static char __pyx_k__ContextTerminated[] = "ContextTerminated";
+static PyObject *__pyx_kp_s_1;
+static PyObject *__pyx_kp_s_10;
+static PyObject *__pyx_n_s_11;
+static PyObject *__pyx_kp_s_3;
+static PyObject *__pyx_kp_s_5;
+static PyObject *__pyx_n_s_6;
+static PyObject *__pyx_n_s__Again;
+static PyObject *__pyx_n_s__ContextTerminated;
+static PyObject *__pyx_n_s__MemoryError;
+static PyObject *__pyx_n_s__TypeError;
+static PyObject *__pyx_n_s__ValueError;
+static PyObject *__pyx_n_s__ZMQError;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____import__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s__current_socket;
+static PyObject *__pyx_n_s__events;
+static PyObject *__pyx_n_s__fileno;
+static PyObject *__pyx_n_s__i;
+static PyObject *__pyx_n_s__int_t;
+static PyObject *__pyx_n_s__nsockets;
+static PyObject *__pyx_n_s__pollitems;
+static PyObject *__pyx_n_s__range;
+static PyObject *__pyx_n_s__rc;
+static PyObject *__pyx_n_s__results;
+static PyObject *__pyx_n_s__revents;
+static PyObject *__pyx_n_s__s;
+static PyObject *__pyx_n_s__sockets;
+static PyObject *__pyx_n_s__sys;
+static PyObject *__pyx_n_s__timeout;
+static PyObject *__pyx_n_s__version_info;
+static PyObject *__pyx_n_s__zmq_poll;
+static PyObject *__pyx_int_3;
+static PyObject *__pyx_k_tuple_2;
+static PyObject *__pyx_k_tuple_4;
+static PyObject *__pyx_k_tuple_8;
+static PyObject *__pyx_k_codeobj_9;
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_5_poll_1zmq_poll(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_5_poll_zmq_poll[] = "zmq_poll(sockets, timeout=-1)\n\n    Poll a set of 0MQ sockets, native file descs. or sockets.\n\n    Parameters\n    ----------\n    sockets : list of tuples of (socket, flags)\n        Each element of this list is a two-tuple containing a socket\n        and a flags. The socket may be a 0MQ socket or any object with\n        a ``fileno()`` method. The flags can be zmq.POLLIN (for detecting\n        for incoming messages), zmq.POLLOUT (for detecting that send is OK)\n        or zmq.POLLIN|zmq.POLLOUT for detecting both.\n    timeout : int\n        The number of milliseconds to poll for. Negative means no timeout.\n    ";
+static PyMethodDef __pyx_mdef_3zmq_4core_5_poll_1zmq_poll = {__Pyx_NAMESTR("zmq_poll"), (PyCFunction)__pyx_pw_3zmq_4core_5_poll_1zmq_poll, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_5_poll_zmq_poll)};
+static PyObject *__pyx_pw_3zmq_4core_5_poll_1zmq_poll(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_sockets = 0;
+  long __pyx_v_timeout;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("zmq_poll (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__sockets,&__pyx_n_s__timeout,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__sockets)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeout);
+          if (value) { values[1] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "zmq_poll") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_sockets = values[0];
+    if (values[1]) {
+      __pyx_v_timeout = __Pyx_PyInt_AsLong(values[1]); if (unlikely((__pyx_v_timeout == (long)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    } else {
+      __pyx_v_timeout = ((long)-1);
+    }
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("zmq_poll", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core._poll.zmq_poll", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_5_poll_zmq_poll(__pyx_self, __pyx_v_sockets, __pyx_v_timeout);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/_poll.pyx":46
+ *     int_t = (int,long)
+ * 
+ * def zmq_poll(sockets, long timeout=-1):             # <<<<<<<<<<<<<<
+ *     """zmq_poll(sockets, timeout=-1)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_5_poll_zmq_poll(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_sockets, long __pyx_v_timeout) {
+  int __pyx_v_rc;
+  int __pyx_v_i;
+  zmq_pollitem_t *__pyx_v_pollitems;
+  int __pyx_v_nsockets;
+  struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_current_socket = 0;
+  PyObject *__pyx_v_s = NULL;
+  PyObject *__pyx_v_events = NULL;
+  PyObject *__pyx_v_fileno = NULL;
+  PyObject *__pyx_v_results = NULL;
+  short __pyx_v_revents;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  Py_ssize_t __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  void *__pyx_t_7;
+  short __pyx_t_8;
+  int __pyx_t_9;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  PyObject *__pyx_t_13 = NULL;
+  PyObject *__pyx_t_14 = NULL;
+  int __pyx_t_15;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("zmq_poll", 0);
+
+  /* "zmq/core/_poll.pyx":63
+ *     """
+ *     cdef int rc, i
+ *     cdef zmq_pollitem_t *pollitems = NULL             # <<<<<<<<<<<<<<
+ *     cdef int nsockets = <int>len(sockets)
+ *     cdef Socket current_socket
+ */
+  __pyx_v_pollitems = NULL;
+
+  /* "zmq/core/_poll.pyx":64
+ *     cdef int rc, i
+ *     cdef zmq_pollitem_t *pollitems = NULL
+ *     cdef int nsockets = <int>len(sockets)             # <<<<<<<<<<<<<<
+ *     cdef Socket current_socket
+ * 
+ */
+  __pyx_t_1 = PyObject_Length(__pyx_v_sockets); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_nsockets = ((int)__pyx_t_1);
+
+  /* "zmq/core/_poll.pyx":67
+ *     cdef Socket current_socket
+ * 
+ *     if nsockets == 0:             # <<<<<<<<<<<<<<
+ *         return []
+ * 
+ */
+  __pyx_t_2 = (__pyx_v_nsockets == 0);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/_poll.pyx":68
+ * 
+ *     if nsockets == 0:
+ *         return []             # <<<<<<<<<<<<<<
+ * 
+ *     pollitems = <zmq_pollitem_t *>malloc(nsockets*sizeof(zmq_pollitem_t))
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = ((PyObject *)__pyx_t_3);
+    __pyx_t_3 = 0;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/_poll.pyx":70
+ *         return []
+ * 
+ *     pollitems = <zmq_pollitem_t *>malloc(nsockets*sizeof(zmq_pollitem_t))             # <<<<<<<<<<<<<<
+ *     if pollitems == NULL:
+ *         raise MemoryError("Could not allocate poll items")
+ */
+  __pyx_v_pollitems = ((zmq_pollitem_t *)malloc((__pyx_v_nsockets * (sizeof(zmq_pollitem_t)))));
+
+  /* "zmq/core/_poll.pyx":71
+ * 
+ *     pollitems = <zmq_pollitem_t *>malloc(nsockets*sizeof(zmq_pollitem_t))
+ *     if pollitems == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError("Could not allocate poll items")
+ * 
+ */
+  __pyx_t_2 = (__pyx_v_pollitems == NULL);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/_poll.pyx":72
+ *     pollitems = <zmq_pollitem_t *>malloc(nsockets*sizeof(zmq_pollitem_t))
+ *     if pollitems == NULL:
+ *         raise MemoryError("Could not allocate poll items")             # <<<<<<<<<<<<<<
+ * 
+ *     if ZMQ_VERSION_MAJOR < 3:
+ */
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_MemoryError, ((PyObject *)__pyx_k_tuple_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/_poll.pyx":74
+ *         raise MemoryError("Could not allocate poll items")
+ * 
+ *     if ZMQ_VERSION_MAJOR < 3:             # <<<<<<<<<<<<<<
+ *         # timeout is us in 2.x, ms in 3.x
+ *         # expected input is ms (matches 3.x)
+ */
+  __pyx_t_2 = (ZMQ_VERSION_MAJOR < 3);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/_poll.pyx":77
+ *         # timeout is us in 2.x, ms in 3.x
+ *         # expected input is ms (matches 3.x)
+ *         timeout = 1000*timeout             # <<<<<<<<<<<<<<
+ * 
+ *     for i in range(nsockets):
+ */
+    __pyx_v_timeout = (1000 * __pyx_v_timeout);
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
+
+  /* "zmq/core/_poll.pyx":79
+ *         timeout = 1000*timeout
+ * 
+ *     for i in range(nsockets):             # <<<<<<<<<<<<<<
+ *         s = sockets[i][0]
+ *         events = sockets[i][1]
+ */
+  __pyx_t_4 = __pyx_v_nsockets;
+  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
+    __pyx_v_i = __pyx_t_5;
+
+    /* "zmq/core/_poll.pyx":80
+ * 
+ *     for i in range(nsockets):
+ *         s = sockets[i][0]             # <<<<<<<<<<<<<<
+ *         events = sockets[i][1]
+ *         if isinstance(s, Socket):
+ */
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_sockets, __pyx_v_i, sizeof(int), PyInt_FromLong, 0, 1, 1); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_6 = __Pyx_GetItemInt(__pyx_t_3, 0, sizeof(long), PyInt_FromLong, 0, 0, 1); if (!__pyx_t_6) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_XDECREF(__pyx_v_s);
+    __pyx_v_s = __pyx_t_6;
+    __pyx_t_6 = 0;
+
+    /* "zmq/core/_poll.pyx":81
+ *     for i in range(nsockets):
+ *         s = sockets[i][0]
+ *         events = sockets[i][1]             # <<<<<<<<<<<<<<
+ *         if isinstance(s, Socket):
+ *             current_socket = s
+ */
+    __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_sockets, __pyx_v_i, sizeof(int), PyInt_FromLong, 0, 1, 1); if (!__pyx_t_6) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_6, 1, sizeof(long), PyInt_FromLong, 0, 0, 1); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_XDECREF(__pyx_v_events);
+    __pyx_v_events = __pyx_t_3;
+    __pyx_t_3 = 0;
+
+    /* "zmq/core/_poll.pyx":82
+ *         s = sockets[i][0]
+ *         events = sockets[i][1]
+ *         if isinstance(s, Socket):             # <<<<<<<<<<<<<<
+ *             current_socket = s
+ *             pollitems[i].socket = current_socket.handle
+ */
+    __pyx_t_2 = __Pyx_TypeCheck(__pyx_v_s, ((PyObject*)__pyx_ptype_3zmq_4core_6socket_Socket)); 
+    if (__pyx_t_2) {
+
+      /* "zmq/core/_poll.pyx":83
+ *         events = sockets[i][1]
+ *         if isinstance(s, Socket):
+ *             current_socket = s             # <<<<<<<<<<<<<<
+ *             pollitems[i].socket = current_socket.handle
+ *             pollitems[i].events = events
+ */
+      if (!(likely(((__pyx_v_s) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_s, __pyx_ptype_3zmq_4core_6socket_Socket))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_INCREF(__pyx_v_s);
+      __Pyx_XDECREF(((PyObject *)__pyx_v_current_socket));
+      __pyx_v_current_socket = ((struct __pyx_obj_3zmq_4core_6socket_Socket *)__pyx_v_s);
+
+      /* "zmq/core/_poll.pyx":84
+ *         if isinstance(s, Socket):
+ *             current_socket = s
+ *             pollitems[i].socket = current_socket.handle             # <<<<<<<<<<<<<<
+ *             pollitems[i].events = events
+ *             pollitems[i].revents = 0
+ */
+      __pyx_t_7 = __pyx_v_current_socket->handle;
+      (__pyx_v_pollitems[__pyx_v_i]).socket = __pyx_t_7;
+
+      /* "zmq/core/_poll.pyx":85
+ *             current_socket = s
+ *             pollitems[i].socket = current_socket.handle
+ *             pollitems[i].events = events             # <<<<<<<<<<<<<<
+ *             pollitems[i].revents = 0
+ *         elif isinstance(s, int_t):
+ */
+      __pyx_t_8 = __Pyx_PyInt_AsShort(__pyx_v_events); if (unlikely((__pyx_t_8 == (short)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      (__pyx_v_pollitems[__pyx_v_i]).events = __pyx_t_8;
+
+      /* "zmq/core/_poll.pyx":86
+ *             pollitems[i].socket = current_socket.handle
+ *             pollitems[i].events = events
+ *             pollitems[i].revents = 0             # <<<<<<<<<<<<<<
+ *         elif isinstance(s, int_t):
+ *             pollitems[i].socket = NULL
+ */
+      (__pyx_v_pollitems[__pyx_v_i]).revents = 0;
+      goto __pyx_L8;
+    }
+
+    /* "zmq/core/_poll.pyx":87
+ *             pollitems[i].events = events
+ *             pollitems[i].revents = 0
+ *         elif isinstance(s, int_t):             # <<<<<<<<<<<<<<
+ *             pollitems[i].socket = NULL
+ *             pollitems[i].fd = s
+ */
+    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__int_t); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = PyObject_IsInstance(__pyx_v_s, __pyx_t_3); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (__pyx_t_2) {
+
+      /* "zmq/core/_poll.pyx":88
+ *             pollitems[i].revents = 0
+ *         elif isinstance(s, int_t):
+ *             pollitems[i].socket = NULL             # <<<<<<<<<<<<<<
+ *             pollitems[i].fd = s
+ *             pollitems[i].events = events
+ */
+      (__pyx_v_pollitems[__pyx_v_i]).socket = NULL;
+
+      /* "zmq/core/_poll.pyx":89
+ *         elif isinstance(s, int_t):
+ *             pollitems[i].socket = NULL
+ *             pollitems[i].fd = s             # <<<<<<<<<<<<<<
+ *             pollitems[i].events = events
+ *             pollitems[i].revents = 0
+ */
+      __pyx_t_9 = __Pyx_PyInt_AsInt(__pyx_v_s); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      (__pyx_v_pollitems[__pyx_v_i]).fd = __pyx_t_9;
+
+      /* "zmq/core/_poll.pyx":90
+ *             pollitems[i].socket = NULL
+ *             pollitems[i].fd = s
+ *             pollitems[i].events = events             # <<<<<<<<<<<<<<
+ *             pollitems[i].revents = 0
+ *         elif hasattr(s, 'fileno'):
+ */
+      __pyx_t_8 = __Pyx_PyInt_AsShort(__pyx_v_events); if (unlikely((__pyx_t_8 == (short)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      (__pyx_v_pollitems[__pyx_v_i]).events = __pyx_t_8;
+
+      /* "zmq/core/_poll.pyx":91
+ *             pollitems[i].fd = s
+ *             pollitems[i].events = events
+ *             pollitems[i].revents = 0             # <<<<<<<<<<<<<<
+ *         elif hasattr(s, 'fileno'):
+ *             try:
+ */
+      (__pyx_v_pollitems[__pyx_v_i]).revents = 0;
+      goto __pyx_L8;
+    }
+
+    /* "zmq/core/_poll.pyx":92
+ *             pollitems[i].events = events
+ *             pollitems[i].revents = 0
+ *         elif hasattr(s, 'fileno'):             # <<<<<<<<<<<<<<
+ *             try:
+ *                 fileno = int(s.fileno())
+ */
+    __pyx_t_2 = PyObject_HasAttr(__pyx_v_s, ((PyObject *)__pyx_n_s__fileno)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_2) {
+
+      /* "zmq/core/_poll.pyx":93
+ *             pollitems[i].revents = 0
+ *         elif hasattr(s, 'fileno'):
+ *             try:             # <<<<<<<<<<<<<<
+ *                 fileno = int(s.fileno())
+ *             except:
+ */
+      {
+        __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
+        __Pyx_XGOTREF(__pyx_t_10);
+        __Pyx_XGOTREF(__pyx_t_11);
+        __Pyx_XGOTREF(__pyx_t_12);
+        /*try:*/ {
+
+          /* "zmq/core/_poll.pyx":94
+ *         elif hasattr(s, 'fileno'):
+ *             try:
+ *                 fileno = int(s.fileno())             # <<<<<<<<<<<<<<
+ *             except:
+ *                 free(pollitems)
+ */
+          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s__fileno); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
+          __Pyx_GOTREF(__pyx_t_3);
+          __pyx_t_6 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
+          __Pyx_GOTREF(__pyx_t_6);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
+          __Pyx_GOTREF(__pyx_t_3);
+          PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_6);
+          __Pyx_GIVEREF(__pyx_t_6);
+          __pyx_t_6 = 0;
+          __pyx_t_6 = PyObject_Call(((PyObject *)((PyObject*)(&PyInt_Type))), ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
+          __Pyx_GOTREF(__pyx_t_6);
+          __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+          __Pyx_XDECREF(__pyx_v_fileno);
+          __pyx_v_fileno = __pyx_t_6;
+          __pyx_t_6 = 0;
+        }
+        /*else:*/ {
+
+          /* "zmq/core/_poll.pyx":99
+ *                 raise ValueError('fileno() must return an valid integer fd')
+ *             else:
+ *                 pollitems[i].socket = NULL             # <<<<<<<<<<<<<<
+ *                 pollitems[i].fd = fileno
+ *                 pollitems[i].events = events
+ */
+          (__pyx_v_pollitems[__pyx_v_i]).socket = NULL;
+
+          /* "zmq/core/_poll.pyx":100
+ *             else:
+ *                 pollitems[i].socket = NULL
+ *                 pollitems[i].fd = fileno             # <<<<<<<<<<<<<<
+ *                 pollitems[i].events = events
+ *                 pollitems[i].revents = 0
+ */
+          __pyx_t_9 = __Pyx_PyInt_AsInt(__pyx_v_fileno); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
+          (__pyx_v_pollitems[__pyx_v_i]).fd = __pyx_t_9;
+
+          /* "zmq/core/_poll.pyx":101
+ *                 pollitems[i].socket = NULL
+ *                 pollitems[i].fd = fileno
+ *                 pollitems[i].events = events             # <<<<<<<<<<<<<<
+ *                 pollitems[i].revents = 0
+ *         else:
+ */
+          __pyx_t_8 = __Pyx_PyInt_AsShort(__pyx_v_events); if (unlikely((__pyx_t_8 == (short)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 101; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
+          (__pyx_v_pollitems[__pyx_v_i]).events = __pyx_t_8;
+
+          /* "zmq/core/_poll.pyx":102
+ *                 pollitems[i].fd = fileno
+ *                 pollitems[i].events = events
+ *                 pollitems[i].revents = 0             # <<<<<<<<<<<<<<
+ *         else:
+ *             free(pollitems)
+ */
+          (__pyx_v_pollitems[__pyx_v_i]).revents = 0;
+        }
+        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
+        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+        __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+        goto __pyx_L16_try_end;
+        __pyx_L9_error:;
+        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+
+        /* "zmq/core/_poll.pyx":95
+ *             try:
+ *                 fileno = int(s.fileno())
+ *             except:             # <<<<<<<<<<<<<<
+ *                 free(pollitems)
+ *                 raise ValueError('fileno() must return an valid integer fd')
+ */
+        /*except:*/ {
+          __Pyx_AddTraceback("zmq.core._poll.zmq_poll", __pyx_clineno, __pyx_lineno, __pyx_filename);
+          if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_3, &__pyx_t_13) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
+          __Pyx_GOTREF(__pyx_t_6);
+          __Pyx_GOTREF(__pyx_t_3);
+          __Pyx_GOTREF(__pyx_t_13);
+
+          /* "zmq/core/_poll.pyx":96
+ *                 fileno = int(s.fileno())
+ *             except:
+ *                 free(pollitems)             # <<<<<<<<<<<<<<
+ *                 raise ValueError('fileno() must return an valid integer fd')
+ *             else:
+ */
+          free(__pyx_v_pollitems);
+
+          /* "zmq/core/_poll.pyx":97
+ *             except:
+ *                 free(pollitems)
+ *                 raise ValueError('fileno() must return an valid integer fd')             # <<<<<<<<<<<<<<
+ *             else:
+ *                 pollitems[i].socket = NULL
+ */
+          __pyx_t_14 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_4), NULL); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
+          __Pyx_GOTREF(__pyx_t_14);
+          __Pyx_Raise(__pyx_t_14, 0, 0, 0);
+          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
+          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+          goto __pyx_L10_exception_handled;
+        }
+        __pyx_L11_except_error:;
+        __Pyx_XGIVEREF(__pyx_t_10);
+        __Pyx_XGIVEREF(__pyx_t_11);
+        __Pyx_XGIVEREF(__pyx_t_12);
+        __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
+        goto __pyx_L1_error;
+        __pyx_L10_exception_handled:;
+        __Pyx_XGIVEREF(__pyx_t_10);
+        __Pyx_XGIVEREF(__pyx_t_11);
+        __Pyx_XGIVEREF(__pyx_t_12);
+        __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
+        __pyx_L16_try_end:;
+      }
+      goto __pyx_L8;
+    }
+    /*else*/ {
+
+      /* "zmq/core/_poll.pyx":104
+ *                 pollitems[i].revents = 0
+ *         else:
+ *             free(pollitems)             # <<<<<<<<<<<<<<
+ *             raise TypeError(
+ *                 "Socket must be a 0MQ socket, an integer fd or have "
+ */
+      free(__pyx_v_pollitems);
+
+      /* "zmq/core/_poll.pyx":108
+ *                 "Socket must be a 0MQ socket, an integer fd or have "
+ *                 "a fileno() method: %r" % s
+ *             )             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+      __pyx_t_13 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_5), __pyx_v_s); if (unlikely(!__pyx_t_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_13));
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_13));
+      __Pyx_GIVEREF(((PyObject *)__pyx_t_13));
+      __pyx_t_13 = 0;
+      __pyx_t_13 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_13);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_13, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    __pyx_L8:;
+  }
+
+  /* "zmq/core/_poll.pyx":111
+ * 
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_poll_c(pollitems, nsockets, timeout)
+ * 
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/_poll.pyx":112
+ * 
+ *     with nogil:
+ *         rc = zmq_poll_c(pollitems, nsockets, timeout)             # <<<<<<<<<<<<<<
+ * 
+ *     if rc < 0:
+ */
+        __pyx_v_rc = zmq_poll(__pyx_v_pollitems, __pyx_v_nsockets, __pyx_v_timeout);
+      }
+
+      /* "zmq/core/_poll.pyx":111
+ * 
+ * 
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_poll_c(pollitems, nsockets, timeout)
+ * 
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/_poll.pyx":114
+ *         rc = zmq_poll_c(pollitems, nsockets, timeout)
+ * 
+ *     if rc < 0:             # <<<<<<<<<<<<<<
+ *         free(pollitems)
+ *         _check_rc(rc)
+ */
+  __pyx_t_2 = (__pyx_v_rc < 0);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/_poll.pyx":115
+ * 
+ *     if rc < 0:
+ *         free(pollitems)             # <<<<<<<<<<<<<<
+ *         _check_rc(rc)
+ * 
+ */
+    free(__pyx_v_pollitems);
+
+    /* "zmq/core/_poll.pyx":116
+ *     if rc < 0:
+ *         free(pollitems)
+ *         _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *     results = []
+ */
+    __pyx_t_4 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L22;
+  }
+  __pyx_L22:;
+
+  /* "zmq/core/_poll.pyx":118
+ *         _check_rc(rc)
+ * 
+ *     results = []             # <<<<<<<<<<<<<<
+ *     for i in range(nsockets):
+ *         s = sockets[i][0]
+ */
+  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_results = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "zmq/core/_poll.pyx":119
+ * 
+ *     results = []
+ *     for i in range(nsockets):             # <<<<<<<<<<<<<<
+ *         s = sockets[i][0]
+ *         # Return the fd for sockets, for compat. with select.poll.
+ */
+  __pyx_t_4 = __pyx_v_nsockets;
+  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
+    __pyx_v_i = __pyx_t_5;
+
+    /* "zmq/core/_poll.pyx":120
+ *     results = []
+ *     for i in range(nsockets):
+ *         s = sockets[i][0]             # <<<<<<<<<<<<<<
+ *         # Return the fd for sockets, for compat. with select.poll.
+ *         if hasattr(s, 'fileno'):
+ */
+    __pyx_t_13 = __Pyx_GetItemInt(__pyx_v_sockets, __pyx_v_i, sizeof(int), PyInt_FromLong, 0, 1, 1); if (!__pyx_t_13) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_13, 0, sizeof(long), PyInt_FromLong, 0, 0, 1); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+    __Pyx_XDECREF(__pyx_v_s);
+    __pyx_v_s = __pyx_t_3;
+    __pyx_t_3 = 0;
+
+    /* "zmq/core/_poll.pyx":122
+ *         s = sockets[i][0]
+ *         # Return the fd for sockets, for compat. with select.poll.
+ *         if hasattr(s, 'fileno'):             # <<<<<<<<<<<<<<
+ *             s = s.fileno()
+ *         revents = pollitems[i].revents
+ */
+    __pyx_t_2 = PyObject_HasAttr(__pyx_v_s, ((PyObject *)__pyx_n_s__fileno)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_2) {
+
+      /* "zmq/core/_poll.pyx":123
+ *         # Return the fd for sockets, for compat. with select.poll.
+ *         if hasattr(s, 'fileno'):
+ *             s = s.fileno()             # <<<<<<<<<<<<<<
+ *         revents = pollitems[i].revents
+ *         # Only return sockets with non-zero status for compat. with select.poll.
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s__fileno); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_13 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_13);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_v_s);
+      __pyx_v_s = __pyx_t_13;
+      __pyx_t_13 = 0;
+      goto __pyx_L25;
+    }
+    __pyx_L25:;
+
+    /* "zmq/core/_poll.pyx":124
+ *         if hasattr(s, 'fileno'):
+ *             s = s.fileno()
+ *         revents = pollitems[i].revents             # <<<<<<<<<<<<<<
+ *         # Only return sockets with non-zero status for compat. with select.poll.
+ *         if revents > 0:
+ */
+    __pyx_t_8 = (__pyx_v_pollitems[__pyx_v_i]).revents;
+    __pyx_v_revents = __pyx_t_8;
+
+    /* "zmq/core/_poll.pyx":126
+ *         revents = pollitems[i].revents
+ *         # Only return sockets with non-zero status for compat. with select.poll.
+ *         if revents > 0:             # <<<<<<<<<<<<<<
+ *             results.append((s, revents))
+ * 
+ */
+    __pyx_t_2 = (__pyx_v_revents > 0);
+    if (__pyx_t_2) {
+
+      /* "zmq/core/_poll.pyx":127
+ *         # Only return sockets with non-zero status for compat. with select.poll.
+ *         if revents > 0:
+ *             results.append((s, revents))             # <<<<<<<<<<<<<<
+ * 
+ *     free(pollitems)
+ */
+      __pyx_t_13 = PyInt_FromLong(__pyx_v_revents); if (unlikely(!__pyx_t_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_13);
+      __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_v_s);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_s);
+      __Pyx_GIVEREF(__pyx_v_s);
+      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_13);
+      __Pyx_GIVEREF(__pyx_t_13);
+      __pyx_t_13 = 0;
+      __pyx_t_15 = __Pyx_PyList_Append(__pyx_v_results, ((PyObject *)__pyx_t_3)); if (unlikely(__pyx_t_15 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      goto __pyx_L26;
+    }
+    __pyx_L26:;
+  }
+
+  /* "zmq/core/_poll.pyx":129
+ *             results.append((s, revents))
+ * 
+ *     free(pollitems)             # <<<<<<<<<<<<<<
+ *     return results
+ * 
+ */
+  free(__pyx_v_pollitems);
+
+  /* "zmq/core/_poll.pyx":130
+ * 
+ *     free(pollitems)
+ *     return results             # <<<<<<<<<<<<<<
+ * 
+ * #-----------------------------------------------------------------------------
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_results));
+  __pyx_r = ((PyObject *)__pyx_v_results);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_13);
+  __Pyx_XDECREF(__pyx_t_14);
+  __Pyx_AddTraceback("zmq.core._poll.zmq_poll", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_current_socket);
+  __Pyx_XDECREF(__pyx_v_s);
+  __Pyx_XDECREF(__pyx_v_events);
+  __Pyx_XDECREF(__pyx_v_fileno);
+  __Pyx_XDECREF(__pyx_v_results);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/checkrc.pxd":5
+ * from libzmq cimport zmq_errno, ZMQ_ETERM
+ * 
+ * cdef inline int _check_rc(int rc) except -1:             # <<<<<<<<<<<<<<
+ *     """internal utility for checking zmq return condition
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int __pyx_v_rc) {
+  int __pyx_v_errno;
+  PyObject *__pyx_v_Again = NULL;
+  PyObject *__pyx_v_ContextTerminated = NULL;
+  PyObject *__pyx_v_ZMQError = NULL;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_check_rc", 0);
+
+  /* "zmq/core/checkrc.pxd":10
+ *     and raising the appropriate Exception class
+ *     """
+ *     cdef int errno = zmq_errno()             # <<<<<<<<<<<<<<
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ */
+  __pyx_v_errno = zmq_errno();
+
+  /* "zmq/core/checkrc.pxd":11
+ *     """
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()             # <<<<<<<<<<<<<<
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ */
+  __pyx_t_1 = PyErr_CheckSignals(); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/checkrc.pxd":12
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()
+ *     if rc < 0:             # <<<<<<<<<<<<<<
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ */
+  __pyx_t_2 = (__pyx_v_rc < 0);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+    switch (__pyx_v_errno) {
+
+      /* "zmq/core/checkrc.pxd":13
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ *         if errno == EAGAIN:             # <<<<<<<<<<<<<<
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ */
+      case EAGAIN:
+
+      /* "zmq/core/checkrc.pxd":14
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again             # <<<<<<<<<<<<<<
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__Again));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__Again));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Again));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_6), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__Again); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_Again = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":15
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ *             raise Again(errno)             # <<<<<<<<<<<<<<
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_Again, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+
+      /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+      case ETERM:
+
+      /* "zmq/core/checkrc.pxd":17
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated             # <<<<<<<<<<<<<<
+ *             raise ContextTerminated(errno)
+ *         else:
+ */
+      __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      PyList_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_n_s__ContextTerminated));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      __pyx_t_3 = __Pyx_Import(((PyObject *)__pyx_n_s_6), ((PyObject *)__pyx_t_4), -1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__ContextTerminated); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_4);
+      __pyx_v_ContextTerminated = __pyx_t_4;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+      /* "zmq/core/checkrc.pxd":18
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)             # <<<<<<<<<<<<<<
+ *         else:
+ *             from zmq.error import ZMQError
+ */
+      __pyx_t_3 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_3);
+      __pyx_t_3 = 0;
+      __pyx_t_3 = PyObject_Call(__pyx_v_ContextTerminated, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+      default:
+
+      /* "zmq/core/checkrc.pxd":20
+ *             raise ContextTerminated(errno)
+ *         else:
+ *             from zmq.error import ZMQError             # <<<<<<<<<<<<<<
+ *             raise ZMQError(errno)
+ *         # return -1
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQError));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__ZMQError));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQError));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_6), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__ZMQError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_ZMQError = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":21
+ *         else:
+ *             from zmq.error import ZMQError
+ *             raise ZMQError(errno)             # <<<<<<<<<<<<<<
+ *         # return -1
+ *     return 0
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_ZMQError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+    }
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/checkrc.pxd":23
+ *             raise ZMQError(errno)
+ *         # return -1
+ *     return 0             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = 0;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.checkrc._check_rc", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_Again);
+  __Pyx_XDECREF(__pyx_v_ContextTerminated);
+  __Pyx_XDECREF(__pyx_v_ZMQError);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":104
+ * # Datetime C API initialization function.
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():             # <<<<<<<<<<<<<<
+ *     PyDateTime_IMPORT
+ * 
+ */
+
+static CYTHON_INLINE void __pyx_f_7cpython_8datetime_import_datetime(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("import_datetime", 0);
+
+  /* "cpython/datetime.pxd":105
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():
+ *     PyDateTime_IMPORT             # <<<<<<<<<<<<<<
+ * 
+ * # Create date object using DateTime CAPI factory function.
+ */
+  PyDateTime_IMPORT;
+
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "cpython/datetime.pxd":109
+ * # Create date object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_date_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("date_new", 0);
+
+  /* "cpython/datetime.pxd":110
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create time object using DateTime CAPI factory function
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Date_FromDate(__pyx_v_year, __pyx_v_month, __pyx_v_day, PyDateTimeAPI->DateType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.date_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":114
+ * # Create time object using DateTime CAPI factory function
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_new(int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("time_new", 0);
+
+  /* "cpython/datetime.pxd":115
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create datetime object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Time_FromTime(__pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->TimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.time_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":119
+ * # Create datetime object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day, int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("datetime_new", 0);
+
+  /* "cpython/datetime.pxd":120
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create timedelta object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->DateTime_FromDateAndTime(__pyx_v_year, __pyx_v_month, __pyx_v_day, __pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->DateTimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.datetime_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":124
+ * # Create timedelta object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_timedelta_new(int __pyx_v_days, int __pyx_v_seconds, int __pyx_v_useconds) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("timedelta_new", 0);
+
+  /* "cpython/datetime.pxd":125
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)             # <<<<<<<<<<<<<<
+ * 
+ * # More recognizable getters for date/time/datetime/timedelta.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Delta_FromDelta(__pyx_v_days, __pyx_v_seconds, __pyx_v_useconds, 1, PyDateTimeAPI->DeltaType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.timedelta_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":133
+ * 
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":134
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_Time *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":135
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":137
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get tzinfo of datetime
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":140
+ * 
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":141
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_DateTime *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":142
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":144
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of date
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":147
+ * 
+ * # Get year of date
+ * cdef inline int date_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_year", 0);
+
+  /* "cpython/datetime.pxd":148
+ * # Get year of date
+ * cdef inline int date_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of date
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":151
+ * 
+ * # Get month of date
+ * cdef inline int date_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_month", 0);
+
+  /* "cpython/datetime.pxd":152
+ * # Get month of date
+ * cdef inline int date_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of date
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":155
+ * 
+ * # Get day of date
+ * cdef inline int date_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_day", 0);
+
+  /* "cpython/datetime.pxd":156
+ * # Get day of date
+ * cdef inline int date_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of datetime
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":159
+ * 
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_year", 0);
+
+  /* "cpython/datetime.pxd":160
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of datetime
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":163
+ * 
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_month", 0);
+
+  /* "cpython/datetime.pxd":164
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of datetime
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":167
+ * 
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_day", 0);
+
+  /* "cpython/datetime.pxd":168
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of time
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":171
+ * 
+ * # Get hour of time
+ * cdef inline int time_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_hour", 0);
+
+  /* "cpython/datetime.pxd":172
+ * # Get hour of time
+ * cdef inline int time_hour(object o):
+ *     return PyDateTime_TIME_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":175
+ * 
+ * # Get minute of time
+ * cdef inline int time_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_minute", 0);
+
+  /* "cpython/datetime.pxd":176
+ * # Get minute of time
+ * cdef inline int time_minute(object o):
+ *     return PyDateTime_TIME_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":179
+ * 
+ * # Get second of time
+ * cdef inline int time_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_second", 0);
+
+  /* "cpython/datetime.pxd":180
+ * # Get second of time
+ * cdef inline int time_second(object o):
+ *     return PyDateTime_TIME_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":183
+ * 
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_microsecond", 0);
+
+  /* "cpython/datetime.pxd":184
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of datetime
+ */
+  __pyx_r = PyDateTime_TIME_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":187
+ * 
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_hour", 0);
+
+  /* "cpython/datetime.pxd":188
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):
+ *     return PyDateTime_DATE_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":191
+ * 
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_minute", 0);
+
+  /* "cpython/datetime.pxd":192
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):
+ *     return PyDateTime_DATE_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":195
+ * 
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_second", 0);
+
+  /* "cpython/datetime.pxd":196
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):
+ *     return PyDateTime_DATE_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":199
+ * 
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_microsecond", 0);
+
+  /* "cpython/datetime.pxd":200
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get days of timedelta
+ */
+  __pyx_r = PyDateTime_DATE_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":203
+ * 
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).days
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_days(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_days", 0);
+
+  /* "cpython/datetime.pxd":204
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):
+ *     return (<PyDateTime_Delta*>o).days             # <<<<<<<<<<<<<<
+ * 
+ * # Get seconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->days;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":207
+ * 
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).seconds
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_seconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_seconds", 0);
+
+  /* "cpython/datetime.pxd":208
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):
+ *     return (<PyDateTime_Delta*>o).seconds             # <<<<<<<<<<<<<<
+ * 
+ * # Get microseconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->seconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_microseconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_microseconds", 0);
+
+  /* "cpython/datetime.pxd":212
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):
+ *     return (<PyDateTime_Delta*>o).microseconds             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->microseconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("_poll"),
+    __Pyx_DOCSTR(__pyx_k_7), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 0},
+  {&__pyx_kp_s_10, __pyx_k_10, sizeof(__pyx_k_10), 0, 0, 1, 0},
+  {&__pyx_n_s_11, __pyx_k_11, sizeof(__pyx_k_11), 0, 0, 1, 1},
+  {&__pyx_kp_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 0},
+  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
+  {&__pyx_n_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 1},
+  {&__pyx_n_s__Again, __pyx_k__Again, sizeof(__pyx_k__Again), 0, 0, 1, 1},
+  {&__pyx_n_s__ContextTerminated, __pyx_k__ContextTerminated, sizeof(__pyx_k__ContextTerminated), 0, 0, 1, 1},
+  {&__pyx_n_s__MemoryError, __pyx_k__MemoryError, sizeof(__pyx_k__MemoryError), 0, 0, 1, 1},
+  {&__pyx_n_s__TypeError, __pyx_k__TypeError, sizeof(__pyx_k__TypeError), 0, 0, 1, 1},
+  {&__pyx_n_s__ValueError, __pyx_k__ValueError, sizeof(__pyx_k__ValueError), 0, 0, 1, 1},
+  {&__pyx_n_s__ZMQError, __pyx_k__ZMQError, sizeof(__pyx_k__ZMQError), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s__current_socket, __pyx_k__current_socket, sizeof(__pyx_k__current_socket), 0, 0, 1, 1},
+  {&__pyx_n_s__events, __pyx_k__events, sizeof(__pyx_k__events), 0, 0, 1, 1},
+  {&__pyx_n_s__fileno, __pyx_k__fileno, sizeof(__pyx_k__fileno), 0, 0, 1, 1},
+  {&__pyx_n_s__i, __pyx_k__i, sizeof(__pyx_k__i), 0, 0, 1, 1},
+  {&__pyx_n_s__int_t, __pyx_k__int_t, sizeof(__pyx_k__int_t), 0, 0, 1, 1},
+  {&__pyx_n_s__nsockets, __pyx_k__nsockets, sizeof(__pyx_k__nsockets), 0, 0, 1, 1},
+  {&__pyx_n_s__pollitems, __pyx_k__pollitems, sizeof(__pyx_k__pollitems), 0, 0, 1, 1},
+  {&__pyx_n_s__range, __pyx_k__range, sizeof(__pyx_k__range), 0, 0, 1, 1},
+  {&__pyx_n_s__rc, __pyx_k__rc, sizeof(__pyx_k__rc), 0, 0, 1, 1},
+  {&__pyx_n_s__results, __pyx_k__results, sizeof(__pyx_k__results), 0, 0, 1, 1},
+  {&__pyx_n_s__revents, __pyx_k__revents, sizeof(__pyx_k__revents), 0, 0, 1, 1},
+  {&__pyx_n_s__s, __pyx_k__s, sizeof(__pyx_k__s), 0, 0, 1, 1},
+  {&__pyx_n_s__sockets, __pyx_k__sockets, sizeof(__pyx_k__sockets), 0, 0, 1, 1},
+  {&__pyx_n_s__sys, __pyx_k__sys, sizeof(__pyx_k__sys), 0, 0, 1, 1},
+  {&__pyx_n_s__timeout, __pyx_k__timeout, sizeof(__pyx_k__timeout), 0, 0, 1, 1},
+  {&__pyx_n_s__version_info, __pyx_k__version_info, sizeof(__pyx_k__version_info), 0, 0, 1, 1},
+  {&__pyx_n_s__zmq_poll, __pyx_k__zmq_poll, sizeof(__pyx_k__zmq_poll), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s__MemoryError); if (!__pyx_builtin_MemoryError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s__range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s__ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s__TypeError); if (!__pyx_builtin_TypeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/_poll.pyx":72
+ *     pollitems = <zmq_pollitem_t *>malloc(nsockets*sizeof(zmq_pollitem_t))
+ *     if pollitems == NULL:
+ *         raise MemoryError("Could not allocate poll items")             # <<<<<<<<<<<<<<
+ * 
+ *     if ZMQ_VERSION_MAJOR < 3:
+ */
+  __pyx_k_tuple_2 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_1)); if (unlikely(!__pyx_k_tuple_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_2);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_2));
+
+  /* "zmq/core/_poll.pyx":97
+ *             except:
+ *                 free(pollitems)
+ *                 raise ValueError('fileno() must return an valid integer fd')             # <<<<<<<<<<<<<<
+ *             else:
+ *                 pollitems[i].socket = NULL
+ */
+  __pyx_k_tuple_4 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 97; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_4);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_4));
+
+  /* "zmq/core/_poll.pyx":46
+ *     int_t = (int,long)
+ * 
+ * def zmq_poll(sockets, long timeout=-1):             # <<<<<<<<<<<<<<
+ *     """zmq_poll(sockets, timeout=-1)
+ * 
+ */
+  __pyx_k_tuple_8 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__sockets), ((PyObject *)__pyx_n_s__timeout), ((PyObject *)__pyx_n_s__rc), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__pollitems), ((PyObject *)__pyx_n_s__nsockets), ((PyObject *)__pyx_n_s__current_socket), ((PyObject *)__pyx_n_s__s), ((PyObject *)__pyx_n_s__events), ((PyObject *)__pyx_n_s__fileno), ((PyObject *)__pyx_n_s__results), ((PyObject *)__pyx_n_s__revents)); if (unlikely(!__pyx_k_tuple_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_8);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_8));
+  __pyx_k_codeobj_9 = (PyObject*)__Pyx_PyCode_New(2, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_8, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_10, __pyx_n_s__zmq_poll, 46, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC init_poll(void); /*proto*/
+PyMODINIT_FUNC init_poll(void)
+#else
+PyMODINIT_FUNC PyInit__poll(void); /*proto*/
+PyMODINIT_FUNC PyInit__poll(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_3;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__poll(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("_poll"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_7), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core._poll")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core._poll", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core___poll) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  /*--- Type import code ---*/
+  __pyx_ptype_3zmq_4core_7context_Context = __Pyx_ImportType("zmq.core.context", "Context", sizeof(struct __pyx_obj_3zmq_4core_7context_Context), 1); if (unlikely(!__pyx_ptype_3zmq_4core_7context_Context)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_vtabptr_3zmq_4core_7context_Context = (struct __pyx_vtabstruct_3zmq_4core_7context_Context*)__Pyx_GetVtable(__pyx_ptype_3zmq_4core_7context_Context->tp_dict); if (unlikely(!__pyx_vtabptr_3zmq_4core_7context_Context)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_3zmq_4core_6socket_Socket = __Pyx_ImportType("zmq.core.socket", "Socket", sizeof(struct __pyx_obj_3zmq_4core_6socket_Socket), 1); if (unlikely(!__pyx_ptype_3zmq_4core_6socket_Socket)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_vtabptr_3zmq_4core_6socket_Socket = (struct __pyx_vtabstruct_3zmq_4core_6socket_Socket*)__Pyx_GetVtable(__pyx_ptype_3zmq_4core_6socket_Socket->tp_dict); if (unlikely(!__pyx_vtabptr_3zmq_4core_6socket_Socket)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
+  #if CYTHON_COMPILING_IN_PYPY
+  sizeof(PyTypeObject),
+  #else
+  sizeof(PyHeapTypeObject),
+  #endif
+  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), 0); if (unlikely(!__pyx_ptype_7cpython_4bool_bool)) {__pyx_filename = __pyx_f[6]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), 0); if (unlikely(!__pyx_ptype_7cpython_7complex_complex)) {__pyx_filename = __pyx_f[7]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_date = __Pyx_ImportType("datetime", "date", sizeof(PyDateTime_Date), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_date)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_time = __Pyx_ImportType("datetime", "time", sizeof(PyDateTime_Time), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_time)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_datetime = __Pyx_ImportType("datetime", "datetime", sizeof(PyDateTime_DateTime), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_datetime)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_timedelta = __Pyx_ImportType("datetime", "timedelta", sizeof(PyDateTime_Delta), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_timedelta)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_tzinfo = __Pyx_ImportType("datetime", "tzinfo", sizeof(PyDateTime_TZInfo), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_tzinfo)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/_poll.pyx":32
+ * from socket cimport Socket
+ * 
+ * import sys             # <<<<<<<<<<<<<<
+ * 
+ * from zmq.core.checkrc cimport _check_rc
+ */
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__sys), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sys, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/_poll.pyx":41
+ * 
+ * # version-independent typecheck for int/long
+ * if sys.version_info[0] >= 3:             # <<<<<<<<<<<<<<
+ *     int_t = int
+ * else:
+ */
+  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__sys); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s__version_info); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_2, 0, sizeof(long), PyInt_FromLong, 0, 0, 1); if (!__pyx_t_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyObject_RichCompare(__pyx_t_1, __pyx_int_3, Py_GE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (__pyx_t_3) {
+
+    /* "zmq/core/_poll.pyx":42
+ * # version-independent typecheck for int/long
+ * if sys.version_info[0] >= 3:
+ *     int_t = int             # <<<<<<<<<<<<<<
+ * else:
+ *     int_t = (int,long)
+ */
+    if (PyDict_SetItem(__pyx_d, __pyx_n_s__int_t, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L2;
+  }
+  /*else*/ {
+
+    /* "zmq/core/_poll.pyx":44
+ *     int_t = int
+ * else:
+ *     int_t = (int,long)             # <<<<<<<<<<<<<<
+ * 
+ * def zmq_poll(sockets, long timeout=-1):
+ */
+    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_INCREF(((PyObject *)((PyObject*)(&PyInt_Type))));
+    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)((PyObject*)(&PyInt_Type))));
+    __Pyx_GIVEREF(((PyObject *)((PyObject*)(&PyInt_Type))));
+    __Pyx_INCREF(((PyObject *)((PyObject*)(&PyLong_Type))));
+    PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)((PyObject*)(&PyLong_Type))));
+    __Pyx_GIVEREF(((PyObject *)((PyObject*)(&PyLong_Type))));
+    if (PyDict_SetItem(__pyx_d, __pyx_n_s__int_t, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+  }
+  __pyx_L2:;
+
+  /* "zmq/core/_poll.pyx":46
+ *     int_t = (int,long)
+ * 
+ * def zmq_poll(sockets, long timeout=-1):             # <<<<<<<<<<<<<<
+ *     """zmq_poll(sockets, timeout=-1)
+ * 
+ */
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_3zmq_4core_5_poll_1zmq_poll, NULL, __pyx_n_s_11); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__zmq_poll, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "zmq/core/_poll.pyx":136
+ * #-----------------------------------------------------------------------------
+ * 
+ * __all__ = [ 'zmq_poll' ]             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__zmq_poll));
+  PyList_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_n_s__zmq_poll));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__zmq_poll));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+
+  /* "zmq/core/_poll.pyx":1
+ * """0MQ polling related functions and classes."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+
+  /* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core._poll", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core._poll");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name,
+    PyObject* kw_name)
+{
+    PyErr_Format(PyExc_TypeError,
+        #if PY_MAJOR_VERSION >= 3
+        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
+        #else
+        "%s() got multiple values for keyword argument '%s'", func_name,
+        PyString_AsString(kw_name));
+        #endif
+}
+
+static int __Pyx_ParseOptionalKeywords(
+    PyObject *kwds,
+    PyObject **argnames[],
+    PyObject *kwds2,
+    PyObject *values[],
+    Py_ssize_t num_pos_args,
+    const char* function_name)
+{
+    PyObject *key = 0, *value = 0;
+    Py_ssize_t pos = 0;
+    PyObject*** name;
+    PyObject*** first_kw_arg = argnames + num_pos_args;
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
+        name = first_kw_arg;
+        while (*name && (**name != key)) name++;
+        if (*name) {
+            values[name-argnames] = value;
+            continue;
+        }
+        name = first_kw_arg;
+        #if PY_MAJOR_VERSION < 3
+        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
+            while (*name) {
+                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
+                        && _PyString_Eq(**name, key)) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    if ((**argname == key) || (
+                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
+                             && _PyString_Eq(**argname, key))) {
+                        goto arg_passed_twice;
+                    }
+                    argname++;
+                }
+            }
+        } else
+        #endif
+        if (likely(PyUnicode_Check(key))) {
+            while (*name) {
+                int cmp = (**name == key) ? 0 :
+                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
+                #endif
+                    PyUnicode_Compare(**name, key);
+                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                if (cmp == 0) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    int cmp = (**argname == key) ? 0 :
+                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
+                    #endif
+                        PyUnicode_Compare(**argname, key);
+                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                    if (cmp == 0) goto arg_passed_twice;
+                    argname++;
+                }
+            }
+        } else
+            goto invalid_keyword_type;
+        if (kwds2) {
+            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+        } else {
+            goto invalid_keyword;
+        }
+    }
+    return 0;
+arg_passed_twice:
+    __Pyx_RaiseDoubleKeywordsError(function_name, key);
+    goto bad;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%s() keywords must be strings", function_name);
+    goto bad;
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%s() got an unexpected keyword argument '%s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+bad:
+    return -1;
+}
+
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
+}
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_Restore(type, value, tb);
+#endif
+}
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(type, value, tb);
+#endif
+}
+
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
+    Py_XINCREF(type);
+    if (!value || value == Py_None)
+        value = NULL;
+    else
+        Py_INCREF(value);
+    if (!tb || tb == Py_None)
+        tb = NULL;
+    else {
+        Py_INCREF(tb);
+        if (!PyTraceBack_Check(tb)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: arg 3 must be a traceback or None");
+            goto raise_error;
+        }
+    }
+    #if PY_VERSION_HEX < 0x02050000
+    if (PyClass_Check(type)) {
+    #else
+    if (PyType_Check(type)) {
+    #endif
+#if CYTHON_COMPILING_IN_PYPY
+        if (!value) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+#endif
+        PyErr_NormalizeException(&type, &value, &tb);
+    } else {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        value = type;
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyInstance_Check(type)) {
+            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+            Py_INCREF(type);
+        } else {
+            type = 0;
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception must be an old-style class or instance");
+            goto raise_error;
+        }
+        #else
+        type = (PyObject*) Py_TYPE(type);
+        Py_INCREF(type);
+        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception class must be a subclass of BaseException");
+            goto raise_error;
+        }
+        #endif
+    }
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+#else /* Python 3+ */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    PyObject* owned_instance = NULL;
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
+    }
+    if (value == Py_None)
+        value = 0;
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (PyExceptionClass_Check(type)) {
+        PyObject *args;
+        if (!value)
+            args = PyTuple_New(0);
+        else if (PyTuple_Check(value)) {
+            Py_INCREF(value);
+            args = value;
+        } else
+            args = PyTuple_Pack(1, value);
+        if (!args)
+            goto bad;
+        owned_instance = PyEval_CallObject(type, args);
+        Py_DECREF(args);
+        if (!owned_instance)
+            goto bad;
+        value = owned_instance;
+        if (!PyExceptionInstance_Check(value)) {
+            PyErr_Format(PyExc_TypeError,
+                         "calling %R should have returned an instance of "
+                         "BaseException, not %R",
+                         type, Py_TYPE(value));
+            goto bad;
+        }
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
+    }
+#if PY_VERSION_HEX >= 0x03030000
+    if (cause) {
+#else
+    if (cause && cause != Py_None) {
+#endif
+        PyObject *fixed_cause;
+        if (cause == Py_None) {
+            fixed_cause = NULL;
+        } else if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        } else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+    PyErr_SetObject(type, value);
+    if (tb) {
+        PyThreadState *tstate = PyThreadState_GET();
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
+    }
+bad:
+    Py_XDECREF(owned_instance);
+    return;
+}
+#endif
+
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
+    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+        PyObject *r = PyList_GET_ITEM(o, i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
+    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+        PyObject *r = PyTuple_GET_ITEM(o, i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (is_list || PyList_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
+        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
+            PyObject *r = PyList_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    else if (PyTuple_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
+        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    } else {
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
+                if (likely(l >= 0)) {
+                    i += l;
+                } else {
+                    if (PyErr_ExceptionMatches(PyExc_OverflowError))
+                        PyErr_Clear();
+                    else
+                        return NULL;
+                }
+            }
+            return m->sq_item(o, i);
+        }
+    }
+#else
+    if (is_list || PySequence_Check(o)) {
+        return PySequence_GetItem(o, i);
+    }
+#endif
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
+
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    if (unlikely(!type)) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (likely(PyObject_TypeCheck(obj, type)))
+        return 1;
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
+    return 0;
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON
+    result = PyDict_GetItem(__pyx_d, name);
+    if (result) {
+        Py_INCREF(result);
+    } else {
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    if (!result) {
+        PyErr_Clear();
+#endif
+        result = __Pyx_GetBuiltinName(name);
+    }
+    return result;
+}
+
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
+    PyObject *local_type, *local_value, *local_tb;
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    local_type = tstate->curexc_type;
+    local_value = tstate->curexc_value;
+    local_tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(&local_type, &local_value, &local_tb);
+#endif
+    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (unlikely(tstate->curexc_type))
+#else
+    if (unlikely(PyErr_Occurred()))
+#endif
+        goto bad;
+    #if PY_MAJOR_VERSION >= 3
+    if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
+        goto bad;
+    #endif
+    Py_INCREF(local_type);
+    Py_INCREF(local_value);
+    Py_INCREF(local_tb);
+    *type = local_type;
+    *value = local_value;
+    *tb = local_tb;
+#if CYTHON_COMPILING_IN_CPYTHON
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = local_type;
+    tstate->exc_value = local_value;
+    tstate->exc_traceback = local_tb;
+    /* Make sure tstate is in a consistent state when we XDECREF
+       these objects (DECREF may run arbitrary code). */
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(local_type, local_value, local_tb);
+#endif
+    return 0;
+bad:
+    *type = 0;
+    *value = 0;
+    *tb = 0;
+    Py_XDECREF(local_type);
+    Py_XDECREF(local_value);
+    Py_XDECREF(local_tb);
+    return -1;
+}
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+#else
+    PyErr_GetExcInfo(type, value, tb);
+#endif
+}
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(type, value, tb);
+#endif
+}
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_VERSION_HEX < 0x03030000
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    #if PY_VERSION_HEX >= 0x02050000
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if (strchr(__Pyx_MODULE_NAME, '.')) {
+                #if PY_VERSION_HEX < 0x03030000
+                PyObject *py_level = PyInt_FromLong(1);
+                if (!py_level)
+                    goto bad;
+                module = PyObject_CallFunctionObjArgs(py_import,
+                    name, global_dict, empty_dict, list, py_level, NULL);
+                Py_DECREF(py_level);
+                #else
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                #endif
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0; /* try absolute import on failure */
+        }
+        #endif
+        if (!module) {
+            #if PY_VERSION_HEX < 0x03030000
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+    #else
+    if (level>0) {
+        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
+        goto bad;
+    }
+    module = PyObject_CallFunctionObjArgs(py_import,
+        name, global_dict, empty_dict, list, NULL);
+    #endif
+bad:
+    #if PY_VERSION_HEX < 0x03030000
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+#ifndef __PYX_HAVE_RT_ImportModule
+#define __PYX_HAVE_RT_ImportModule
+static PyObject *__Pyx_ImportModule(const char *name) {
+    PyObject *py_name = 0;
+    PyObject *py_module = 0;
+    py_name = __Pyx_PyIdentifier_FromString(name);
+    if (!py_name)
+        goto bad;
+    py_module = PyImport_Import(py_name);
+    Py_DECREF(py_name);
+    return py_module;
+bad:
+    Py_XDECREF(py_name);
+    return 0;
+}
+#endif
+
+#ifndef __PYX_HAVE_RT_ImportType
+#define __PYX_HAVE_RT_ImportType
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
+    size_t size, int strict)
+{
+    PyObject *py_module = 0;
+    PyObject *result = 0;
+    PyObject *py_name = 0;
+    char warning[200];
+    Py_ssize_t basicsize;
+#ifdef Py_LIMITED_API
+    PyObject *py_basicsize;
+#endif
+    py_module = __Pyx_ImportModule(module_name);
+    if (!py_module)
+        goto bad;
+    py_name = __Pyx_PyIdentifier_FromString(class_name);
+    if (!py_name)
+        goto bad;
+    result = PyObject_GetAttr(py_module, py_name);
+    Py_DECREF(py_name);
+    py_name = 0;
+    Py_DECREF(py_module);
+    py_module = 0;
+    if (!result)
+        goto bad;
+    if (!PyType_Check(result)) {
+        PyErr_Format(PyExc_TypeError,
+            "%s.%s is not a type object",
+            module_name, class_name);
+        goto bad;
+    }
+#ifndef Py_LIMITED_API
+    basicsize = ((PyTypeObject *)result)->tp_basicsize;
+#else
+    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
+    if (!py_basicsize)
+        goto bad;
+    basicsize = PyLong_AsSsize_t(py_basicsize);
+    Py_DECREF(py_basicsize);
+    py_basicsize = 0;
+    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
+#endif
+    if (!strict && (size_t)basicsize > size) {
+        PyOS_snprintf(warning, sizeof(warning),
+            "%s.%s size changed, may indicate binary incompatibility",
+            module_name, class_name);
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyErr_Warn(NULL, warning) < 0) goto bad;
+        #else
+        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
+        #endif
+    }
+    else if ((size_t)basicsize != size) {
+        PyErr_Format(PyExc_ValueError,
+            "%s.%s has the wrong size, try recompiling",
+            module_name, class_name);
+        goto bad;
+    }
+    return (PyTypeObject *)result;
+bad:
+    Py_XDECREF(py_module);
+    Py_XDECREF(result);
+    return NULL;
+}
+#endif
+
+static void* __Pyx_GetVtable(PyObject *dict) {
+    void* ptr;
+    PyObject *ob = PyMapping_GetItemString(dict, (char *)"__pyx_vtable__");
+    if (!ob)
+        goto bad;
+#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
+    ptr = PyCapsule_GetPointer(ob, 0);
+#else
+    ptr = PyCObject_AsVoidPtr(ob);
+#endif
+    if (!ptr && !PyErr_Occurred())
+        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
+    Py_DECREF(ob);
+    return ptr;
+bad:
+    Py_XDECREF(ob);
+    return NULL;
+}
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
--- /dev/null
+++ pyzmq-13.1.0/zmq/core/message.c
@@ -0,0 +1,8743 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core__message
+#define __PYX_HAVE_API__zmq__core__message
+#include "string.h"
+#include "stdio.h"
+#include "pythread.h"
+#include "datetime.h"
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#include "pyversion_compat.h"
+#include "errno.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "message.pyx",
+  "message.pxd",
+  "checkrc.pxd",
+  "buffers.pxd",
+  "datetime.pxd",
+  "type.pxd",
+  "bool.pxd",
+  "complex.pxd",
+};
+
+/*--- Type declarations ---*/
+struct __pyx_obj_3zmq_4core_7message_MessageTracker;
+struct __pyx_obj_3zmq_4core_7message_Frame;
+
+/* "zmq/core/message.pxd":34
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class MessageTracker(object):             # <<<<<<<<<<<<<<
+ *     """A class for tracking if 0MQ is done using one or more messages."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_7message_MessageTracker {
+  PyObject_HEAD
+  PyObject *events;
+  PyObject *peers;
+};
+
+
+/* "zmq/core/message.pxd":41
+ * 
+ * 
+ * cdef class Frame:             # <<<<<<<<<<<<<<
+ *     """A Message Frame class for non-copy send/recvs."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_7message_Frame {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_7message_Frame *__pyx_vtab;
+  zmq_msg_t zmq_msg;
+  PyObject *_data;
+  PyObject *_buffer;
+  PyObject *_bytes;
+  int _failed_init;
+  PyObject *tracker_event;
+  PyObject *tracker;
+  int more;
+};
+
+
+
+/* "zmq/core/message.pyx":69
+ * 
+ * 
+ * cdef class Frame:             # <<<<<<<<<<<<<<
+ *     """Frame(data=None, track=False)
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_7message_Frame {
+  struct __pyx_obj_3zmq_4core_7message_Frame *(*fast_copy)(struct __pyx_obj_3zmq_4core_7message_Frame *);
+  PyObject *(*_getbuffer)(struct __pyx_obj_3zmq_4core_7message_Frame *);
+};
+static struct __pyx_vtabstruct_3zmq_4core_7message_Frame *__pyx_vtabptr_3zmq_4core_7message_Frame;
+static PyObject *__pyx_f_3zmq_4core_7message_5Frame__getbuffer(struct __pyx_obj_3zmq_4core_7message_Frame *);
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+
+#ifndef __PYX_FORCE_INIT_THREADS
+  #define __PYX_FORCE_INIT_THREADS 0
+#endif
+
+#define __Pyx_GetItemInt(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_Fast(o, i, is_list, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+#define __Pyx_GetItemInt_List(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_List_Fast(o, i, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+#define __Pyx_GetItemInt_Tuple(o, i, size, to_py_func, is_list, wraparound, boundscheck) \
+    (((size) <= sizeof(Py_ssize_t)) ? \
+    __Pyx_GetItemInt_Tuple_Fast(o, i, wraparound, boundscheck) : \
+    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck);
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/
+
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
+    const char* function_name); /*proto*/
+
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static void __Pyx_WriteUnraisable(const char *name, int clineno,
+                                  int lineno, const char *filename); /*proto*/
+
+static int __Pyx_check_binary_version(void);
+
+static int __Pyx_SetVtable(PyObject *dict, void *vtable); /*proto*/
+
+#if !defined(__Pyx_PyIdentifier_FromString)
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
+#else
+  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
+#endif
+#endif
+
+static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
+
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'cpython.version' */
+
+/* Module declarations from 'cpython.ref' */
+
+/* Module declarations from 'cpython.exc' */
+
+/* Module declarations from 'cpython.module' */
+
+/* Module declarations from 'cpython.mem' */
+
+/* Module declarations from 'cpython.tuple' */
+
+/* Module declarations from 'cpython.list' */
+
+/* Module declarations from 'libc.string' */
+
+/* Module declarations from 'libc.stdio' */
+
+/* Module declarations from 'cpython.object' */
+
+/* Module declarations from 'cpython.sequence' */
+
+/* Module declarations from 'cpython.mapping' */
+
+/* Module declarations from 'cpython.iterator' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.type' */
+static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
+
+/* Module declarations from 'cpython.number' */
+
+/* Module declarations from 'cpython.int' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.bool' */
+static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;
+
+/* Module declarations from 'cpython.long' */
+
+/* Module declarations from 'cpython.float' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.complex' */
+static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;
+
+/* Module declarations from 'cpython.string' */
+
+/* Module declarations from 'cpython.unicode' */
+
+/* Module declarations from 'cpython.dict' */
+
+/* Module declarations from 'cpython.instance' */
+
+/* Module declarations from 'cpython.function' */
+
+/* Module declarations from 'cpython.method' */
+
+/* Module declarations from 'cpython.weakref' */
+
+/* Module declarations from 'cpython.getargs' */
+
+/* Module declarations from 'cpython.pythread' */
+
+/* Module declarations from 'cpython.pystate' */
+
+/* Module declarations from 'cpython.cobject' */
+
+/* Module declarations from 'cpython.oldbuffer' */
+
+/* Module declarations from 'cpython.set' */
+
+/* Module declarations from 'cpython.buffer' */
+
+/* Module declarations from 'cpython.bytes' */
+
+/* Module declarations from 'cpython.pycapsule' */
+
+/* Module declarations from 'datetime' */
+
+/* Module declarations from 'cpython.datetime' */
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_date = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_time = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_datetime = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_timedelta = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_tzinfo = 0;
+
+/* Module declarations from 'cpython' */
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'buffers' */
+static CYTHON_INLINE int __pyx_f_7buffers_memoryview_available(void); /*proto*/
+static CYTHON_INLINE int __pyx_f_7buffers_oldstyle_available(void); /*proto*/
+static CYTHON_INLINE int __pyx_f_7buffers_check_buffer(PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer(PyObject *, int, int, void **, Py_ssize_t *, Py_ssize_t *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer_r(PyObject *, void **, Py_ssize_t *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_3(void *, Py_ssize_t, int); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_2(void *, Py_ssize_t, int); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer(void *, Py_ssize_t, int); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject(PyObject *, int); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject_r(PyObject *); /*proto*/
+
+/* Module declarations from 'libc.errno' */
+
+/* Module declarations from 'zmq.core.checkrc' */
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int); /*proto*/
+
+/* Module declarations from 'zmq.core.message' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_7message_MessageTracker = 0;
+static PyTypeObject *__pyx_ptype_3zmq_4core_7message_Frame = 0;
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_7message_copy_zmq_msg_bytes(zmq_msg_t *); /*proto*/
+static void __pyx_f_3zmq_4core_7message_free_python_msg(void *, void *); /*proto*/
+#define __Pyx_MODULE_NAME "zmq.core.message"
+int __pyx_module_is_main_zmq__core__message = 0;
+
+/* Implementation of 'zmq.core.message' */
+static PyObject *__pyx_builtin_ImportError;
+static PyObject *__pyx_builtin_AttributeError;
+static PyObject *__pyx_builtin_property;
+static PyObject *__pyx_builtin_TypeError;
+static PyObject *__pyx_builtin_SystemError;
+static PyObject *__pyx_builtin_NotImplementedError;
+static int __pyx_pf_3zmq_4core_7message_5Frame___cinit__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, PyObject *__pyx_v_data, PyObject *__pyx_v_track, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static int __pyx_pf_3zmq_4core_7message_5Frame_2__init__(CYTHON_UNUSED struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_track); /* proto */
+static void __pyx_pf_3zmq_4core_7message_5Frame_4__dealloc__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_7message_5Frame_6__getbuffer__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, Py_buffer *__pyx_v_buffer, CYTHON_UNUSED int __pyx_v_flags); /* proto */
+#if PY_MAJOR_VERSION < 3
+static Py_ssize_t __pyx_pf_3zmq_4core_7message_5Frame_8__getsegcount__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, Py_ssize_t *__pyx_v_lenp); /* proto */
+#endif
+#if PY_MAJOR_VERSION < 3
+static Py_ssize_t __pyx_pf_3zmq_4core_7message_5Frame_10__getreadbuffer__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, Py_ssize_t __pyx_v_idx, void **__pyx_v_p); /* proto */
+#endif
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_12__copy__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static Py_ssize_t __pyx_pf_3zmq_4core_7message_5Frame_14__len__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_16__str__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_18buffer(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_20bytes(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_22set(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, int __pyx_v_option, int __pyx_v_value); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_24get(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, int __pyx_v_option); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_13tracker_event___get__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_7message_5Frame_13tracker_event_2__set__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
+static int __pyx_pf_3zmq_4core_7message_5Frame_13tracker_event_4__del__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_7tracker___get__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_7message_5Frame_7tracker_2__set__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
+static int __pyx_pf_3zmq_4core_7message_5Frame_7tracker_4__del__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_4more___get__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_7message_5Frame_4more_2__set__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
+static PyObject *__pyx_tp_new_3zmq_4core_7message_MessageTracker(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_tp_new_3zmq_4core_7message_Frame(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static char __pyx_k_2[] = "Unicode objects not allowed. Only: str/bytes, buffer interfaces.";
+static char __pyx_k_5[] = "accessing non-existent buffer segment";
+static char __pyx_k_7[] = "zmq.error";
+static char __pyx_k_8[] = "%r does not provide a buffer interface.";
+static char __pyx_k_10[] = "";
+static char __pyx_k_11[] = "Old style buffers not available.";
+static char __pyx_k_13[] = "0MQ Message related classes.";
+static char __pyx_k_14[] = "zmq.utils.strtypes";
+static char __pyx_k__B[] = "B";
+static char __pyx_k__set[] = "set";
+static char __pyx_k__zmq[] = "zmq";
+static char __pyx_k__char[] = "char";
+static char __pyx_k__data[] = "data";
+static char __pyx_k__time[] = "time";
+static char __pyx_k__Again[] = "Again";
+static char __pyx_k__Event[] = "Event";
+static char __pyx_k__Frame[] = "Frame";
+static char __pyx_k__ascii[] = "ascii";
+static char __pyx_k__bytes[] = "bytes";
+static char __pyx_k__dtype[] = "dtype";
+static char __pyx_k__track[] = "track";
+static char __pyx_k__value[] = "value";
+static char __pyx_k___Event[] = "_Event";
+static char __pyx_k__buffer[] = "buffer";
+static char __pyx_k__decode[] = "decode";
+static char __pyx_k__option[] = "option";
+static char __pyx_k__Message[] = "Message";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k__unicode[] = "unicode";
+static char __pyx_k__ZMQError[] = "ZMQError";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__itemsize[] = "itemsize";
+static char __pyx_k__property[] = "property";
+static char __pyx_k__typecode[] = "typecode";
+static char __pyx_k__TypeError[] = "TypeError";
+static char __pyx_k__threading[] = "threading";
+static char __pyx_k____import__[] = "__import__";
+static char __pyx_k__basestring[] = "basestring";
+static char __pyx_k__ImportError[] = "ImportError";
+static char __pyx_k__SystemError[] = "SystemError";
+static char __pyx_k__AttributeError[] = "AttributeError";
+static char __pyx_k__MessageTracker[] = "MessageTracker";
+static char __pyx_k__ContextTerminated[] = "ContextTerminated";
+static char __pyx_k__NotImplementedError[] = "NotImplementedError";
+static PyObject *__pyx_kp_s_10;
+static PyObject *__pyx_kp_s_11;
+static PyObject *__pyx_n_s_14;
+static PyObject *__pyx_kp_s_2;
+static PyObject *__pyx_kp_s_5;
+static PyObject *__pyx_n_s_7;
+static PyObject *__pyx_kp_s_8;
+static PyObject *__pyx_n_s__Again;
+static PyObject *__pyx_n_s__AttributeError;
+static PyObject *__pyx_n_b__B;
+static PyObject *__pyx_n_s__ContextTerminated;
+static PyObject *__pyx_n_s__Event;
+static PyObject *__pyx_n_s__Frame;
+static PyObject *__pyx_n_s__ImportError;
+static PyObject *__pyx_n_s__Message;
+static PyObject *__pyx_n_s__MessageTracker;
+static PyObject *__pyx_n_s__NotImplementedError;
+static PyObject *__pyx_n_s__SystemError;
+static PyObject *__pyx_n_s__TypeError;
+static PyObject *__pyx_n_s__ZMQError;
+static PyObject *__pyx_n_s___Event;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____import__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s__ascii;
+static PyObject *__pyx_n_s__basestring;
+static PyObject *__pyx_n_s__buffer;
+static PyObject *__pyx_n_s__bytes;
+static PyObject *__pyx_n_s__char;
+static PyObject *__pyx_n_s__data;
+static PyObject *__pyx_n_s__decode;
+static PyObject *__pyx_n_s__dtype;
+static PyObject *__pyx_n_s__itemsize;
+static PyObject *__pyx_n_s__option;
+static PyObject *__pyx_n_s__property;
+static PyObject *__pyx_n_s__set;
+static PyObject *__pyx_n_s__threading;
+static PyObject *__pyx_n_s__time;
+static PyObject *__pyx_n_s__track;
+static PyObject *__pyx_n_s__typecode;
+static PyObject *__pyx_n_s__unicode;
+static PyObject *__pyx_n_s__value;
+static PyObject *__pyx_n_s__zmq;
+static PyObject *__pyx_k_1;
+static PyObject *__pyx_k_4;
+static PyObject *__pyx_k_tuple_3;
+static PyObject *__pyx_k_tuple_6;
+static PyObject *__pyx_k_tuple_9;
+static PyObject *__pyx_k_tuple_12;
+
+/* "zmq/core/message.pyx":57
+ * 
+ * 
+ * cdef void free_python_msg(void *data, void *hint) with gil:             # <<<<<<<<<<<<<<
+ *     """A function for DECREF'ing Python based messages."""
+ *     if hint != NULL:
+ */
+
+static void __pyx_f_3zmq_4core_7message_free_python_msg(CYTHON_UNUSED void *__pyx_v_data, void *__pyx_v_hint) {
+  PyObject *__pyx_v_tracker_event = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  #ifdef WITH_THREAD
+  PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
+  #endif
+  __Pyx_RefNannySetupContext("free_python_msg", 0);
+
+  /* "zmq/core/message.pyx":59
+ * cdef void free_python_msg(void *data, void *hint) with gil:
+ *     """A function for DECREF'ing Python based messages."""
+ *     if hint != NULL:             # <<<<<<<<<<<<<<
+ *         tracker_event = (<tuple>hint)[1]
+ *         Py_DECREF(<object>hint)
+ */
+  __pyx_t_1 = (__pyx_v_hint != NULL);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":60
+ *     """A function for DECREF'ing Python based messages."""
+ *     if hint != NULL:
+ *         tracker_event = (<tuple>hint)[1]             # <<<<<<<<<<<<<<
+ *         Py_DECREF(<object>hint)
+ *         if isinstance(tracker_event, Event):
+ */
+    if (unlikely(((PyObject *)__pyx_v_hint) == Py_None)) {
+      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    __pyx_t_2 = __Pyx_GetItemInt_Tuple(((PyObject *)((PyObject*)__pyx_v_hint)), 1, sizeof(long), PyInt_FromLong, 0, 0, 1); if (!__pyx_t_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_v_tracker_event = __pyx_t_2;
+    __pyx_t_2 = 0;
+
+    /* "zmq/core/message.pyx":61
+ *     if hint != NULL:
+ *         tracker_event = (<tuple>hint)[1]
+ *         Py_DECREF(<object>hint)             # <<<<<<<<<<<<<<
+ *         if isinstance(tracker_event, Event):
+ *             # don't assert before DECREF:
+ */
+    Py_DECREF(((PyObject *)__pyx_v_hint));
+
+    /* "zmq/core/message.pyx":62
+ *         tracker_event = (<tuple>hint)[1]
+ *         Py_DECREF(<object>hint)
+ *         if isinstance(tracker_event, Event):             # <<<<<<<<<<<<<<
+ *             # don't assert before DECREF:
+ *             # assert tracker_queue.empty(), "somebody else wrote to my Queue!"
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__Event); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_1 = PyObject_IsInstance(__pyx_v_tracker_event, __pyx_t_2); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (__pyx_t_1) {
+
+      /* "zmq/core/message.pyx":65
+ *             # don't assert before DECREF:
+ *             # assert tracker_queue.empty(), "somebody else wrote to my Queue!"
+ *             tracker_event.set()             # <<<<<<<<<<<<<<
+ *         tracker_event = None
+ * 
+ */
+      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_tracker_event, __pyx_n_s__set); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 65; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 65; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      goto __pyx_L4;
+    }
+    __pyx_L4:;
+
+    /* "zmq/core/message.pyx":66
+ *             # assert tracker_queue.empty(), "somebody else wrote to my Queue!"
+ *             tracker_event.set()
+ *         tracker_event = None             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __Pyx_INCREF(Py_None);
+    __Pyx_DECREF(__pyx_v_tracker_event);
+    __pyx_v_tracker_event = Py_None;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_WriteUnraisable("zmq.core.message.free_python_msg", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_tracker_event);
+  __Pyx_RefNannyFinishContext();
+  #ifdef WITH_THREAD
+  PyGILState_Release(__pyx_gilstate_save);
+  #endif
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7message_5Frame_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3zmq_4core_7message_5Frame_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_data = 0;
+  PyObject *__pyx_v_track = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__data,&__pyx_n_s__track,0};
+    PyObject* values[2] = {0,0};
+
+    /* "zmq/core/message.pyx":96
+ *     """
+ * 
+ *     def __cinit__(self, object data=None, track=False, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef int rc
+ *         cdef char *data_c = NULL
+ */
+    values[0] = ((PyObject *)Py_None);
+    values[1] = __pyx_k_1;
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__data);
+          if (value) { values[0] = value; kw_args--; }
+        }
+        case  1:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__track);
+          if (value) { values[1] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_data = values[0];
+    __pyx_v_track = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("zmq.core.message.Frame.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame___cinit__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), __pyx_v_data, __pyx_v_track, __pyx_v_kwargs);
+  __Pyx_XDECREF(__pyx_v_kwargs);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7message_5Frame___cinit__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, PyObject *__pyx_v_data, PyObject *__pyx_v_track, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
+  int __pyx_v_rc;
+  char *__pyx_v_data_c;
+  Py_ssize_t __pyx_v_data_len_c;
+  PyObject *__pyx_v_hint = 0;
+  PyObject *__pyx_v_evt = NULL;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__cinit__", 0);
+
+  /* "zmq/core/message.pyx":98
+ *     def __cinit__(self, object data=None, track=False, **kwargs):
+ *         cdef int rc
+ *         cdef char *data_c = NULL             # <<<<<<<<<<<<<<
+ *         cdef Py_ssize_t data_len_c=0
+ *         cdef object hint
+ */
+  __pyx_v_data_c = NULL;
+
+  /* "zmq/core/message.pyx":99
+ *         cdef int rc
+ *         cdef char *data_c = NULL
+ *         cdef Py_ssize_t data_len_c=0             # <<<<<<<<<<<<<<
+ *         cdef object hint
+ * 
+ */
+  __pyx_v_data_len_c = 0;
+
+  /* "zmq/core/message.pyx":103
+ * 
+ *         # init more as False
+ *         self.more = False             # <<<<<<<<<<<<<<
+ * 
+ *         # Save the data object in case the user wants the the data as a str.
+ */
+  __pyx_v_self->more = 0;
+
+  /* "zmq/core/message.pyx":106
+ * 
+ *         # Save the data object in case the user wants the the data as a str.
+ *         self._data = data             # <<<<<<<<<<<<<<
+ *         self._failed_init = True  # bool switch for dealloc
+ *         self._buffer = None       # buffer view of data
+ */
+  __Pyx_INCREF(__pyx_v_data);
+  __Pyx_GIVEREF(__pyx_v_data);
+  __Pyx_GOTREF(__pyx_v_self->_data);
+  __Pyx_DECREF(__pyx_v_self->_data);
+  __pyx_v_self->_data = __pyx_v_data;
+
+  /* "zmq/core/message.pyx":107
+ *         # Save the data object in case the user wants the the data as a str.
+ *         self._data = data
+ *         self._failed_init = True  # bool switch for dealloc             # <<<<<<<<<<<<<<
+ *         self._buffer = None       # buffer view of data
+ *         self._bytes = None        # bytes copy of data
+ */
+  __pyx_v_self->_failed_init = 1;
+
+  /* "zmq/core/message.pyx":108
+ *         self._data = data
+ *         self._failed_init = True  # bool switch for dealloc
+ *         self._buffer = None       # buffer view of data             # <<<<<<<<<<<<<<
+ *         self._bytes = None        # bytes copy of data
+ * 
+ */
+  __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(Py_None);
+  __Pyx_GOTREF(__pyx_v_self->_buffer);
+  __Pyx_DECREF(__pyx_v_self->_buffer);
+  __pyx_v_self->_buffer = Py_None;
+
+  /* "zmq/core/message.pyx":109
+ *         self._failed_init = True  # bool switch for dealloc
+ *         self._buffer = None       # buffer view of data
+ *         self._bytes = None        # bytes copy of data             # <<<<<<<<<<<<<<
+ * 
+ *         # Event and MessageTracker for monitoring when zmq is done with data:
+ */
+  __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(Py_None);
+  __Pyx_GOTREF(__pyx_v_self->_bytes);
+  __Pyx_DECREF(__pyx_v_self->_bytes);
+  __pyx_v_self->_bytes = Py_None;
+
+  /* "zmq/core/message.pyx":112
+ * 
+ *         # Event and MessageTracker for monitoring when zmq is done with data:
+ *         if track:             # <<<<<<<<<<<<<<
+ *             evt = Event()
+ *             self.tracker_event = evt
+ */
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_track); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":113
+ *         # Event and MessageTracker for monitoring when zmq is done with data:
+ *         if track:
+ *             evt = Event()             # <<<<<<<<<<<<<<
+ *             self.tracker_event = evt
+ *             self.tracker = zmq.MessageTracker(evt)
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__Event); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_v_evt = __pyx_t_3;
+    __pyx_t_3 = 0;
+
+    /* "zmq/core/message.pyx":114
+ *         if track:
+ *             evt = Event()
+ *             self.tracker_event = evt             # <<<<<<<<<<<<<<
+ *             self.tracker = zmq.MessageTracker(evt)
+ *         else:
+ */
+    __Pyx_INCREF(__pyx_v_evt);
+    __Pyx_GIVEREF(__pyx_v_evt);
+    __Pyx_GOTREF(__pyx_v_self->tracker_event);
+    __Pyx_DECREF(__pyx_v_self->tracker_event);
+    __pyx_v_self->tracker_event = __pyx_v_evt;
+
+    /* "zmq/core/message.pyx":115
+ *             evt = Event()
+ *             self.tracker_event = evt
+ *             self.tracker = zmq.MessageTracker(evt)             # <<<<<<<<<<<<<<
+ *         else:
+ *             self.tracker_event = None
+ */
+    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s__zmq); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s__MessageTracker); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_INCREF(__pyx_v_evt);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_evt);
+    __Pyx_GIVEREF(__pyx_v_evt);
+    __pyx_t_4 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __Pyx_GIVEREF(__pyx_t_4);
+    __Pyx_GOTREF(__pyx_v_self->tracker);
+    __Pyx_DECREF(__pyx_v_self->tracker);
+    __pyx_v_self->tracker = __pyx_t_4;
+    __pyx_t_4 = 0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/message.pyx":117
+ *             self.tracker = zmq.MessageTracker(evt)
+ *         else:
+ *             self.tracker_event = None             # <<<<<<<<<<<<<<
+ *             self.tracker = None
+ * 
+ */
+    __Pyx_INCREF(Py_None);
+    __Pyx_GIVEREF(Py_None);
+    __Pyx_GOTREF(__pyx_v_self->tracker_event);
+    __Pyx_DECREF(__pyx_v_self->tracker_event);
+    __pyx_v_self->tracker_event = Py_None;
+
+    /* "zmq/core/message.pyx":118
+ *         else:
+ *             self.tracker_event = None
+ *             self.tracker = None             # <<<<<<<<<<<<<<
+ * 
+ *         if isinstance(data, unicode):
+ */
+    __Pyx_INCREF(Py_None);
+    __Pyx_GIVEREF(Py_None);
+    __Pyx_GOTREF(__pyx_v_self->tracker);
+    __Pyx_DECREF(__pyx_v_self->tracker);
+    __pyx_v_self->tracker = Py_None;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/message.pyx":120
+ *             self.tracker = None
+ * 
+ *         if isinstance(data, unicode):             # <<<<<<<<<<<<<<
+ *             raise TypeError("Unicode objects not allowed. Only: str/bytes, buffer interfaces.")
+ * 
+ */
+  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_data, __pyx_t_4); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":121
+ * 
+ *         if isinstance(data, unicode):
+ *             raise TypeError("Unicode objects not allowed. Only: str/bytes, buffer interfaces.")             # <<<<<<<<<<<<<<
+ * 
+ *         if data is None:
+ */
+    __pyx_t_4 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_k_tuple_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/message.pyx":123
+ *             raise TypeError("Unicode objects not allowed. Only: str/bytes, buffer interfaces.")
+ * 
+ *         if data is None:             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_msg_init(&self.zmq_msg)
+ */
+  __pyx_t_1 = (__pyx_v_data == Py_None);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":124
+ * 
+ *         if data is None:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_msg_init(&self.zmq_msg)
+ *             _check_rc(rc)
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/message.pyx":125
+ *         if data is None:
+ *             with nogil:
+ *                 rc = zmq_msg_init(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ *             _check_rc(rc)
+ *             self._failed_init = False
+ */
+          __pyx_v_rc = zmq_msg_init((&__pyx_v_self->zmq_msg));
+        }
+
+        /* "zmq/core/message.pyx":124
+ * 
+ *         if data is None:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_msg_init(&self.zmq_msg)
+ *             _check_rc(rc)
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+
+    /* "zmq/core/message.pyx":126
+ *             with nogil:
+ *                 rc = zmq_msg_init(&self.zmq_msg)
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ *             self._failed_init = False
+ *             return
+ */
+    __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "zmq/core/message.pyx":127
+ *                 rc = zmq_msg_init(&self.zmq_msg)
+ *             _check_rc(rc)
+ *             self._failed_init = False             # <<<<<<<<<<<<<<
+ *             return
+ *         else:
+ */
+    __pyx_v_self->_failed_init = 0;
+
+    /* "zmq/core/message.pyx":128
+ *             _check_rc(rc)
+ *             self._failed_init = False
+ *             return             # <<<<<<<<<<<<<<
+ *         else:
+ *             asbuffer_r(data, <void **>&data_c, &data_len_c)
+ */
+    __pyx_r = 0;
+    goto __pyx_L0;
+    goto __pyx_L5;
+  }
+  /*else*/ {
+
+    /* "zmq/core/message.pyx":130
+ *             return
+ *         else:
+ *             asbuffer_r(data, <void **>&data_c, &data_len_c)             # <<<<<<<<<<<<<<
+ *         # We INCREF the *original* Python object (not self) and pass it
+ *         # as the hint below. This allows other copies of this Frame
+ */
+    __pyx_t_4 = __pyx_f_7buffers_asbuffer_r(__pyx_v_data, ((void **)(&__pyx_v_data_c)), (&__pyx_v_data_len_c)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  }
+  __pyx_L5:;
+
+  /* "zmq/core/message.pyx":134
+ *         # as the hint below. This allows other copies of this Frame
+ *         # object to take over the ref counting of data properly.
+ *         hint = (data, self.tracker_event)             # <<<<<<<<<<<<<<
+ *         Py_INCREF(hint)
+ *         with nogil:
+ */
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(__pyx_v_data);
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_data);
+  __Pyx_GIVEREF(__pyx_v_data);
+  __Pyx_INCREF(__pyx_v_self->tracker_event);
+  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_self->tracker_event);
+  __Pyx_GIVEREF(__pyx_v_self->tracker_event);
+  __pyx_v_hint = ((PyObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "zmq/core/message.pyx":135
+ *         # object to take over the ref counting of data properly.
+ *         hint = (data, self.tracker_event)
+ *         Py_INCREF(hint)             # <<<<<<<<<<<<<<
+ *         with nogil:
+ *             rc = zmq_msg_init_data(
+ */
+  Py_INCREF(__pyx_v_hint);
+
+  /* "zmq/core/message.pyx":136
+ *         hint = (data, self.tracker_event)
+ *         Py_INCREF(hint)
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             rc = zmq_msg_init_data(
+ *                 &self.zmq_msg, <void *>data_c, data_len_c,
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/message.pyx":140
+ *                 &self.zmq_msg, <void *>data_c, data_len_c,
+ *                 <zmq_free_fn *>free_python_msg, <void *>hint
+ *             )             # <<<<<<<<<<<<<<
+ *         if rc != 0:
+ *             Py_DECREF(hint)
+ */
+        __pyx_v_rc = zmq_msg_init_data((&__pyx_v_self->zmq_msg), ((void *)__pyx_v_data_c), __pyx_v_data_len_c, ((zmq_free_fn *)__pyx_f_3zmq_4core_7message_free_python_msg), ((void *)__pyx_v_hint));
+      }
+
+      /* "zmq/core/message.pyx":136
+ *         hint = (data, self.tracker_event)
+ *         Py_INCREF(hint)
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             rc = zmq_msg_init_data(
+ *                 &self.zmq_msg, <void *>data_c, data_len_c,
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/message.pyx":141
+ *                 <zmq_free_fn *>free_python_msg, <void *>hint
+ *             )
+ *         if rc != 0:             # <<<<<<<<<<<<<<
+ *             Py_DECREF(hint)
+ *             _check_rc(rc)
+ */
+  __pyx_t_1 = (__pyx_v_rc != 0);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":142
+ *             )
+ *         if rc != 0:
+ *             Py_DECREF(hint)             # <<<<<<<<<<<<<<
+ *             _check_rc(rc)
+ *         self._failed_init = False
+ */
+    Py_DECREF(__pyx_v_hint);
+
+    /* "zmq/core/message.pyx":143
+ *         if rc != 0:
+ *             Py_DECREF(hint)
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ *         self._failed_init = False
+ * 
+ */
+    __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L12;
+  }
+  __pyx_L12:;
+
+  /* "zmq/core/message.pyx":144
+ *             Py_DECREF(hint)
+ *             _check_rc(rc)
+ *         self._failed_init = False             # <<<<<<<<<<<<<<
+ * 
+ *     def __init__(self, object data=None, track=False):
+ */
+  __pyx_v_self->_failed_init = 0;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.message.Frame.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_hint);
+  __Pyx_XDECREF(__pyx_v_evt);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7message_5Frame_3__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_7message_5Frame_2__init__[] = "Enforce signature";
+#if CYTHON_COMPILING_IN_CPYTHON
+struct wrapperbase __pyx_wrapperbase_3zmq_4core_7message_5Frame_2__init__;
+#endif
+static int __pyx_pw_3zmq_4core_7message_5Frame_3__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  CYTHON_UNUSED PyObject *__pyx_v_data = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_track = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__data,&__pyx_n_s__track,0};
+    PyObject* values[2] = {0,0};
+
+    /* "zmq/core/message.pyx":146
+ *         self._failed_init = False
+ * 
+ *     def __init__(self, object data=None, track=False):             # <<<<<<<<<<<<<<
+ *         """Enforce signature"""
+ *         pass
+ */
+    values[0] = ((PyObject *)Py_None);
+    values[1] = __pyx_k_4;
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__data);
+          if (value) { values[0] = value; kw_args--; }
+        }
+        case  1:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__track);
+          if (value) { values[1] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_data = values[0];
+    __pyx_v_track = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.message.Frame.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_2__init__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), __pyx_v_data, __pyx_v_track);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7message_5Frame_2__init__(CYTHON_UNUSED struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_track) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__", 0);
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static void __pyx_pw_3zmq_4core_7message_5Frame_5__dealloc__(PyObject *__pyx_v_self); /*proto*/
+static void __pyx_pw_3zmq_4core_7message_5Frame_5__dealloc__(PyObject *__pyx_v_self) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
+  __pyx_pf_3zmq_4core_7message_5Frame_4__dealloc__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "zmq/core/message.pyx":150
+ *         pass
+ * 
+ *     def __dealloc__(self):             # <<<<<<<<<<<<<<
+ *         cdef int rc
+ *         if self._failed_init:
+ */
+
+static void __pyx_pf_3zmq_4core_7message_5Frame_4__dealloc__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  int __pyx_v_rc;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__dealloc__", 0);
+
+  /* "zmq/core/message.pyx":152
+ *     def __dealloc__(self):
+ *         cdef int rc
+ *         if self._failed_init:             # <<<<<<<<<<<<<<
+ *             return
+ *         # This simply decreases the 0MQ ref-count of zmq_msg.
+ */
+  if (__pyx_v_self->_failed_init) {
+
+    /* "zmq/core/message.pyx":153
+ *         cdef int rc
+ *         if self._failed_init:
+ *             return             # <<<<<<<<<<<<<<
+ *         # This simply decreases the 0MQ ref-count of zmq_msg.
+ *         with nogil:
+ */
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/message.pyx":155
+ *             return
+ *         # This simply decreases the 0MQ ref-count of zmq_msg.
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             rc = zmq_msg_close(&self.zmq_msg)
+ *         _check_rc(rc)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/message.pyx":156
+ *         # This simply decreases the 0MQ ref-count of zmq_msg.
+ *         with nogil:
+ *             rc = zmq_msg_close(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ *         _check_rc(rc)
+ * 
+ */
+        __pyx_v_rc = zmq_msg_close((&__pyx_v_self->zmq_msg));
+      }
+
+      /* "zmq/core/message.pyx":155
+ *             return
+ *         # This simply decreases the 0MQ ref-count of zmq_msg.
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             rc = zmq_msg_close(&self.zmq_msg)
+ *         _check_rc(rc)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/message.pyx":157
+ *         with nogil:
+ *             rc = zmq_msg_close(&self.zmq_msg)
+ *         _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *     # buffer interface code adapted from petsc4py by Lisandro Dalcin, a BSD project
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("zmq.core.message.Frame.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+}
+
+/* Python wrapper */
+static CYTHON_UNUSED int __pyx_pw_3zmq_4core_7message_5Frame_7__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_buffer, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_pw_3zmq_4core_7message_5Frame_7__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_buffer, int __pyx_v_flags) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_6__getbuffer__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), ((Py_buffer *)__pyx_v_buffer), ((int)__pyx_v_flags));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":161
+ *     # buffer interface code adapted from petsc4py by Lisandro Dalcin, a BSD project
+ * 
+ *     def __getbuffer__(self, Py_buffer* buffer, int flags):             # <<<<<<<<<<<<<<
+ *         # new-style (memoryview) buffer interface
+ *         with nogil:
+ */
+
+static int __pyx_pf_3zmq_4core_7message_5Frame_6__getbuffer__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, Py_buffer *__pyx_v_buffer, CYTHON_UNUSED int __pyx_v_flags) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__getbuffer__", 0);
+  if (__pyx_v_buffer != NULL) {
+    __pyx_v_buffer->obj = Py_None; __Pyx_INCREF(Py_None);
+    __Pyx_GIVEREF(__pyx_v_buffer->obj);
+  }
+
+  /* "zmq/core/message.pyx":163
+ *     def __getbuffer__(self, Py_buffer* buffer, int flags):
+ *         # new-style (memoryview) buffer interface
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             buffer.buf = zmq_msg_data(&self.zmq_msg)
+ *             buffer.len = zmq_msg_size(&self.zmq_msg)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/message.pyx":164
+ *         # new-style (memoryview) buffer interface
+ *         with nogil:
+ *             buffer.buf = zmq_msg_data(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ *             buffer.len = zmq_msg_size(&self.zmq_msg)
+ * 
+ */
+        __pyx_v_buffer->buf = zmq_msg_data((&__pyx_v_self->zmq_msg));
+
+        /* "zmq/core/message.pyx":165
+ *         with nogil:
+ *             buffer.buf = zmq_msg_data(&self.zmq_msg)
+ *             buffer.len = zmq_msg_size(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ * 
+ *         buffer.obj = self
+ */
+        __pyx_v_buffer->len = zmq_msg_size((&__pyx_v_self->zmq_msg));
+      }
+
+      /* "zmq/core/message.pyx":163
+ *     def __getbuffer__(self, Py_buffer* buffer, int flags):
+ *         # new-style (memoryview) buffer interface
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             buffer.buf = zmq_msg_data(&self.zmq_msg)
+ *             buffer.len = zmq_msg_size(&self.zmq_msg)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/message.pyx":167
+ *             buffer.len = zmq_msg_size(&self.zmq_msg)
+ * 
+ *         buffer.obj = self             # <<<<<<<<<<<<<<
+ *         buffer.readonly = 1
+ *         buffer.format = "B"
+ */
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
+  __Pyx_GOTREF(__pyx_v_buffer->obj);
+  __Pyx_DECREF(__pyx_v_buffer->obj);
+  __pyx_v_buffer->obj = ((PyObject *)__pyx_v_self);
+
+  /* "zmq/core/message.pyx":168
+ * 
+ *         buffer.obj = self
+ *         buffer.readonly = 1             # <<<<<<<<<<<<<<
+ *         buffer.format = "B"
+ *         buffer.ndim = 0
+ */
+  __pyx_v_buffer->readonly = 1;
+
+  /* "zmq/core/message.pyx":169
+ *         buffer.obj = self
+ *         buffer.readonly = 1
+ *         buffer.format = "B"             # <<<<<<<<<<<<<<
+ *         buffer.ndim = 0
+ *         buffer.shape = NULL
+ */
+  __pyx_v_buffer->format = __pyx_k__B;
+
+  /* "zmq/core/message.pyx":170
+ *         buffer.readonly = 1
+ *         buffer.format = "B"
+ *         buffer.ndim = 0             # <<<<<<<<<<<<<<
+ *         buffer.shape = NULL
+ *         buffer.strides = NULL
+ */
+  __pyx_v_buffer->ndim = 0;
+
+  /* "zmq/core/message.pyx":171
+ *         buffer.format = "B"
+ *         buffer.ndim = 0
+ *         buffer.shape = NULL             # <<<<<<<<<<<<<<
+ *         buffer.strides = NULL
+ *         buffer.suboffsets = NULL
+ */
+  __pyx_v_buffer->shape = NULL;
+
+  /* "zmq/core/message.pyx":172
+ *         buffer.ndim = 0
+ *         buffer.shape = NULL
+ *         buffer.strides = NULL             # <<<<<<<<<<<<<<
+ *         buffer.suboffsets = NULL
+ *         buffer.itemsize = 1
+ */
+  __pyx_v_buffer->strides = NULL;
+
+  /* "zmq/core/message.pyx":173
+ *         buffer.shape = NULL
+ *         buffer.strides = NULL
+ *         buffer.suboffsets = NULL             # <<<<<<<<<<<<<<
+ *         buffer.itemsize = 1
+ *         buffer.internal = NULL
+ */
+  __pyx_v_buffer->suboffsets = NULL;
+
+  /* "zmq/core/message.pyx":174
+ *         buffer.strides = NULL
+ *         buffer.suboffsets = NULL
+ *         buffer.itemsize = 1             # <<<<<<<<<<<<<<
+ *         buffer.internal = NULL
+ * 
+ */
+  __pyx_v_buffer->itemsize = 1;
+
+  /* "zmq/core/message.pyx":175
+ *         buffer.suboffsets = NULL
+ *         buffer.itemsize = 1
+ *         buffer.internal = NULL             # <<<<<<<<<<<<<<
+ * 
+ *     def __getsegcount__(self, Py_ssize_t *lenp):
+ */
+  __pyx_v_buffer->internal = NULL;
+
+  __pyx_r = 0;
+  if (__pyx_v_buffer != NULL && __pyx_v_buffer->obj == Py_None) {
+    __Pyx_GOTREF(Py_None);
+    __Pyx_DECREF(Py_None); __pyx_v_buffer->obj = NULL;
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+#if PY_MAJOR_VERSION < 3
+static Py_ssize_t __pyx_pw_3zmq_4core_7message_5Frame_9__getsegcount__(PyObject *__pyx_v_self, Py_ssize_t *__pyx_v_lenp); /*proto*/
+static Py_ssize_t __pyx_pw_3zmq_4core_7message_5Frame_9__getsegcount__(PyObject *__pyx_v_self, Py_ssize_t *__pyx_v_lenp) {
+  Py_ssize_t __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__getsegcount__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_8__getsegcount__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), ((Py_ssize_t *)__pyx_v_lenp));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+#endif /*!(#if PY_MAJOR_VERSION < 3)*/
+
+/* "zmq/core/message.pyx":177
+ *         buffer.internal = NULL
+ * 
+ *     def __getsegcount__(self, Py_ssize_t *lenp):             # <<<<<<<<<<<<<<
+ *         # required for getreadbuffer
+ *         if lenp != NULL:
+ */
+
+#if PY_MAJOR_VERSION < 3
+static Py_ssize_t __pyx_pf_3zmq_4core_7message_5Frame_8__getsegcount__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, Py_ssize_t *__pyx_v_lenp) {
+  Py_ssize_t __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  __Pyx_RefNannySetupContext("__getsegcount__", 0);
+
+  /* "zmq/core/message.pyx":179
+ *     def __getsegcount__(self, Py_ssize_t *lenp):
+ *         # required for getreadbuffer
+ *         if lenp != NULL:             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 lenp[0] = zmq_msg_size(&self.zmq_msg)
+ */
+  __pyx_t_1 = (__pyx_v_lenp != NULL);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":180
+ *         # required for getreadbuffer
+ *         if lenp != NULL:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 lenp[0] = zmq_msg_size(&self.zmq_msg)
+ *         return 1
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/message.pyx":181
+ *         if lenp != NULL:
+ *             with nogil:
+ *                 lenp[0] = zmq_msg_size(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ *         return 1
+ * 
+ */
+          (__pyx_v_lenp[0]) = zmq_msg_size((&__pyx_v_self->zmq_msg));
+        }
+
+        /* "zmq/core/message.pyx":180
+ *         # required for getreadbuffer
+ *         if lenp != NULL:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 lenp[0] = zmq_msg_size(&self.zmq_msg)
+ *         return 1
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/message.pyx":182
+ *             with nogil:
+ *                 lenp[0] = zmq_msg_size(&self.zmq_msg)
+ *         return 1             # <<<<<<<<<<<<<<
+ * 
+ *     def __getreadbuffer__(self, Py_ssize_t idx, void **p):
+ */
+  __pyx_r = 1;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+#endif /*!(#if PY_MAJOR_VERSION < 3)*/
+
+/* Python wrapper */
+#if PY_MAJOR_VERSION < 3
+static Py_ssize_t __pyx_pw_3zmq_4core_7message_5Frame_11__getreadbuffer__(PyObject *__pyx_v_self, Py_ssize_t __pyx_v_idx, void **__pyx_v_p); /*proto*/
+static Py_ssize_t __pyx_pw_3zmq_4core_7message_5Frame_11__getreadbuffer__(PyObject *__pyx_v_self, Py_ssize_t __pyx_v_idx, void **__pyx_v_p) {
+  Py_ssize_t __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__getreadbuffer__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_10__getreadbuffer__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), ((Py_ssize_t)__pyx_v_idx), ((void **)__pyx_v_p));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+#endif /*!(#if PY_MAJOR_VERSION < 3)*/
+
+/* "zmq/core/message.pyx":184
+ *         return 1
+ * 
+ *     def __getreadbuffer__(self, Py_ssize_t idx, void **p):             # <<<<<<<<<<<<<<
+ *         # old-style (buffer) interface
+ *         cdef char *data_c = NULL
+ */
+
+#if PY_MAJOR_VERSION < 3
+static Py_ssize_t __pyx_pf_3zmq_4core_7message_5Frame_10__getreadbuffer__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, Py_ssize_t __pyx_v_idx, void **__pyx_v_p) {
+  char *__pyx_v_data_c;
+  Py_ssize_t __pyx_v_data_len_c;
+  Py_ssize_t __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__getreadbuffer__", 0);
+
+  /* "zmq/core/message.pyx":186
+ *     def __getreadbuffer__(self, Py_ssize_t idx, void **p):
+ *         # old-style (buffer) interface
+ *         cdef char *data_c = NULL             # <<<<<<<<<<<<<<
+ *         cdef Py_ssize_t data_len_c
+ *         if idx != 0:
+ */
+  __pyx_v_data_c = NULL;
+
+  /* "zmq/core/message.pyx":188
+ *         cdef char *data_c = NULL
+ *         cdef Py_ssize_t data_len_c
+ *         if idx != 0:             # <<<<<<<<<<<<<<
+ *             raise SystemError("accessing non-existent buffer segment")
+ *         # read-only, because we don't want to allow
+ */
+  __pyx_t_1 = (__pyx_v_idx != 0);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":189
+ *         cdef Py_ssize_t data_len_c
+ *         if idx != 0:
+ *             raise SystemError("accessing non-existent buffer segment")             # <<<<<<<<<<<<<<
+ *         # read-only, because we don't want to allow
+ *         # editing of the message in-place
+ */
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_SystemError, ((PyObject *)__pyx_k_tuple_6), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/message.pyx":192
+ *         # read-only, because we don't want to allow
+ *         # editing of the message in-place
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             data_c = <char *>zmq_msg_data(&self.zmq_msg)
+ *             data_len_c = zmq_msg_size(&self.zmq_msg)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/message.pyx":193
+ *         # editing of the message in-place
+ *         with nogil:
+ *             data_c = <char *>zmq_msg_data(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ *             data_len_c = zmq_msg_size(&self.zmq_msg)
+ *         if p != NULL:
+ */
+        __pyx_v_data_c = ((char *)zmq_msg_data((&__pyx_v_self->zmq_msg)));
+
+        /* "zmq/core/message.pyx":194
+ *         with nogil:
+ *             data_c = <char *>zmq_msg_data(&self.zmq_msg)
+ *             data_len_c = zmq_msg_size(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ *         if p != NULL:
+ *             p[0] = <void*>data_c
+ */
+        __pyx_v_data_len_c = zmq_msg_size((&__pyx_v_self->zmq_msg));
+      }
+
+      /* "zmq/core/message.pyx":192
+ *         # read-only, because we don't want to allow
+ *         # editing of the message in-place
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             data_c = <char *>zmq_msg_data(&self.zmq_msg)
+ *             data_len_c = zmq_msg_size(&self.zmq_msg)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/message.pyx":195
+ *             data_c = <char *>zmq_msg_data(&self.zmq_msg)
+ *             data_len_c = zmq_msg_size(&self.zmq_msg)
+ *         if p != NULL:             # <<<<<<<<<<<<<<
+ *             p[0] = <void*>data_c
+ *         return data_len_c
+ */
+  __pyx_t_1 = (__pyx_v_p != NULL);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":196
+ *             data_len_c = zmq_msg_size(&self.zmq_msg)
+ *         if p != NULL:
+ *             p[0] = <void*>data_c             # <<<<<<<<<<<<<<
+ *         return data_len_c
+ * 
+ */
+    (__pyx_v_p[0]) = ((void *)__pyx_v_data_c);
+    goto __pyx_L7;
+  }
+  __pyx_L7:;
+
+  /* "zmq/core/message.pyx":197
+ *         if p != NULL:
+ *             p[0] = <void*>data_c
+ *         return data_len_c             # <<<<<<<<<<<<<<
+ * 
+ *     # end buffer interface
+ */
+  __pyx_r = __pyx_v_data_len_c;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.message.Frame.__getreadbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+#endif /*!(#if PY_MAJOR_VERSION < 3)*/
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_13__copy__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_7message_5Frame_12__copy__[] = "Create a shallow copy of the message.\n\n        This does not copy the contents of the Frame, just the pointer.\n        This will increment the 0MQ ref count of the message, but not\n        the ref count of the Python object. That is only done once when\n        the Python is first turned into a 0MQ message.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_13__copy__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__copy__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_12__copy__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":201
+ *     # end buffer interface
+ * 
+ *     def __copy__(self):             # <<<<<<<<<<<<<<
+ *         """Create a shallow copy of the message.
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_12__copy__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__copy__", 0);
+
+  /* "zmq/core/message.pyx":209
+ *         the Python is first turned into a 0MQ message.
+ *         """
+ *         return self.fast_copy()             # <<<<<<<<<<<<<<
+ * 
+ *     cdef Frame fast_copy(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_3zmq_4core_7message_Frame *)__pyx_v_self->__pyx_vtab)->fast_copy(__pyx_v_self)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.message.Frame.__copy__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":211
+ *         return self.fast_copy()
+ * 
+ *     cdef Frame fast_copy(self):             # <<<<<<<<<<<<<<
+ *         """Fast, cdef'd version of shallow copy of the Frame."""
+ *         cdef Frame new_msg
+ */
+
+static struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_f_3zmq_4core_7message_5Frame_fast_copy(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_new_msg = 0;
+  struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("fast_copy", 0);
+
+  /* "zmq/core/message.pyx":214
+ *         """Fast, cdef'd version of shallow copy of the Frame."""
+ *         cdef Frame new_msg
+ *         new_msg = Frame()             # <<<<<<<<<<<<<<
+ *         # This does not copy the contents, but just increases the ref-count
+ *         # of the zmq_msg by one.
+ */
+  __pyx_t_1 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3zmq_4core_7message_Frame)), ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_new_msg = ((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "zmq/core/message.pyx":217
+ *         # This does not copy the contents, but just increases the ref-count
+ *         # of the zmq_msg by one.
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             zmq_msg_copy(&new_msg.zmq_msg, &self.zmq_msg)
+ *         # Copy the ref to data so the copy won't create a copy when str is
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/message.pyx":218
+ *         # of the zmq_msg by one.
+ *         with nogil:
+ *             zmq_msg_copy(&new_msg.zmq_msg, &self.zmq_msg)             # <<<<<<<<<<<<<<
+ *         # Copy the ref to data so the copy won't create a copy when str is
+ *         # called.
+ */
+        zmq_msg_copy((&__pyx_v_new_msg->zmq_msg), (&__pyx_v_self->zmq_msg));
+      }
+
+      /* "zmq/core/message.pyx":217
+ *         # This does not copy the contents, but just increases the ref-count
+ *         # of the zmq_msg by one.
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             zmq_msg_copy(&new_msg.zmq_msg, &self.zmq_msg)
+ *         # Copy the ref to data so the copy won't create a copy when str is
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/message.pyx":221
+ *         # Copy the ref to data so the copy won't create a copy when str is
+ *         # called.
+ *         if self._data is not None:             # <<<<<<<<<<<<<<
+ *             new_msg._data = self._data
+ *         if self._buffer is not None:
+ */
+  __pyx_t_2 = (__pyx_v_self->_data != Py_None);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/message.pyx":222
+ *         # called.
+ *         if self._data is not None:
+ *             new_msg._data = self._data             # <<<<<<<<<<<<<<
+ *         if self._buffer is not None:
+ *             new_msg._buffer = self._buffer
+ */
+    __pyx_t_1 = __pyx_v_self->_data;
+    __Pyx_INCREF(__pyx_t_1);
+    __Pyx_GIVEREF(__pyx_t_1);
+    __Pyx_GOTREF(__pyx_v_new_msg->_data);
+    __Pyx_DECREF(__pyx_v_new_msg->_data);
+    __pyx_v_new_msg->_data = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "zmq/core/message.pyx":223
+ *         if self._data is not None:
+ *             new_msg._data = self._data
+ *         if self._buffer is not None:             # <<<<<<<<<<<<<<
+ *             new_msg._buffer = self._buffer
+ *         if self._bytes is not None:
+ */
+  __pyx_t_2 = (__pyx_v_self->_buffer != Py_None);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/message.pyx":224
+ *             new_msg._data = self._data
+ *         if self._buffer is not None:
+ *             new_msg._buffer = self._buffer             # <<<<<<<<<<<<<<
+ *         if self._bytes is not None:
+ *             new_msg._bytes = self._bytes
+ */
+    __pyx_t_1 = __pyx_v_self->_buffer;
+    __Pyx_INCREF(__pyx_t_1);
+    __Pyx_GIVEREF(__pyx_t_1);
+    __Pyx_GOTREF(__pyx_v_new_msg->_buffer);
+    __Pyx_DECREF(__pyx_v_new_msg->_buffer);
+    __pyx_v_new_msg->_buffer = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L7;
+  }
+  __pyx_L7:;
+
+  /* "zmq/core/message.pyx":225
+ *         if self._buffer is not None:
+ *             new_msg._buffer = self._buffer
+ *         if self._bytes is not None:             # <<<<<<<<<<<<<<
+ *             new_msg._bytes = self._bytes
+ * 
+ */
+  __pyx_t_2 = (__pyx_v_self->_bytes != Py_None);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/message.pyx":226
+ *             new_msg._buffer = self._buffer
+ *         if self._bytes is not None:
+ *             new_msg._bytes = self._bytes             # <<<<<<<<<<<<<<
+ * 
+ *         # Frame copies share the tracker and tracker_event
+ */
+    __pyx_t_1 = __pyx_v_self->_bytes;
+    __Pyx_INCREF(__pyx_t_1);
+    __Pyx_GIVEREF(__pyx_t_1);
+    __Pyx_GOTREF(__pyx_v_new_msg->_bytes);
+    __Pyx_DECREF(__pyx_v_new_msg->_bytes);
+    __pyx_v_new_msg->_bytes = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L8;
+  }
+  __pyx_L8:;
+
+  /* "zmq/core/message.pyx":229
+ * 
+ *         # Frame copies share the tracker and tracker_event
+ *         new_msg.tracker_event = self.tracker_event             # <<<<<<<<<<<<<<
+ *         new_msg.tracker = self.tracker
+ * 
+ */
+  __pyx_t_1 = __pyx_v_self->tracker_event;
+  __Pyx_INCREF(__pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __Pyx_GOTREF(__pyx_v_new_msg->tracker_event);
+  __Pyx_DECREF(__pyx_v_new_msg->tracker_event);
+  __pyx_v_new_msg->tracker_event = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "zmq/core/message.pyx":230
+ *         # Frame copies share the tracker and tracker_event
+ *         new_msg.tracker_event = self.tracker_event
+ *         new_msg.tracker = self.tracker             # <<<<<<<<<<<<<<
+ * 
+ *         return new_msg
+ */
+  __pyx_t_1 = __pyx_v_self->tracker;
+  __Pyx_INCREF(__pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __Pyx_GOTREF(__pyx_v_new_msg->tracker);
+  __Pyx_DECREF(__pyx_v_new_msg->tracker);
+  __pyx_v_new_msg->tracker = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "zmq/core/message.pyx":232
+ *         new_msg.tracker = self.tracker
+ * 
+ *         return new_msg             # <<<<<<<<<<<<<<
+ * 
+ *     def __len__(self):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_new_msg));
+  __pyx_r = __pyx_v_new_msg;
+  goto __pyx_L0;
+
+  __pyx_r = ((struct __pyx_obj_3zmq_4core_7message_Frame *)Py_None); __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.message.Frame.fast_copy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_new_msg);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static Py_ssize_t __pyx_pw_3zmq_4core_7message_5Frame_15__len__(PyObject *__pyx_v_self); /*proto*/
+static char __pyx_doc_3zmq_4core_7message_5Frame_14__len__[] = "Return the length of the message in bytes.";
+#if CYTHON_COMPILING_IN_CPYTHON
+struct wrapperbase __pyx_wrapperbase_3zmq_4core_7message_5Frame_14__len__;
+#endif
+static Py_ssize_t __pyx_pw_3zmq_4core_7message_5Frame_15__len__(PyObject *__pyx_v_self) {
+  Py_ssize_t __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_14__len__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":234
+ *         return new_msg
+ * 
+ *     def __len__(self):             # <<<<<<<<<<<<<<
+ *         """Return the length of the message in bytes."""
+ *         cdef size_t sz
+ */
+
+static Py_ssize_t __pyx_pf_3zmq_4core_7message_5Frame_14__len__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  size_t __pyx_v_sz;
+  Py_ssize_t __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__len__", 0);
+
+  /* "zmq/core/message.pyx":237
+ *         """Return the length of the message in bytes."""
+ *         cdef size_t sz
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             sz = zmq_msg_size(&self.zmq_msg)
+ *         return sz
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/message.pyx":238
+ *         cdef size_t sz
+ *         with nogil:
+ *             sz = zmq_msg_size(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ *         return sz
+ *         # return <int>zmq_msg_size(&self.zmq_msg)
+ */
+        __pyx_v_sz = zmq_msg_size((&__pyx_v_self->zmq_msg));
+      }
+
+      /* "zmq/core/message.pyx":237
+ *         """Return the length of the message in bytes."""
+ *         cdef size_t sz
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             sz = zmq_msg_size(&self.zmq_msg)
+ *         return sz
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/message.pyx":239
+ *         with nogil:
+ *             sz = zmq_msg_size(&self.zmq_msg)
+ *         return sz             # <<<<<<<<<<<<<<
+ *         # return <int>zmq_msg_size(&self.zmq_msg)
+ * 
+ */
+  __pyx_r = __pyx_v_sz;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_17__str__(PyObject *__pyx_v_self); /*proto*/
+static char __pyx_doc_3zmq_4core_7message_5Frame_16__str__[] = "Return the str form of the message.";
+#if CYTHON_COMPILING_IN_CPYTHON
+struct wrapperbase __pyx_wrapperbase_3zmq_4core_7message_5Frame_16__str__;
+#endif
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_17__str__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_16__str__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":242
+ *         # return <int>zmq_msg_size(&self.zmq_msg)
+ * 
+ *     def __str__(self):             # <<<<<<<<<<<<<<
+ *         """Return the str form of the message."""
+ *         if isinstance(self._data, bytes):
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_16__str__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  PyObject *__pyx_v_b = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_3;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__str__", 0);
+
+  /* "zmq/core/message.pyx":244
+ *     def __str__(self):
+ *         """Return the str form of the message."""
+ *         if isinstance(self._data, bytes):             # <<<<<<<<<<<<<<
+ *             b = self._data
+ *         else:
+ */
+  __pyx_t_1 = __pyx_v_self->_data;
+  __Pyx_INCREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__bytes); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyObject_IsInstance(__pyx_t_1, __pyx_t_2); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (__pyx_t_3) {
+
+    /* "zmq/core/message.pyx":245
+ *         """Return the str form of the message."""
+ *         if isinstance(self._data, bytes):
+ *             b = self._data             # <<<<<<<<<<<<<<
+ *         else:
+ *             b = self.bytes
+ */
+    __pyx_t_2 = __pyx_v_self->_data;
+    __Pyx_INCREF(__pyx_t_2);
+    __pyx_v_b = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/message.pyx":247
+ *             b = self._data
+ *         else:
+ *             b = self.bytes             # <<<<<<<<<<<<<<
+ *         if str is unicode:
+ *             return b.decode()
+ */
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s__bytes); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_v_b = __pyx_t_2;
+    __pyx_t_2 = 0;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/message.pyx":248
+ *         else:
+ *             b = self.bytes
+ *         if str is unicode:             # <<<<<<<<<<<<<<
+ *             return b.decode()
+ *         else:
+ */
+  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__unicode); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = (((PyObject*)(&PyString_Type)) == ((PyObject*)__pyx_t_2));
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (__pyx_t_3) {
+
+    /* "zmq/core/message.pyx":249
+ *             b = self.bytes
+ *         if str is unicode:
+ *             return b.decode()             # <<<<<<<<<<<<<<
+ *         else:
+ *             return b
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_b, __pyx_n_s__decode); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_1 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L4;
+  }
+  /*else*/ {
+
+    /* "zmq/core/message.pyx":251
+ *             return b.decode()
+ *         else:
+ *             return b             # <<<<<<<<<<<<<<
+ * 
+ *     cdef inline object _getbuffer(self):
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(__pyx_v_b);
+    __pyx_r = __pyx_v_b;
+    goto __pyx_L0;
+  }
+  __pyx_L4:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.message.Frame.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_b);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":253
+ *             return b
+ * 
+ *     cdef inline object _getbuffer(self):             # <<<<<<<<<<<<<<
+ *         """Create a Python buffer/view of the message data.
+ * 
+ */
+
+static PyObject *__pyx_f_3zmq_4core_7message_5Frame__getbuffer(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_getbuffer", 0);
+
+  /* "zmq/core/message.pyx":259
+ *         is accessed. Subsequent calls use a cached copy.
+ *         """
+ *         if self._data is None:             # <<<<<<<<<<<<<<
+ *             return viewfromobject_r(self)
+ *         else:
+ */
+  __pyx_t_1 = (__pyx_v_self->_data == Py_None);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":260
+ *         """
+ *         if self._data is None:
+ *             return viewfromobject_r(self)             # <<<<<<<<<<<<<<
+ *         else:
+ *             return viewfromobject_r(self._data)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = __pyx_f_7buffers_viewfromobject_r(((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/message.pyx":262
+ *             return viewfromobject_r(self)
+ *         else:
+ *             return viewfromobject_r(self._data)             # <<<<<<<<<<<<<<
+ * 
+ *     @property
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = __pyx_v_self->_data;
+    __Pyx_INCREF(__pyx_t_2);
+    __pyx_t_3 = __pyx_f_7buffers_viewfromobject_r(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.message.Frame._getbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_19buffer(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_7message_5Frame_18buffer[] = "Get a read-only buffer view of the message contents.";
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_19buffer(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("buffer (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_18buffer(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":265
+ * 
+ *     @property
+ *     def buffer(self):             # <<<<<<<<<<<<<<
+ *         """Get a read-only buffer view of the message contents."""
+ *         if self._buffer is None:
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_18buffer(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("buffer", 0);
+
+  /* "zmq/core/message.pyx":267
+ *     def buffer(self):
+ *         """Get a read-only buffer view of the message contents."""
+ *         if self._buffer is None:             # <<<<<<<<<<<<<<
+ *             self._buffer = self._getbuffer()
+ *         return self._buffer
+ */
+  __pyx_t_1 = (__pyx_v_self->_buffer == Py_None);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":268
+ *         """Get a read-only buffer view of the message contents."""
+ *         if self._buffer is None:
+ *             self._buffer = self._getbuffer()             # <<<<<<<<<<<<<<
+ *         return self._buffer
+ * 
+ */
+    __pyx_t_2 = __pyx_f_3zmq_4core_7message_5Frame__getbuffer(__pyx_v_self); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_2);
+    __Pyx_GOTREF(__pyx_v_self->_buffer);
+    __Pyx_DECREF(__pyx_v_self->_buffer);
+    __pyx_v_self->_buffer = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/message.pyx":269
+ *         if self._buffer is None:
+ *             self._buffer = self._getbuffer()
+ *         return self._buffer             # <<<<<<<<<<<<<<
+ * 
+ *     @property
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->_buffer);
+  __pyx_r = __pyx_v_self->_buffer;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.message.Frame.buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_21bytes(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_7message_5Frame_20bytes[] = "Get the message content as a Python str/bytes object.\n\n        The first time this property is accessed, a copy of the message \n        contents is made. From then on that same copy of the message is\n        returned.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_21bytes(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("bytes (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_20bytes(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":272
+ * 
+ *     @property
+ *     def bytes(self):             # <<<<<<<<<<<<<<
+ *         """Get the message content as a Python str/bytes object.
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_20bytes(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("bytes", 0);
+
+  /* "zmq/core/message.pyx":279
+ *         returned.
+ *         """
+ *         if self._bytes is None:             # <<<<<<<<<<<<<<
+ *             self._bytes = copy_zmq_msg_bytes(&self.zmq_msg)
+ *         return self._bytes
+ */
+  __pyx_t_1 = (__pyx_v_self->_bytes == Py_None);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/message.pyx":280
+ *         """
+ *         if self._bytes is None:
+ *             self._bytes = copy_zmq_msg_bytes(&self.zmq_msg)             # <<<<<<<<<<<<<<
+ *         return self._bytes
+ * 
+ */
+    __pyx_t_2 = __pyx_f_3zmq_4core_7message_copy_zmq_msg_bytes((&__pyx_v_self->zmq_msg)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_2);
+    __Pyx_GOTREF(__pyx_v_self->_bytes);
+    __Pyx_DECREF(__pyx_v_self->_bytes);
+    __pyx_v_self->_bytes = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/message.pyx":281
+ *         if self._bytes is None:
+ *             self._bytes = copy_zmq_msg_bytes(&self.zmq_msg)
+ *         return self._bytes             # <<<<<<<<<<<<<<
+ * 
+ *     def set(self, int option, int value):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->_bytes);
+  __pyx_r = __pyx_v_self->_bytes;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.message.Frame.bytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_23set(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_7message_5Frame_22set[] = "Set a message property";
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_23set(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_v_option;
+  int __pyx_v_value;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("set (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__option,&__pyx_n_s__value,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__option)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__value)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("set", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_option = __Pyx_PyInt_AsInt(values[0]); if (unlikely((__pyx_v_option == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    __pyx_v_value = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_value == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("set", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.message.Frame.set", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_22set(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), __pyx_v_option, __pyx_v_value);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":283
+ *         return self._bytes
+ * 
+ *     def set(self, int option, int value):             # <<<<<<<<<<<<<<
+ *         """Set a message property"""
+ *         cdef int rc = zmq_msg_set(&self.zmq_msg, option, value)
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_22set(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, int __pyx_v_option, int __pyx_v_value) {
+  int __pyx_v_rc;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("set", 0);
+
+  /* "zmq/core/message.pyx":285
+ *     def set(self, int option, int value):
+ *         """Set a message property"""
+ *         cdef int rc = zmq_msg_set(&self.zmq_msg, option, value)             # <<<<<<<<<<<<<<
+ *         _check_rc(rc)
+ * 
+ */
+  __pyx_v_rc = zmq_msg_set((&__pyx_v_self->zmq_msg), __pyx_v_option, __pyx_v_value);
+
+  /* "zmq/core/message.pyx":286
+ *         """Set a message property"""
+ *         cdef int rc = zmq_msg_set(&self.zmq_msg, option, value)
+ *         _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *     def get(self, int option):
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 286; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("zmq.core.message.Frame.set", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_25get(PyObject *__pyx_v_self, PyObject *__pyx_arg_option); /*proto*/
+static char __pyx_doc_3zmq_4core_7message_5Frame_24get[] = "Get a message property";
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_25get(PyObject *__pyx_v_self, PyObject *__pyx_arg_option) {
+  int __pyx_v_option;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get (wrapper)", 0);
+  assert(__pyx_arg_option); {
+    __pyx_v_option = __Pyx_PyInt_AsInt(__pyx_arg_option); if (unlikely((__pyx_v_option == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 288; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.message.Frame.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_24get(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), ((int)__pyx_v_option));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pyx":288
+ *         _check_rc(rc)
+ * 
+ *     def get(self, int option):             # <<<<<<<<<<<<<<
+ *         """Get a message property"""
+ *         cdef int rc = zmq_msg_get(&self.zmq_msg, option)
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_24get(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, int __pyx_v_option) {
+  int __pyx_v_rc;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get", 0);
+
+  /* "zmq/core/message.pyx":290
+ *     def get(self, int option):
+ *         """Get a message property"""
+ *         cdef int rc = zmq_msg_get(&self.zmq_msg, option)             # <<<<<<<<<<<<<<
+ *         _check_rc(rc)
+ *         return rc
+ */
+  __pyx_v_rc = zmq_msg_get((&__pyx_v_self->zmq_msg), __pyx_v_option);
+
+  /* "zmq/core/message.pyx":291
+ *         """Get a message property"""
+ *         cdef int rc = zmq_msg_get(&self.zmq_msg, option)
+ *         _check_rc(rc)             # <<<<<<<<<<<<<<
+ *         return rc
+ * 
+ */
+  __pyx_t_1 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/message.pyx":292
+ *         cdef int rc = zmq_msg_get(&self.zmq_msg, option)
+ *         _check_rc(rc)
+ *         return rc             # <<<<<<<<<<<<<<
+ * 
+ * # legacy Message name
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = PyInt_FromLong(__pyx_v_rc); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.message.Frame.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_13tracker_event___get__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pxd":49
+ *     cdef object _bytes     # A bytes/str copy of the message.
+ *     cdef bint _failed_init # Flag to handle failed zmq_msg_init
+ *     cdef public object tracker_event  # Event for use with zmq_free_fn.             # <<<<<<<<<<<<<<
+ *     cdef public object tracker        # MessageTracker object.
+ *     cdef public bint more             # whether RCVMORE was set
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_13tracker_event___get__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->tracker_event);
+  __pyx_r = __pyx_v_self->tracker_event;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
+static int __pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_13tracker_event_2__set__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), ((PyObject *)__pyx_v_value));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7message_5Frame_13tracker_event_2__set__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__", 0);
+  __Pyx_INCREF(__pyx_v_value);
+  __Pyx_GIVEREF(__pyx_v_value);
+  __Pyx_GOTREF(__pyx_v_self->tracker_event);
+  __Pyx_DECREF(__pyx_v_self->tracker_event);
+  __pyx_v_self->tracker_event = __pyx_v_value;
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_5__del__(PyObject *__pyx_v_self); /*proto*/
+static int __pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_5__del__(PyObject *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_13tracker_event_4__del__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7message_5Frame_13tracker_event_4__del__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__", 0);
+  __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(Py_None);
+  __Pyx_GOTREF(__pyx_v_self->tracker_event);
+  __Pyx_DECREF(__pyx_v_self->tracker_event);
+  __pyx_v_self->tracker_event = Py_None;
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_7tracker_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_7tracker_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_7tracker___get__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pxd":50
+ *     cdef bint _failed_init # Flag to handle failed zmq_msg_init
+ *     cdef public object tracker_event  # Event for use with zmq_free_fn.
+ *     cdef public object tracker        # MessageTracker object.             # <<<<<<<<<<<<<<
+ *     cdef public bint more             # whether RCVMORE was set
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_7tracker___get__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->tracker);
+  __pyx_r = __pyx_v_self->tracker;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7message_5Frame_7tracker_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
+static int __pyx_pw_3zmq_4core_7message_5Frame_7tracker_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_7tracker_2__set__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), ((PyObject *)__pyx_v_value));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7message_5Frame_7tracker_2__set__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__", 0);
+  __Pyx_INCREF(__pyx_v_value);
+  __Pyx_GIVEREF(__pyx_v_value);
+  __Pyx_GOTREF(__pyx_v_self->tracker);
+  __Pyx_DECREF(__pyx_v_self->tracker);
+  __pyx_v_self->tracker = __pyx_v_value;
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7message_5Frame_7tracker_5__del__(PyObject *__pyx_v_self); /*proto*/
+static int __pyx_pw_3zmq_4core_7message_5Frame_7tracker_5__del__(PyObject *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_7tracker_4__del__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7message_5Frame_7tracker_4__del__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__", 0);
+  __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(Py_None);
+  __Pyx_GOTREF(__pyx_v_self->tracker);
+  __Pyx_DECREF(__pyx_v_self->tracker);
+  __pyx_v_self->tracker = Py_None;
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_4more_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_7message_5Frame_4more_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_4more___get__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pxd":51
+ *     cdef public object tracker_event  # Event for use with zmq_free_fn.
+ *     cdef public object tracker        # MessageTracker object.
+ *     cdef public bint more             # whether RCVMORE was set             # <<<<<<<<<<<<<<
+ * 
+ *     cdef Frame fast_copy(self) # Create shallow copy of Message object.
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7message_5Frame_4more___get__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->more); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.message.Frame.more.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7message_5Frame_4more_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
+static int __pyx_pw_3zmq_4core_7message_5Frame_4more_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7message_5Frame_4more_2__set__(((struct __pyx_obj_3zmq_4core_7message_Frame *)__pyx_v_self), ((PyObject *)__pyx_v_value));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7message_5Frame_4more_2__set__(struct __pyx_obj_3zmq_4core_7message_Frame *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__set__", 0);
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_self->more = __pyx_t_1;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("zmq.core.message.Frame.more.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/checkrc.pxd":5
+ * from libzmq cimport zmq_errno, ZMQ_ETERM
+ * 
+ * cdef inline int _check_rc(int rc) except -1:             # <<<<<<<<<<<<<<
+ *     """internal utility for checking zmq return condition
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int __pyx_v_rc) {
+  int __pyx_v_errno;
+  PyObject *__pyx_v_Again = NULL;
+  PyObject *__pyx_v_ContextTerminated = NULL;
+  PyObject *__pyx_v_ZMQError = NULL;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_check_rc", 0);
+
+  /* "zmq/core/checkrc.pxd":10
+ *     and raising the appropriate Exception class
+ *     """
+ *     cdef int errno = zmq_errno()             # <<<<<<<<<<<<<<
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ */
+  __pyx_v_errno = zmq_errno();
+
+  /* "zmq/core/checkrc.pxd":11
+ *     """
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()             # <<<<<<<<<<<<<<
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ */
+  __pyx_t_1 = PyErr_CheckSignals(); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/checkrc.pxd":12
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()
+ *     if rc < 0:             # <<<<<<<<<<<<<<
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ */
+  __pyx_t_2 = (__pyx_v_rc < 0);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+    switch (__pyx_v_errno) {
+
+      /* "zmq/core/checkrc.pxd":13
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ *         if errno == EAGAIN:             # <<<<<<<<<<<<<<
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ */
+      case EAGAIN:
+
+      /* "zmq/core/checkrc.pxd":14
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again             # <<<<<<<<<<<<<<
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__Again));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__Again));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Again));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_7), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__Again); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_Again = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":15
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ *             raise Again(errno)             # <<<<<<<<<<<<<<
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_Again, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+
+      /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+      case ETERM:
+
+      /* "zmq/core/checkrc.pxd":17
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated             # <<<<<<<<<<<<<<
+ *             raise ContextTerminated(errno)
+ *         else:
+ */
+      __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      PyList_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_n_s__ContextTerminated));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      __pyx_t_3 = __Pyx_Import(((PyObject *)__pyx_n_s_7), ((PyObject *)__pyx_t_4), -1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__ContextTerminated); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_4);
+      __pyx_v_ContextTerminated = __pyx_t_4;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+      /* "zmq/core/checkrc.pxd":18
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)             # <<<<<<<<<<<<<<
+ *         else:
+ *             from zmq.error import ZMQError
+ */
+      __pyx_t_3 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_3);
+      __pyx_t_3 = 0;
+      __pyx_t_3 = PyObject_Call(__pyx_v_ContextTerminated, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+      default:
+
+      /* "zmq/core/checkrc.pxd":20
+ *             raise ContextTerminated(errno)
+ *         else:
+ *             from zmq.error import ZMQError             # <<<<<<<<<<<<<<
+ *             raise ZMQError(errno)
+ *         # return -1
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQError));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__ZMQError));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQError));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_7), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__ZMQError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_ZMQError = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":21
+ *         else:
+ *             from zmq.error import ZMQError
+ *             raise ZMQError(errno)             # <<<<<<<<<<<<<<
+ *         # return -1
+ *     return 0
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_ZMQError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+    }
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/checkrc.pxd":23
+ *             raise ZMQError(errno)
+ *         # return -1
+ *     return 0             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = 0;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.checkrc._check_rc", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_Again);
+  __Pyx_XDECREF(__pyx_v_ContextTerminated);
+  __Pyx_XDECREF(__pyx_v_ZMQError);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/message.pxd":57
+ * 
+ * 
+ * cdef inline object copy_zmq_msg_bytes(zmq_msg_t *zmq_msg):             # <<<<<<<<<<<<<<
+ *     """ Copy the data from a zmq_msg_t """
+ *     cdef char *data_c = NULL
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_3zmq_4core_7message_copy_zmq_msg_bytes(zmq_msg_t *__pyx_v_zmq_msg) {
+  char *__pyx_v_data_c;
+  Py_ssize_t __pyx_v_data_len_c;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("copy_zmq_msg_bytes", 0);
+
+  /* "zmq/core/message.pxd":59
+ * cdef inline object copy_zmq_msg_bytes(zmq_msg_t *zmq_msg):
+ *     """ Copy the data from a zmq_msg_t """
+ *     cdef char *data_c = NULL             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t data_len_c
+ *     with nogil:
+ */
+  __pyx_v_data_c = NULL;
+
+  /* "zmq/core/message.pxd":61
+ *     cdef char *data_c = NULL
+ *     cdef Py_ssize_t data_len_c
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         data_c = <char *>zmq_msg_data(zmq_msg)
+ *         data_len_c = zmq_msg_size(zmq_msg)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/message.pxd":62
+ *     cdef Py_ssize_t data_len_c
+ *     with nogil:
+ *         data_c = <char *>zmq_msg_data(zmq_msg)             # <<<<<<<<<<<<<<
+ *         data_len_c = zmq_msg_size(zmq_msg)
+ *     return PyBytes_FromStringAndSize(data_c, data_len_c)
+ */
+        __pyx_v_data_c = ((char *)zmq_msg_data(__pyx_v_zmq_msg));
+
+        /* "zmq/core/message.pxd":63
+ *     with nogil:
+ *         data_c = <char *>zmq_msg_data(zmq_msg)
+ *         data_len_c = zmq_msg_size(zmq_msg)             # <<<<<<<<<<<<<<
+ *     return PyBytes_FromStringAndSize(data_c, data_len_c)
+ * 
+ */
+        __pyx_v_data_len_c = zmq_msg_size(__pyx_v_zmq_msg);
+      }
+
+      /* "zmq/core/message.pxd":61
+ *     cdef char *data_c = NULL
+ *     cdef Py_ssize_t data_len_c
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         data_c = <char *>zmq_msg_data(zmq_msg)
+ *         data_len_c = zmq_msg_size(zmq_msg)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/message.pxd":64
+ *         data_c = <char *>zmq_msg_data(zmq_msg)
+ *         data_len_c = zmq_msg_size(zmq_msg)
+ *     return PyBytes_FromStringAndSize(data_c, data_len_c)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = ((PyObject *)PyBytes_FromStringAndSize(__pyx_v_data_c, __pyx_v_data_len_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.message.copy_zmq_msg_bytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":88
+ * 
+ * 
+ * cdef inline int memoryview_available():             # <<<<<<<<<<<<<<
+ *     return PY_MAJOR_VERSION >= 3 or (PY_MAJOR_VERSION >=2 and PY_MINOR_VERSION >= 7)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7buffers_memoryview_available(void) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  int __pyx_t_4;
+  __Pyx_RefNannySetupContext("memoryview_available", 0);
+
+  /* "buffers.pxd":89
+ * 
+ * cdef inline int memoryview_available():
+ *     return PY_MAJOR_VERSION >= 3 or (PY_MAJOR_VERSION >=2 and PY_MINOR_VERSION >= 7)             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline int oldstyle_available():
+ */
+  __pyx_t_1 = (PY_MAJOR_VERSION >= 3);
+  if (!__pyx_t_1) {
+    __pyx_t_2 = (PY_MAJOR_VERSION >= 2);
+    if (__pyx_t_2) {
+      __pyx_t_3 = (PY_MINOR_VERSION >= 7);
+      __pyx_t_4 = __pyx_t_3;
+    } else {
+      __pyx_t_4 = __pyx_t_2;
+    }
+    __pyx_t_2 = __pyx_t_4;
+  } else {
+    __pyx_t_2 = __pyx_t_1;
+  }
+  __pyx_r = __pyx_t_2;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":91
+ *     return PY_MAJOR_VERSION >= 3 or (PY_MAJOR_VERSION >=2 and PY_MINOR_VERSION >= 7)
+ * 
+ * cdef inline int oldstyle_available():             # <<<<<<<<<<<<<<
+ *     return PY_MAJOR_VERSION < 3
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7buffers_oldstyle_available(void) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("oldstyle_available", 0);
+
+  /* "buffers.pxd":92
+ * 
+ * cdef inline int oldstyle_available():
+ *     return PY_MAJOR_VERSION < 3             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = (PY_MAJOR_VERSION < 3);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":95
+ * 
+ * 
+ * cdef inline int check_buffer(object ob):             # <<<<<<<<<<<<<<
+ *     """Version independent check for whether an object is a buffer.
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7buffers_check_buffer(PyObject *__pyx_v_ob) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  long __pyx_t_2;
+  __Pyx_RefNannySetupContext("check_buffer", 0);
+
+  /* "buffers.pxd":107
+ *     int : 0 if no buffer interface, 3 if newstyle buffer interface, 2 if oldstyle.
+ *     """
+ *     if PyObject_CheckBuffer(ob):             # <<<<<<<<<<<<<<
+ *         return 3
+ *     if oldstyle_available():
+ */
+  __pyx_t_1 = PyObject_CheckBuffer(__pyx_v_ob);
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":108
+ *     """
+ *     if PyObject_CheckBuffer(ob):
+ *         return 3             # <<<<<<<<<<<<<<
+ *     if oldstyle_available():
+ *         return PyObject_CheckReadBuffer(ob) and 2
+ */
+    __pyx_r = 3;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "buffers.pxd":109
+ *     if PyObject_CheckBuffer(ob):
+ *         return 3
+ *     if oldstyle_available():             # <<<<<<<<<<<<<<
+ *         return PyObject_CheckReadBuffer(ob) and 2
+ *     return 0
+ */
+  __pyx_t_1 = __pyx_f_7buffers_oldstyle_available();
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":110
+ *         return 3
+ *     if oldstyle_available():
+ *         return PyObject_CheckReadBuffer(ob) and 2             # <<<<<<<<<<<<<<
+ *     return 0
+ * 
+ */
+    __pyx_t_1 = PyObject_CheckReadBuffer(__pyx_v_ob);
+    if (__pyx_t_1) {
+      __pyx_t_2 = 2;
+    } else {
+      __pyx_t_2 = __pyx_t_1;
+    }
+    __pyx_r = __pyx_t_2;
+    goto __pyx_L0;
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "buffers.pxd":111
+ *     if oldstyle_available():
+ *         return PyObject_CheckReadBuffer(ob) and 2
+ *     return 0             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = 0;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":114
+ * 
+ * 
+ * cdef inline object asbuffer(object ob, int writable, int format,             # <<<<<<<<<<<<<<
+ *                             void **base, Py_ssize_t *size,
+ *                             Py_ssize_t *itemsize):
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer(PyObject *__pyx_v_ob, int __pyx_v_writable, int __pyx_v_format, void **__pyx_v_base, Py_ssize_t *__pyx_v_size, Py_ssize_t *__pyx_v_itemsize) {
+  void *__pyx_v_bptr;
+  Py_ssize_t __pyx_v_blen;
+  Py_ssize_t __pyx_v_bitemlen;
+  Py_buffer __pyx_v_view;
+  int __pyx_v_flags;
+  int __pyx_v_mode;
+  PyObject *__pyx_v_bfmt = NULL;
+  PyObject *__pyx_v_dtype = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  void *__pyx_t_5;
+  Py_ssize_t __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  PyObject *__pyx_t_13 = NULL;
+  PyObject *__pyx_t_14 = NULL;
+  PyObject *__pyx_t_15 = NULL;
+  PyObject *__pyx_t_16 = NULL;
+  int __pyx_t_17;
+  int __pyx_t_18;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("asbuffer", 0);
+
+  /* "buffers.pxd":141
+ *     """
+ * 
+ *     cdef void *bptr = NULL             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t blen = 0, bitemlen = 0
+ *     cdef Py_buffer view
+ */
+  __pyx_v_bptr = NULL;
+
+  /* "buffers.pxd":142
+ * 
+ *     cdef void *bptr = NULL
+ *     cdef Py_ssize_t blen = 0, bitemlen = 0             # <<<<<<<<<<<<<<
+ *     cdef Py_buffer view
+ *     cdef int flags = PyBUF_SIMPLE
+ */
+  __pyx_v_blen = 0;
+  __pyx_v_bitemlen = 0;
+
+  /* "buffers.pxd":144
+ *     cdef Py_ssize_t blen = 0, bitemlen = 0
+ *     cdef Py_buffer view
+ *     cdef int flags = PyBUF_SIMPLE             # <<<<<<<<<<<<<<
+ *     cdef int mode = 0
+ * 
+ */
+  __pyx_v_flags = PyBUF_SIMPLE;
+
+  /* "buffers.pxd":145
+ *     cdef Py_buffer view
+ *     cdef int flags = PyBUF_SIMPLE
+ *     cdef int mode = 0             # <<<<<<<<<<<<<<
+ * 
+ *     bfmt = None
+ */
+  __pyx_v_mode = 0;
+
+  /* "buffers.pxd":147
+ *     cdef int mode = 0
+ * 
+ *     bfmt = None             # <<<<<<<<<<<<<<
+ * 
+ *     mode = check_buffer(ob)
+ */
+  __Pyx_INCREF(Py_None);
+  __pyx_v_bfmt = Py_None;
+
+  /* "buffers.pxd":149
+ *     bfmt = None
+ * 
+ *     mode = check_buffer(ob)             # <<<<<<<<<<<<<<
+ *     if mode == 0:
+ *         raise TypeError("%r does not provide a buffer interface."%ob)
+ */
+  __pyx_v_mode = __pyx_f_7buffers_check_buffer(__pyx_v_ob);
+
+  /* "buffers.pxd":150
+ * 
+ *     mode = check_buffer(ob)
+ *     if mode == 0:             # <<<<<<<<<<<<<<
+ *         raise TypeError("%r does not provide a buffer interface."%ob)
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_mode == 0);
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":151
+ *     mode = check_buffer(ob)
+ *     if mode == 0:
+ *         raise TypeError("%r does not provide a buffer interface."%ob)             # <<<<<<<<<<<<<<
+ * 
+ *     if mode == 3:
+ */
+    __pyx_t_2 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_8), __pyx_v_ob); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_2));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_2));
+    __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[3]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "buffers.pxd":153
+ *         raise TypeError("%r does not provide a buffer interface."%ob)
+ * 
+ *     if mode == 3:             # <<<<<<<<<<<<<<
+ *         flags = PyBUF_ANY_CONTIGUOUS
+ *         if writable:
+ */
+  __pyx_t_1 = (__pyx_v_mode == 3);
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":154
+ * 
+ *     if mode == 3:
+ *         flags = PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
+ *         if writable:
+ *             flags |= PyBUF_WRITABLE
+ */
+    __pyx_v_flags = PyBUF_ANY_CONTIGUOUS;
+
+    /* "buffers.pxd":155
+ *     if mode == 3:
+ *         flags = PyBUF_ANY_CONTIGUOUS
+ *         if writable:             # <<<<<<<<<<<<<<
+ *             flags |= PyBUF_WRITABLE
+ *         if format:
+ */
+    if (__pyx_v_writable) {
+
+      /* "buffers.pxd":156
+ *         flags = PyBUF_ANY_CONTIGUOUS
+ *         if writable:
+ *             flags |= PyBUF_WRITABLE             # <<<<<<<<<<<<<<
+ *         if format:
+ *             flags |= PyBUF_FORMAT
+ */
+      __pyx_v_flags = (__pyx_v_flags | PyBUF_WRITABLE);
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "buffers.pxd":157
+ *         if writable:
+ *             flags |= PyBUF_WRITABLE
+ *         if format:             # <<<<<<<<<<<<<<
+ *             flags |= PyBUF_FORMAT
+ *         PyObject_GetBuffer(ob, &view, flags)
+ */
+    if (__pyx_v_format) {
+
+      /* "buffers.pxd":158
+ *             flags |= PyBUF_WRITABLE
+ *         if format:
+ *             flags |= PyBUF_FORMAT             # <<<<<<<<<<<<<<
+ *         PyObject_GetBuffer(ob, &view, flags)
+ *         bptr = view.buf
+ */
+      __pyx_v_flags = (__pyx_v_flags | PyBUF_FORMAT);
+      goto __pyx_L6;
+    }
+    __pyx_L6:;
+
+    /* "buffers.pxd":159
+ *         if format:
+ *             flags |= PyBUF_FORMAT
+ *         PyObject_GetBuffer(ob, &view, flags)             # <<<<<<<<<<<<<<
+ *         bptr = view.buf
+ *         blen = view.len
+ */
+    __pyx_t_4 = PyObject_GetBuffer(__pyx_v_ob, (&__pyx_v_view), __pyx_v_flags); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "buffers.pxd":160
+ *             flags |= PyBUF_FORMAT
+ *         PyObject_GetBuffer(ob, &view, flags)
+ *         bptr = view.buf             # <<<<<<<<<<<<<<
+ *         blen = view.len
+ *         if format:
+ */
+    __pyx_t_5 = __pyx_v_view.buf;
+    __pyx_v_bptr = __pyx_t_5;
+
+    /* "buffers.pxd":161
+ *         PyObject_GetBuffer(ob, &view, flags)
+ *         bptr = view.buf
+ *         blen = view.len             # <<<<<<<<<<<<<<
+ *         if format:
+ *             if view.format != NULL:
+ */
+    __pyx_t_6 = __pyx_v_view.len;
+    __pyx_v_blen = __pyx_t_6;
+
+    /* "buffers.pxd":162
+ *         bptr = view.buf
+ *         blen = view.len
+ *         if format:             # <<<<<<<<<<<<<<
+ *             if view.format != NULL:
+ *                 bfmt = view.format
+ */
+    if (__pyx_v_format) {
+
+      /* "buffers.pxd":163
+ *         blen = view.len
+ *         if format:
+ *             if view.format != NULL:             # <<<<<<<<<<<<<<
+ *                 bfmt = view.format
+ *                 bitemlen = view.itemsize
+ */
+      __pyx_t_1 = (__pyx_v_view.format != NULL);
+      if (__pyx_t_1) {
+
+        /* "buffers.pxd":164
+ *         if format:
+ *             if view.format != NULL:
+ *                 bfmt = view.format             # <<<<<<<<<<<<<<
+ *                 bitemlen = view.itemsize
+ *         PyBuffer_Release(&view)
+ */
+        __pyx_t_2 = __Pyx_PyBytes_FromString(__pyx_v_view.format); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+        __Pyx_DECREF(__pyx_v_bfmt);
+        __pyx_v_bfmt = ((PyObject *)__pyx_t_2);
+        __pyx_t_2 = 0;
+
+        /* "buffers.pxd":165
+ *             if view.format != NULL:
+ *                 bfmt = view.format
+ *                 bitemlen = view.itemsize             # <<<<<<<<<<<<<<
+ *         PyBuffer_Release(&view)
+ *     else: # oldstyle
+ */
+        __pyx_t_6 = __pyx_v_view.itemsize;
+        __pyx_v_bitemlen = __pyx_t_6;
+        goto __pyx_L8;
+      }
+      __pyx_L8:;
+      goto __pyx_L7;
+    }
+    __pyx_L7:;
+
+    /* "buffers.pxd":166
+ *                 bfmt = view.format
+ *                 bitemlen = view.itemsize
+ *         PyBuffer_Release(&view)             # <<<<<<<<<<<<<<
+ *     else: # oldstyle
+ *         if writable:
+ */
+    PyBuffer_Release((&__pyx_v_view));
+    goto __pyx_L4;
+  }
+  /*else*/ {
+
+    /* "buffers.pxd":168
+ *         PyBuffer_Release(&view)
+ *     else: # oldstyle
+ *         if writable:             # <<<<<<<<<<<<<<
+ *             PyObject_AsWriteBuffer(ob, &bptr, &blen)
+ *         else:
+ */
+    if (__pyx_v_writable) {
+
+      /* "buffers.pxd":169
+ *     else: # oldstyle
+ *         if writable:
+ *             PyObject_AsWriteBuffer(ob, &bptr, &blen)             # <<<<<<<<<<<<<<
+ *         else:
+ *             PyObject_AsReadBuffer(ob, <const_void **>&bptr, &blen)
+ */
+      __pyx_t_4 = PyObject_AsWriteBuffer(__pyx_v_ob, (&__pyx_v_bptr), (&__pyx_v_blen)); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L9;
+    }
+    /*else*/ {
+
+      /* "buffers.pxd":171
+ *             PyObject_AsWriteBuffer(ob, &bptr, &blen)
+ *         else:
+ *             PyObject_AsReadBuffer(ob, <const_void **>&bptr, &blen)             # <<<<<<<<<<<<<<
+ *         if format:
+ *             try: # numpy.ndarray
+ */
+      __pyx_t_4 = PyObject_AsReadBuffer(__pyx_v_ob, ((const void **)(&__pyx_v_bptr)), (&__pyx_v_blen)); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    __pyx_L9:;
+
+    /* "buffers.pxd":172
+ *         else:
+ *             PyObject_AsReadBuffer(ob, <const_void **>&bptr, &blen)
+ *         if format:             # <<<<<<<<<<<<<<
+ *             try: # numpy.ndarray
+ *                 dtype = ob.dtype
+ */
+    if (__pyx_v_format) {
+
+      /* "buffers.pxd":173
+ *             PyObject_AsReadBuffer(ob, <const_void **>&bptr, &blen)
+ *         if format:
+ *             try: # numpy.ndarray             # <<<<<<<<<<<<<<
+ *                 dtype = ob.dtype
+ *                 bfmt = dtype.char
+ */
+      {
+        __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
+        __Pyx_XGOTREF(__pyx_t_7);
+        __Pyx_XGOTREF(__pyx_t_8);
+        __Pyx_XGOTREF(__pyx_t_9);
+        /*try:*/ {
+
+          /* "buffers.pxd":174
+ *         if format:
+ *             try: # numpy.ndarray
+ *                 dtype = ob.dtype             # <<<<<<<<<<<<<<
+ *                 bfmt = dtype.char
+ *                 bitemlen = dtype.itemsize
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_ob, __pyx_n_s__dtype); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L11_error;}
+          __Pyx_GOTREF(__pyx_t_2);
+          __pyx_v_dtype = __pyx_t_2;
+          __pyx_t_2 = 0;
+
+          /* "buffers.pxd":175
+ *             try: # numpy.ndarray
+ *                 dtype = ob.dtype
+ *                 bfmt = dtype.char             # <<<<<<<<<<<<<<
+ *                 bitemlen = dtype.itemsize
+ *             except AttributeError:
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_dtype, __pyx_n_s__char); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L11_error;}
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_v_bfmt);
+          __pyx_v_bfmt = __pyx_t_2;
+          __pyx_t_2 = 0;
+
+          /* "buffers.pxd":176
+ *                 dtype = ob.dtype
+ *                 bfmt = dtype.char
+ *                 bitemlen = dtype.itemsize             # <<<<<<<<<<<<<<
+ *             except AttributeError:
+ *                 try: # array.array
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_dtype, __pyx_n_s__itemsize); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L11_error;}
+          __Pyx_GOTREF(__pyx_t_2);
+          __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_t_2); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L11_error;}
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __pyx_v_bitemlen = __pyx_t_6;
+        }
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
+        goto __pyx_L18_try_end;
+        __pyx_L11_error:;
+        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+        /* "buffers.pxd":177
+ *                 bfmt = dtype.char
+ *                 bitemlen = dtype.itemsize
+ *             except AttributeError:             # <<<<<<<<<<<<<<
+ *                 try: # array.array
+ *                     bfmt = ob.typecode
+ */
+        __pyx_t_4 = PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
+        if (__pyx_t_4) {
+          __Pyx_AddTraceback("buffers.asbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+          if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_3, &__pyx_t_10) < 0) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L13_except_error;}
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_GOTREF(__pyx_t_3);
+          __Pyx_GOTREF(__pyx_t_10);
+
+          /* "buffers.pxd":178
+ *                 bitemlen = dtype.itemsize
+ *             except AttributeError:
+ *                 try: # array.array             # <<<<<<<<<<<<<<
+ *                     bfmt = ob.typecode
+ *                     bitemlen = ob.itemsize
+ */
+          {
+            __Pyx_ExceptionSave(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
+            __Pyx_XGOTREF(__pyx_t_11);
+            __Pyx_XGOTREF(__pyx_t_12);
+            __Pyx_XGOTREF(__pyx_t_13);
+            /*try:*/ {
+
+              /* "buffers.pxd":179
+ *             except AttributeError:
+ *                 try: # array.array
+ *                     bfmt = ob.typecode             # <<<<<<<<<<<<<<
+ *                     bitemlen = ob.itemsize
+ *                 except AttributeError:
+ */
+              __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_v_ob, __pyx_n_s__typecode); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
+              __Pyx_GOTREF(__pyx_t_14);
+              __Pyx_DECREF(__pyx_v_bfmt);
+              __pyx_v_bfmt = __pyx_t_14;
+              __pyx_t_14 = 0;
+
+              /* "buffers.pxd":180
+ *                 try: # array.array
+ *                     bfmt = ob.typecode
+ *                     bitemlen = ob.itemsize             # <<<<<<<<<<<<<<
+ *                 except AttributeError:
+ *                     if isinstance(ob, bytes):
+ */
+              __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_v_ob, __pyx_n_s__itemsize); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
+              __Pyx_GOTREF(__pyx_t_14);
+              __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_t_14); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
+              __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+              __pyx_v_bitemlen = __pyx_t_6;
+            }
+            __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+            __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+            __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
+            goto __pyx_L28_try_end;
+            __pyx_L21_error:;
+            __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
+
+            /* "buffers.pxd":181
+ *                     bfmt = ob.typecode
+ *                     bitemlen = ob.itemsize
+ *                 except AttributeError:             # <<<<<<<<<<<<<<
+ *                     if isinstance(ob, bytes):
+ *                         bfmt = b"B"
+ */
+            __pyx_t_4 = PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
+            if (__pyx_t_4) {
+              __Pyx_AddTraceback("buffers.asbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+              if (__Pyx_GetException(&__pyx_t_14, &__pyx_t_15, &__pyx_t_16) < 0) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L23_except_error;}
+              __Pyx_GOTREF(__pyx_t_14);
+              __Pyx_GOTREF(__pyx_t_15);
+              __Pyx_GOTREF(__pyx_t_16);
+
+              /* "buffers.pxd":182
+ *                     bitemlen = ob.itemsize
+ *                 except AttributeError:
+ *                     if isinstance(ob, bytes):             # <<<<<<<<<<<<<<
+ *                         bfmt = b"B"
+ *                         bitemlen = 1
+ */
+              __pyx_t_1 = PyBytes_Check(__pyx_v_ob); 
+              if (__pyx_t_1) {
+
+                /* "buffers.pxd":183
+ *                 except AttributeError:
+ *                     if isinstance(ob, bytes):
+ *                         bfmt = b"B"             # <<<<<<<<<<<<<<
+ *                         bitemlen = 1
+ *                     else:
+ */
+                __Pyx_INCREF(((PyObject *)__pyx_n_b__B));
+                __Pyx_DECREF(__pyx_v_bfmt);
+                __pyx_v_bfmt = ((PyObject *)__pyx_n_b__B);
+
+                /* "buffers.pxd":184
+ *                     if isinstance(ob, bytes):
+ *                         bfmt = b"B"
+ *                         bitemlen = 1             # <<<<<<<<<<<<<<
+ *                     else:
+ *                         # nothing found
+ */
+                __pyx_v_bitemlen = 1;
+                goto __pyx_L31;
+              }
+              /*else*/ {
+
+                /* "buffers.pxd":187
+ *                     else:
+ *                         # nothing found
+ *                         bfmt = None             # <<<<<<<<<<<<<<
+ *                         bitemlen = 0
+ *     if base: base[0] = <void *>bptr
+ */
+                __Pyx_INCREF(Py_None);
+                __Pyx_DECREF(__pyx_v_bfmt);
+                __pyx_v_bfmt = Py_None;
+
+                /* "buffers.pxd":188
+ *                         # nothing found
+ *                         bfmt = None
+ *                         bitemlen = 0             # <<<<<<<<<<<<<<
+ *     if base: base[0] = <void *>bptr
+ *     if size: size[0] = <Py_ssize_t>blen
+ */
+                __pyx_v_bitemlen = 0;
+              }
+              __pyx_L31:;
+              __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+              __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+              __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+              goto __pyx_L22_exception_handled;
+            }
+            __pyx_L23_except_error:;
+            __Pyx_XGIVEREF(__pyx_t_11);
+            __Pyx_XGIVEREF(__pyx_t_12);
+            __Pyx_XGIVEREF(__pyx_t_13);
+            __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);
+            goto __pyx_L13_except_error;
+            __pyx_L22_exception_handled:;
+            __Pyx_XGIVEREF(__pyx_t_11);
+            __Pyx_XGIVEREF(__pyx_t_12);
+            __Pyx_XGIVEREF(__pyx_t_13);
+            __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);
+            __pyx_L28_try_end:;
+          }
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+          goto __pyx_L12_exception_handled;
+        }
+        __pyx_L13_except_error:;
+        __Pyx_XGIVEREF(__pyx_t_7);
+        __Pyx_XGIVEREF(__pyx_t_8);
+        __Pyx_XGIVEREF(__pyx_t_9);
+        __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+        goto __pyx_L1_error;
+        __pyx_L12_exception_handled:;
+        __Pyx_XGIVEREF(__pyx_t_7);
+        __Pyx_XGIVEREF(__pyx_t_8);
+        __Pyx_XGIVEREF(__pyx_t_9);
+        __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+        __pyx_L18_try_end:;
+      }
+      goto __pyx_L10;
+    }
+    __pyx_L10:;
+  }
+  __pyx_L4:;
+
+  /* "buffers.pxd":189
+ *                         bfmt = None
+ *                         bitemlen = 0
+ *     if base: base[0] = <void *>bptr             # <<<<<<<<<<<<<<
+ *     if size: size[0] = <Py_ssize_t>blen
+ *     if itemsize: itemsize[0] = <Py_ssize_t>bitemlen
+ */
+  __pyx_t_1 = (__pyx_v_base != 0);
+  if (__pyx_t_1) {
+    (__pyx_v_base[0]) = ((void *)__pyx_v_bptr);
+    goto __pyx_L32;
+  }
+  __pyx_L32:;
+
+  /* "buffers.pxd":190
+ *                         bitemlen = 0
+ *     if base: base[0] = <void *>bptr
+ *     if size: size[0] = <Py_ssize_t>blen             # <<<<<<<<<<<<<<
+ *     if itemsize: itemsize[0] = <Py_ssize_t>bitemlen
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_size != 0);
+  if (__pyx_t_1) {
+    (__pyx_v_size[0]) = ((Py_ssize_t)__pyx_v_blen);
+    goto __pyx_L33;
+  }
+  __pyx_L33:;
+
+  /* "buffers.pxd":191
+ *     if base: base[0] = <void *>bptr
+ *     if size: size[0] = <Py_ssize_t>blen
+ *     if itemsize: itemsize[0] = <Py_ssize_t>bitemlen             # <<<<<<<<<<<<<<
+ * 
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:
+ */
+  __pyx_t_1 = (__pyx_v_itemsize != 0);
+  if (__pyx_t_1) {
+    (__pyx_v_itemsize[0]) = ((Py_ssize_t)__pyx_v_bitemlen);
+    goto __pyx_L34;
+  }
+  __pyx_L34:;
+
+  /* "buffers.pxd":193
+ *     if itemsize: itemsize[0] = <Py_ssize_t>bitemlen
+ * 
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:             # <<<<<<<<<<<<<<
+ *         return bfmt.decode('ascii')
+ *     return bfmt
+ */
+  __pyx_t_1 = (PY_MAJOR_VERSION >= 3);
+  if (__pyx_t_1) {
+    __pyx_t_17 = (__pyx_v_bfmt != Py_None);
+    __pyx_t_18 = __pyx_t_17;
+  } else {
+    __pyx_t_18 = __pyx_t_1;
+  }
+  if (__pyx_t_18) {
+
+    /* "buffers.pxd":194
+ * 
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:
+ *         return bfmt.decode('ascii')             # <<<<<<<<<<<<<<
+ *     return bfmt
+ * 
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_v_bfmt, __pyx_n_s__decode); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_10);
+    __pyx_t_3 = PyObject_Call(__pyx_t_10, ((PyObject *)__pyx_k_tuple_9), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L0;
+    goto __pyx_L35;
+  }
+  __pyx_L35:;
+
+  /* "buffers.pxd":195
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:
+ *         return bfmt.decode('ascii')
+ *     return bfmt             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_bfmt);
+  __pyx_r = __pyx_v_bfmt;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_XDECREF(__pyx_t_14);
+  __Pyx_XDECREF(__pyx_t_15);
+  __Pyx_XDECREF(__pyx_t_16);
+  __Pyx_AddTraceback("buffers.asbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_bfmt);
+  __Pyx_XDECREF(__pyx_v_dtype);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":198
+ * 
+ * 
+ * cdef inline object asbuffer_r(object ob, void **base, Py_ssize_t *size):             # <<<<<<<<<<<<<<
+ *     """Wrapper for standard calls to asbuffer with a readonly buffer."""
+ *     asbuffer(ob, 0, 0, base, size, NULL)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer_r(PyObject *__pyx_v_ob, void **__pyx_v_base, Py_ssize_t *__pyx_v_size) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("asbuffer_r", 0);
+
+  /* "buffers.pxd":200
+ * cdef inline object asbuffer_r(object ob, void **base, Py_ssize_t *size):
+ *     """Wrapper for standard calls to asbuffer with a readonly buffer."""
+ *     asbuffer(ob, 0, 0, base, size, NULL)             # <<<<<<<<<<<<<<
+ *     return ob
+ * 
+ */
+  __pyx_t_1 = __pyx_f_7buffers_asbuffer(__pyx_v_ob, 0, 0, __pyx_v_base, __pyx_v_size, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "buffers.pxd":201
+ *     """Wrapper for standard calls to asbuffer with a readonly buffer."""
+ *     asbuffer(ob, 0, 0, base, size, NULL)
+ *     return ob             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_ob);
+  __pyx_r = __pyx_v_ob;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.asbuffer_r", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":204
+ * 
+ * 
+ * cdef inline object asbuffer_w(object ob, void **base, Py_ssize_t *size):             # <<<<<<<<<<<<<<
+ *     """Wrapper for standard calls to asbuffer with a writable buffer."""
+ *     asbuffer(ob, 1, 0, base, size, NULL)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_asbuffer_w(PyObject *__pyx_v_ob, void **__pyx_v_base, Py_ssize_t *__pyx_v_size) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("asbuffer_w", 0);
+
+  /* "buffers.pxd":206
+ * cdef inline object asbuffer_w(object ob, void **base, Py_ssize_t *size):
+ *     """Wrapper for standard calls to asbuffer with a writable buffer."""
+ *     asbuffer(ob, 1, 0, base, size, NULL)             # <<<<<<<<<<<<<<
+ *     return ob
+ * 
+ */
+  __pyx_t_1 = __pyx_f_7buffers_asbuffer(__pyx_v_ob, 1, 0, __pyx_v_base, __pyx_v_size, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "buffers.pxd":207
+ *     """Wrapper for standard calls to asbuffer with a writable buffer."""
+ *     asbuffer(ob, 1, 0, base, size, NULL)
+ *     return ob             # <<<<<<<<<<<<<<
+ * 
+ * #------------------------------------------------------------------------------
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_ob);
+  __pyx_r = __pyx_v_ob;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.asbuffer_w", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":214
+ * 
+ * 
+ * cdef inline object frombuffer_3(void *ptr, Py_ssize_t s, int readonly):             # <<<<<<<<<<<<<<
+ *     """Python 3 version of frombuffer.
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_3(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s, int __pyx_v_readonly) {
+  Py_buffer __pyx_v_pybuf;
+  Py_ssize_t *__pyx_v_shape;
+  PyObject *__pyx_v_astr = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  Py_ssize_t __pyx_t_1[1];
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer_3", 0);
+
+  /* "buffers.pxd":221
+ *     """
+ *     cdef Py_buffer pybuf
+ *     cdef Py_ssize_t *shape = [s]             # <<<<<<<<<<<<<<
+ *     cdef str astr=""
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)
+ */
+  __pyx_t_1[0] = __pyx_v_s;
+  __pyx_v_shape = __pyx_t_1;
+
+  /* "buffers.pxd":222
+ *     cdef Py_buffer pybuf
+ *     cdef Py_ssize_t *shape = [s]
+ *     cdef str astr=""             # <<<<<<<<<<<<<<
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)
+ *     pybuf.format = "B"
+ */
+  __Pyx_INCREF(((PyObject *)__pyx_kp_s_10));
+  __pyx_v_astr = __pyx_kp_s_10;
+
+  /* "buffers.pxd":223
+ *     cdef Py_ssize_t *shape = [s]
+ *     cdef str astr=""
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)             # <<<<<<<<<<<<<<
+ *     pybuf.format = "B"
+ *     pybuf.shape = shape
+ */
+  __pyx_t_2 = PyBuffer_FillInfo((&__pyx_v_pybuf), ((PyObject *)__pyx_v_astr), __pyx_v_ptr, __pyx_v_s, __pyx_v_readonly, PyBUF_SIMPLE); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "buffers.pxd":224
+ *     cdef str astr=""
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)
+ *     pybuf.format = "B"             # <<<<<<<<<<<<<<
+ *     pybuf.shape = shape
+ *     return PyMemoryView_FromBuffer(&pybuf)
+ */
+  __pyx_v_pybuf.format = __pyx_k__B;
+
+  /* "buffers.pxd":225
+ *     PyBuffer_FillInfo(&pybuf, astr, ptr, s, readonly, PyBUF_SIMPLE)
+ *     pybuf.format = "B"
+ *     pybuf.shape = shape             # <<<<<<<<<<<<<<
+ *     return PyMemoryView_FromBuffer(&pybuf)
+ * 
+ */
+  __pyx_v_pybuf.shape = __pyx_v_shape;
+
+  /* "buffers.pxd":226
+ *     pybuf.format = "B"
+ *     pybuf.shape = shape
+ *     return PyMemoryView_FromBuffer(&pybuf)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_3 = PyMemoryView_FromBuffer((&__pyx_v_pybuf)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("buffers.frombuffer_3", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_astr);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":229
+ * 
+ * 
+ * cdef inline object frombuffer_2(void *ptr, Py_ssize_t s, int readonly):             # <<<<<<<<<<<<<<
+ *     """Python 2 version of frombuffer.
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_2(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s, int __pyx_v_readonly) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer_2", 0);
+
+  /* "buffers.pxd":235
+ *     """
+ * 
+ *     if oldstyle_available():             # <<<<<<<<<<<<<<
+ *         if readonly:
+ *             return PyBuffer_FromMemory(ptr, s)
+ */
+  __pyx_t_1 = __pyx_f_7buffers_oldstyle_available();
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":236
+ * 
+ *     if oldstyle_available():
+ *         if readonly:             # <<<<<<<<<<<<<<
+ *             return PyBuffer_FromMemory(ptr, s)
+ *         else:
+ */
+    if (__pyx_v_readonly) {
+
+      /* "buffers.pxd":237
+ *     if oldstyle_available():
+ *         if readonly:
+ *             return PyBuffer_FromMemory(ptr, s)             # <<<<<<<<<<<<<<
+ *         else:
+ *             return PyBuffer_FromReadWriteMemory(ptr, s)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyBuffer_FromMemory(__pyx_v_ptr, __pyx_v_s); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+      goto __pyx_L4;
+    }
+    /*else*/ {
+
+      /* "buffers.pxd":239
+ *             return PyBuffer_FromMemory(ptr, s)
+ *         else:
+ *             return PyBuffer_FromReadWriteMemory(ptr, s)             # <<<<<<<<<<<<<<
+ *     else:
+ *         raise NotImplementedError("Old style buffers not available.")
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyBuffer_FromReadWriteMemory(__pyx_v_ptr, __pyx_v_s); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+    }
+    __pyx_L4:;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "buffers.pxd":241
+ *             return PyBuffer_FromReadWriteMemory(ptr, s)
+ *     else:
+ *         raise NotImplementedError("Old style buffers not available.")             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_NotImplementedError, ((PyObject *)__pyx_k_tuple_12), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[3]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("buffers.frombuffer_2", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":244
+ * 
+ * 
+ * cdef inline object frombuffer(void *ptr, Py_ssize_t s, int readonly):             # <<<<<<<<<<<<<<
+ *     """Create a Python Buffer/View of a C array.
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s, int __pyx_v_readonly) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer", 0);
+
+  /* "buffers.pxd":261
+ *     """
+ *     # oldstyle first priority for now
+ *     if oldstyle_available():             # <<<<<<<<<<<<<<
+ *         return frombuffer_2(ptr, s, readonly)
+ *     else:
+ */
+  __pyx_t_1 = __pyx_f_7buffers_oldstyle_available();
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":262
+ *     # oldstyle first priority for now
+ *     if oldstyle_available():
+ *         return frombuffer_2(ptr, s, readonly)             # <<<<<<<<<<<<<<
+ *     else:
+ *         return frombuffer_3(ptr, s, readonly)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = __pyx_f_7buffers_frombuffer_2(__pyx_v_ptr, __pyx_v_s, __pyx_v_readonly); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "buffers.pxd":264
+ *         return frombuffer_2(ptr, s, readonly)
+ *     else:
+ *         return frombuffer_3(ptr, s, readonly)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = __pyx_f_7buffers_frombuffer_3(__pyx_v_ptr, __pyx_v_s, __pyx_v_readonly); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("buffers.frombuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":267
+ * 
+ * 
+ * cdef inline object frombuffer_r(void *ptr, Py_ssize_t s):             # <<<<<<<<<<<<<<
+ *     """Wrapper for readonly view frombuffer."""
+ *     return frombuffer(ptr, s, 1)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_r(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer_r", 0);
+
+  /* "buffers.pxd":269
+ * cdef inline object frombuffer_r(void *ptr, Py_ssize_t s):
+ *     """Wrapper for readonly view frombuffer."""
+ *     return frombuffer(ptr, s, 1)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_7buffers_frombuffer(__pyx_v_ptr, __pyx_v_s, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.frombuffer_r", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":272
+ * 
+ * 
+ * cdef inline object frombuffer_w(void *ptr, Py_ssize_t s):             # <<<<<<<<<<<<<<
+ *     """Wrapper for writable view frombuffer."""
+ *     return frombuffer(ptr, s, 0)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_frombuffer_w(void *__pyx_v_ptr, Py_ssize_t __pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("frombuffer_w", 0);
+
+  /* "buffers.pxd":274
+ * cdef inline object frombuffer_w(void *ptr, Py_ssize_t s):
+ *     """Wrapper for writable view frombuffer."""
+ *     return frombuffer(ptr, s, 0)             # <<<<<<<<<<<<<<
+ * 
+ * #------------------------------------------------------------------------------
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_7buffers_frombuffer(__pyx_v_ptr, __pyx_v_s, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.frombuffer_w", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":281
+ * #------------------------------------------------------------------------------
+ * 
+ * cdef inline object viewfromobject(object obj, int readonly):             # <<<<<<<<<<<<<<
+ *     """Construct a Python Buffer/View object from another Python object.
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject(PyObject *__pyx_v_obj, int __pyx_v_readonly) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("viewfromobject", 0);
+
+  /* "buffers.pxd":297
+ *     Buffer/View of the original object.
+ *     """
+ *     if not memoryview_available():             # <<<<<<<<<<<<<<
+ *         if readonly:
+ *             return PyBuffer_FromObject(obj, 0, Py_END_OF_BUFFER)
+ */
+  __pyx_t_1 = (!__pyx_f_7buffers_memoryview_available());
+  if (__pyx_t_1) {
+
+    /* "buffers.pxd":298
+ *     """
+ *     if not memoryview_available():
+ *         if readonly:             # <<<<<<<<<<<<<<
+ *             return PyBuffer_FromObject(obj, 0, Py_END_OF_BUFFER)
+ *         else:
+ */
+    if (__pyx_v_readonly) {
+
+      /* "buffers.pxd":299
+ *     if not memoryview_available():
+ *         if readonly:
+ *             return PyBuffer_FromObject(obj, 0, Py_END_OF_BUFFER)             # <<<<<<<<<<<<<<
+ *         else:
+ *             return PyBuffer_FromReadWriteObject(obj, 0, Py_END_OF_BUFFER)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyBuffer_FromObject(__pyx_v_obj, 0, Py_END_OF_BUFFER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+      goto __pyx_L4;
+    }
+    /*else*/ {
+
+      /* "buffers.pxd":301
+ *             return PyBuffer_FromObject(obj, 0, Py_END_OF_BUFFER)
+ *         else:
+ *             return PyBuffer_FromReadWriteObject(obj, 0, Py_END_OF_BUFFER)             # <<<<<<<<<<<<<<
+ *     else:
+ *         return PyMemoryView_FromObject(obj)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_2 = PyBuffer_FromReadWriteObject(__pyx_v_obj, 0, Py_END_OF_BUFFER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+    }
+    __pyx_L4:;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "buffers.pxd":303
+ *             return PyBuffer_FromReadWriteObject(obj, 0, Py_END_OF_BUFFER)
+ *     else:
+ *         return PyMemoryView_FromObject(obj)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = PyMemoryView_FromObject(__pyx_v_obj); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("buffers.viewfromobject", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":306
+ * 
+ * 
+ * cdef inline object viewfromobject_r(object obj):             # <<<<<<<<<<<<<<
+ *     """Wrapper for readonly viewfromobject."""
+ *     return viewfromobject(obj, 1)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject_r(PyObject *__pyx_v_obj) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("viewfromobject_r", 0);
+
+  /* "buffers.pxd":308
+ * cdef inline object viewfromobject_r(object obj):
+ *     """Wrapper for readonly viewfromobject."""
+ *     return viewfromobject(obj, 1)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_7buffers_viewfromobject(__pyx_v_obj, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.viewfromobject_r", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "buffers.pxd":311
+ * 
+ * 
+ * cdef inline object viewfromobject_w(object obj):             # <<<<<<<<<<<<<<
+ *     """Wrapper for writable viewfromobject."""
+ *     return viewfromobject(obj, 0)
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7buffers_viewfromobject_w(PyObject *__pyx_v_obj) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("viewfromobject_w", 0);
+
+  /* "buffers.pxd":313
+ * cdef inline object viewfromobject_w(object obj):
+ *     """Wrapper for writable viewfromobject."""
+ *     return viewfromobject(obj, 0)             # <<<<<<<<<<<<<<
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_7buffers_viewfromobject(__pyx_v_obj, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("buffers.viewfromobject_w", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":104
+ * # Datetime C API initialization function.
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():             # <<<<<<<<<<<<<<
+ *     PyDateTime_IMPORT
+ * 
+ */
+
+static CYTHON_INLINE void __pyx_f_7cpython_8datetime_import_datetime(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("import_datetime", 0);
+
+  /* "cpython/datetime.pxd":105
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():
+ *     PyDateTime_IMPORT             # <<<<<<<<<<<<<<
+ * 
+ * # Create date object using DateTime CAPI factory function.
+ */
+  PyDateTime_IMPORT;
+
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "cpython/datetime.pxd":109
+ * # Create date object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_date_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("date_new", 0);
+
+  /* "cpython/datetime.pxd":110
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create time object using DateTime CAPI factory function
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Date_FromDate(__pyx_v_year, __pyx_v_month, __pyx_v_day, PyDateTimeAPI->DateType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.date_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":114
+ * # Create time object using DateTime CAPI factory function
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_new(int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("time_new", 0);
+
+  /* "cpython/datetime.pxd":115
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create datetime object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Time_FromTime(__pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->TimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.time_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":119
+ * # Create datetime object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day, int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("datetime_new", 0);
+
+  /* "cpython/datetime.pxd":120
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create timedelta object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->DateTime_FromDateAndTime(__pyx_v_year, __pyx_v_month, __pyx_v_day, __pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->DateTimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.datetime_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":124
+ * # Create timedelta object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_timedelta_new(int __pyx_v_days, int __pyx_v_seconds, int __pyx_v_useconds) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("timedelta_new", 0);
+
+  /* "cpython/datetime.pxd":125
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)             # <<<<<<<<<<<<<<
+ * 
+ * # More recognizable getters for date/time/datetime/timedelta.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Delta_FromDelta(__pyx_v_days, __pyx_v_seconds, __pyx_v_useconds, 1, PyDateTimeAPI->DeltaType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.timedelta_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":133
+ * 
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":134
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_Time *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":135
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":137
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get tzinfo of datetime
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":140
+ * 
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":141
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_DateTime *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":142
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":144
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of date
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":147
+ * 
+ * # Get year of date
+ * cdef inline int date_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_year", 0);
+
+  /* "cpython/datetime.pxd":148
+ * # Get year of date
+ * cdef inline int date_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of date
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":151
+ * 
+ * # Get month of date
+ * cdef inline int date_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_month", 0);
+
+  /* "cpython/datetime.pxd":152
+ * # Get month of date
+ * cdef inline int date_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of date
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":155
+ * 
+ * # Get day of date
+ * cdef inline int date_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_day", 0);
+
+  /* "cpython/datetime.pxd":156
+ * # Get day of date
+ * cdef inline int date_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of datetime
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":159
+ * 
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_year", 0);
+
+  /* "cpython/datetime.pxd":160
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of datetime
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":163
+ * 
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_month", 0);
+
+  /* "cpython/datetime.pxd":164
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of datetime
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":167
+ * 
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_day", 0);
+
+  /* "cpython/datetime.pxd":168
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of time
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":171
+ * 
+ * # Get hour of time
+ * cdef inline int time_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_hour", 0);
+
+  /* "cpython/datetime.pxd":172
+ * # Get hour of time
+ * cdef inline int time_hour(object o):
+ *     return PyDateTime_TIME_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":175
+ * 
+ * # Get minute of time
+ * cdef inline int time_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_minute", 0);
+
+  /* "cpython/datetime.pxd":176
+ * # Get minute of time
+ * cdef inline int time_minute(object o):
+ *     return PyDateTime_TIME_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":179
+ * 
+ * # Get second of time
+ * cdef inline int time_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_second", 0);
+
+  /* "cpython/datetime.pxd":180
+ * # Get second of time
+ * cdef inline int time_second(object o):
+ *     return PyDateTime_TIME_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":183
+ * 
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_microsecond", 0);
+
+  /* "cpython/datetime.pxd":184
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of datetime
+ */
+  __pyx_r = PyDateTime_TIME_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":187
+ * 
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_hour", 0);
+
+  /* "cpython/datetime.pxd":188
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):
+ *     return PyDateTime_DATE_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":191
+ * 
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_minute", 0);
+
+  /* "cpython/datetime.pxd":192
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):
+ *     return PyDateTime_DATE_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":195
+ * 
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_second", 0);
+
+  /* "cpython/datetime.pxd":196
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):
+ *     return PyDateTime_DATE_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":199
+ * 
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_microsecond", 0);
+
+  /* "cpython/datetime.pxd":200
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get days of timedelta
+ */
+  __pyx_r = PyDateTime_DATE_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":203
+ * 
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).days
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_days(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_days", 0);
+
+  /* "cpython/datetime.pxd":204
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):
+ *     return (<PyDateTime_Delta*>o).days             # <<<<<<<<<<<<<<
+ * 
+ * # Get seconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->days;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":207
+ * 
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).seconds
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_seconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_seconds", 0);
+
+  /* "cpython/datetime.pxd":208
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):
+ *     return (<PyDateTime_Delta*>o).seconds             # <<<<<<<<<<<<<<
+ * 
+ * # Get microseconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->seconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_microseconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_microseconds", 0);
+
+  /* "cpython/datetime.pxd":212
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):
+ *     return (<PyDateTime_Delta*>o).microseconds             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->microseconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_tp_new_3zmq_4core_7message_MessageTracker(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
+  struct __pyx_obj_3zmq_4core_7message_MessageTracker *p;
+  PyObject *o;
+  o = (*t->tp_alloc)(t, 0);
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_3zmq_4core_7message_MessageTracker *)o);
+  p->events = ((PyObject*)Py_None); Py_INCREF(Py_None);
+  p->peers = ((PyObject*)Py_None); Py_INCREF(Py_None);
+  return o;
+}
+
+static void __pyx_tp_dealloc_3zmq_4core_7message_MessageTracker(PyObject *o) {
+  struct __pyx_obj_3zmq_4core_7message_MessageTracker *p = (struct __pyx_obj_3zmq_4core_7message_MessageTracker *)o;
+  PyObject_GC_UnTrack(o);
+  Py_CLEAR(p->events);
+  Py_CLEAR(p->peers);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static int __pyx_tp_traverse_3zmq_4core_7message_MessageTracker(PyObject *o, visitproc v, void *a) {
+  int e;
+  struct __pyx_obj_3zmq_4core_7message_MessageTracker *p = (struct __pyx_obj_3zmq_4core_7message_MessageTracker *)o;
+  if (p->events) {
+    e = (*v)(p->events, a); if (e) return e;
+  }
+  if (p->peers) {
+    e = (*v)(p->peers, a); if (e) return e;
+  }
+  return 0;
+}
+
+static int __pyx_tp_clear_3zmq_4core_7message_MessageTracker(PyObject *o) {
+  struct __pyx_obj_3zmq_4core_7message_MessageTracker *p = (struct __pyx_obj_3zmq_4core_7message_MessageTracker *)o;
+  PyObject* tmp;
+  tmp = ((PyObject*)p->events);
+  p->events = ((PyObject*)Py_None); Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->peers);
+  p->peers = ((PyObject*)Py_None); Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  return 0;
+}
+
+static PyMethodDef __pyx_methods_3zmq_4core_7message_MessageTracker[] = {
+  {0, 0, 0, 0}
+};
+
+static PyNumberMethods __pyx_tp_as_number_MessageTracker = {
+  0, /*nb_add*/
+  0, /*nb_subtract*/
+  0, /*nb_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_divide*/
+  #endif
+  0, /*nb_remainder*/
+  0, /*nb_divmod*/
+  0, /*nb_power*/
+  0, /*nb_negative*/
+  0, /*nb_positive*/
+  0, /*nb_absolute*/
+  0, /*nb_nonzero*/
+  0, /*nb_invert*/
+  0, /*nb_lshift*/
+  0, /*nb_rshift*/
+  0, /*nb_and*/
+  0, /*nb_xor*/
+  0, /*nb_or*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_coerce*/
+  #endif
+  0, /*nb_int*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_long*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*nb_float*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_oct*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_hex*/
+  #endif
+  0, /*nb_inplace_add*/
+  0, /*nb_inplace_subtract*/
+  0, /*nb_inplace_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_inplace_divide*/
+  #endif
+  0, /*nb_inplace_remainder*/
+  0, /*nb_inplace_power*/
+  0, /*nb_inplace_lshift*/
+  0, /*nb_inplace_rshift*/
+  0, /*nb_inplace_and*/
+  0, /*nb_inplace_xor*/
+  0, /*nb_inplace_or*/
+  0, /*nb_floor_divide*/
+  0, /*nb_true_divide*/
+  0, /*nb_inplace_floor_divide*/
+  0, /*nb_inplace_true_divide*/
+  #if PY_VERSION_HEX >= 0x02050000
+  0, /*nb_index*/
+  #endif
+};
+
+static PySequenceMethods __pyx_tp_as_sequence_MessageTracker = {
+  0, /*sq_length*/
+  0, /*sq_concat*/
+  0, /*sq_repeat*/
+  0, /*sq_item*/
+  0, /*sq_slice*/
+  0, /*sq_ass_item*/
+  0, /*sq_ass_slice*/
+  0, /*sq_contains*/
+  0, /*sq_inplace_concat*/
+  0, /*sq_inplace_repeat*/
+};
+
+static PyMappingMethods __pyx_tp_as_mapping_MessageTracker = {
+  0, /*mp_length*/
+  0, /*mp_subscript*/
+  0, /*mp_ass_subscript*/
+};
+
+static PyBufferProcs __pyx_tp_as_buffer_MessageTracker = {
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getreadbuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getwritebuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getsegcount*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getcharbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_getbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_releasebuffer*/
+  #endif
+};
+
+static PyTypeObject __pyx_type_3zmq_4core_7message_MessageTracker = {
+  PyVarObject_HEAD_INIT(0, 0)
+  __Pyx_NAMESTR("zmq.core.message.MessageTracker"), /*tp_name*/
+  sizeof(struct __pyx_obj_3zmq_4core_7message_MessageTracker), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_3zmq_4core_7message_MessageTracker, /*tp_dealloc*/
+  0, /*tp_print*/
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*tp_repr*/
+  &__pyx_tp_as_number_MessageTracker, /*tp_as_number*/
+  &__pyx_tp_as_sequence_MessageTracker, /*tp_as_sequence*/
+  &__pyx_tp_as_mapping_MessageTracker, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  &__pyx_tp_as_buffer_MessageTracker, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  __Pyx_DOCSTR("A class for tracking if 0MQ is done using one or more messages."), /*tp_doc*/
+  __pyx_tp_traverse_3zmq_4core_7message_MessageTracker, /*tp_traverse*/
+  __pyx_tp_clear_3zmq_4core_7message_MessageTracker, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_3zmq_4core_7message_MessageTracker, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  0, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_3zmq_4core_7message_MessageTracker, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*tp_version_tag*/
+  #endif
+};
+static struct __pyx_vtabstruct_3zmq_4core_7message_Frame __pyx_vtable_3zmq_4core_7message_Frame;
+
+static PyObject *__pyx_tp_new_3zmq_4core_7message_Frame(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_3zmq_4core_7message_Frame *p;
+  PyObject *o;
+  o = (*t->tp_alloc)(t, 0);
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_3zmq_4core_7message_Frame *)o);
+  p->__pyx_vtab = __pyx_vtabptr_3zmq_4core_7message_Frame;
+  p->_data = Py_None; Py_INCREF(Py_None);
+  p->_buffer = Py_None; Py_INCREF(Py_None);
+  p->_bytes = Py_None; Py_INCREF(Py_None);
+  p->tracker_event = Py_None; Py_INCREF(Py_None);
+  p->tracker = Py_None; Py_INCREF(Py_None);
+  if (unlikely(__pyx_pw_3zmq_4core_7message_5Frame_1__cinit__(o, a, k) < 0)) {
+    Py_DECREF(o); o = 0;
+  }
+  return o;
+}
+
+static void __pyx_tp_dealloc_3zmq_4core_7message_Frame(PyObject *o) {
+  struct __pyx_obj_3zmq_4core_7message_Frame *p = (struct __pyx_obj_3zmq_4core_7message_Frame *)o;
+  PyObject_GC_UnTrack(o);
+  {
+    PyObject *etype, *eval, *etb;
+    PyErr_Fetch(&etype, &eval, &etb);
+    ++Py_REFCNT(o);
+    __pyx_pw_3zmq_4core_7message_5Frame_5__dealloc__(o);
+    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
+    --Py_REFCNT(o);
+    PyErr_Restore(etype, eval, etb);
+  }
+  Py_CLEAR(p->_data);
+  Py_CLEAR(p->_buffer);
+  Py_CLEAR(p->_bytes);
+  Py_CLEAR(p->tracker_event);
+  Py_CLEAR(p->tracker);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static int __pyx_tp_traverse_3zmq_4core_7message_Frame(PyObject *o, visitproc v, void *a) {
+  int e;
+  struct __pyx_obj_3zmq_4core_7message_Frame *p = (struct __pyx_obj_3zmq_4core_7message_Frame *)o;
+  if (p->_data) {
+    e = (*v)(p->_data, a); if (e) return e;
+  }
+  if (p->_buffer) {
+    e = (*v)(p->_buffer, a); if (e) return e;
+  }
+  if (p->_bytes) {
+    e = (*v)(p->_bytes, a); if (e) return e;
+  }
+  if (p->tracker_event) {
+    e = (*v)(p->tracker_event, a); if (e) return e;
+  }
+  if (p->tracker) {
+    e = (*v)(p->tracker, a); if (e) return e;
+  }
+  return 0;
+}
+
+static int __pyx_tp_clear_3zmq_4core_7message_Frame(PyObject *o) {
+  struct __pyx_obj_3zmq_4core_7message_Frame *p = (struct __pyx_obj_3zmq_4core_7message_Frame *)o;
+  PyObject* tmp;
+  tmp = ((PyObject*)p->_data);
+  p->_data = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->_buffer);
+  p->_buffer = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->_bytes);
+  p->_bytes = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->tracker_event);
+  p->tracker_event = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->tracker);
+  p->tracker = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  return 0;
+}
+
+static PyObject *__pyx_getprop_3zmq_4core_7message_5Frame_tracker_event(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_1__get__(o);
+}
+
+static int __pyx_setprop_3zmq_4core_7message_5Frame_tracker_event(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
+  if (v) {
+    return __pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_3__set__(o, v);
+  }
+  else {
+    return __pyx_pw_3zmq_4core_7message_5Frame_13tracker_event_5__del__(o);
+  }
+}
+
+static PyObject *__pyx_getprop_3zmq_4core_7message_5Frame_tracker(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3zmq_4core_7message_5Frame_7tracker_1__get__(o);
+}
+
+static int __pyx_setprop_3zmq_4core_7message_5Frame_tracker(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
+  if (v) {
+    return __pyx_pw_3zmq_4core_7message_5Frame_7tracker_3__set__(o, v);
+  }
+  else {
+    return __pyx_pw_3zmq_4core_7message_5Frame_7tracker_5__del__(o);
+  }
+}
+
+static PyObject *__pyx_getprop_3zmq_4core_7message_5Frame_more(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3zmq_4core_7message_5Frame_4more_1__get__(o);
+}
+
+static int __pyx_setprop_3zmq_4core_7message_5Frame_more(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
+  if (v) {
+    return __pyx_pw_3zmq_4core_7message_5Frame_4more_3__set__(o, v);
+  }
+  else {
+    PyErr_SetString(PyExc_NotImplementedError, "__del__");
+    return -1;
+  }
+}
+
+static PyMethodDef __pyx_methods_3zmq_4core_7message_Frame[] = {
+  {__Pyx_NAMESTR("__copy__"), (PyCFunction)__pyx_pw_3zmq_4core_7message_5Frame_13__copy__, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7message_5Frame_12__copy__)},
+  {__Pyx_NAMESTR("buffer"), (PyCFunction)__pyx_pw_3zmq_4core_7message_5Frame_19buffer, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7message_5Frame_18buffer)},
+  {__Pyx_NAMESTR("bytes"), (PyCFunction)__pyx_pw_3zmq_4core_7message_5Frame_21bytes, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7message_5Frame_20bytes)},
+  {__Pyx_NAMESTR("set"), (PyCFunction)__pyx_pw_3zmq_4core_7message_5Frame_23set, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7message_5Frame_22set)},
+  {__Pyx_NAMESTR("get"), (PyCFunction)__pyx_pw_3zmq_4core_7message_5Frame_25get, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7message_5Frame_24get)},
+  {0, 0, 0, 0}
+};
+
+static struct PyGetSetDef __pyx_getsets_3zmq_4core_7message_Frame[] = {
+  {(char *)"tracker_event", __pyx_getprop_3zmq_4core_7message_5Frame_tracker_event, __pyx_setprop_3zmq_4core_7message_5Frame_tracker_event, 0, 0},
+  {(char *)"tracker", __pyx_getprop_3zmq_4core_7message_5Frame_tracker, __pyx_setprop_3zmq_4core_7message_5Frame_tracker, 0, 0},
+  {(char *)"more", __pyx_getprop_3zmq_4core_7message_5Frame_more, __pyx_setprop_3zmq_4core_7message_5Frame_more, 0, 0},
+  {0, 0, 0, 0, 0}
+};
+
+static PyNumberMethods __pyx_tp_as_number_Frame = {
+  0, /*nb_add*/
+  0, /*nb_subtract*/
+  0, /*nb_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_divide*/
+  #endif
+  0, /*nb_remainder*/
+  0, /*nb_divmod*/
+  0, /*nb_power*/
+  0, /*nb_negative*/
+  0, /*nb_positive*/
+  0, /*nb_absolute*/
+  0, /*nb_nonzero*/
+  0, /*nb_invert*/
+  0, /*nb_lshift*/
+  0, /*nb_rshift*/
+  0, /*nb_and*/
+  0, /*nb_xor*/
+  0, /*nb_or*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_coerce*/
+  #endif
+  0, /*nb_int*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_long*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*nb_float*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_oct*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_hex*/
+  #endif
+  0, /*nb_inplace_add*/
+  0, /*nb_inplace_subtract*/
+  0, /*nb_inplace_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_inplace_divide*/
+  #endif
+  0, /*nb_inplace_remainder*/
+  0, /*nb_inplace_power*/
+  0, /*nb_inplace_lshift*/
+  0, /*nb_inplace_rshift*/
+  0, /*nb_inplace_and*/
+  0, /*nb_inplace_xor*/
+  0, /*nb_inplace_or*/
+  0, /*nb_floor_divide*/
+  0, /*nb_true_divide*/
+  0, /*nb_inplace_floor_divide*/
+  0, /*nb_inplace_true_divide*/
+  #if PY_VERSION_HEX >= 0x02050000
+  0, /*nb_index*/
+  #endif
+};
+
+static PySequenceMethods __pyx_tp_as_sequence_Frame = {
+  __pyx_pw_3zmq_4core_7message_5Frame_15__len__, /*sq_length*/
+  0, /*sq_concat*/
+  0, /*sq_repeat*/
+  0, /*sq_item*/
+  0, /*sq_slice*/
+  0, /*sq_ass_item*/
+  0, /*sq_ass_slice*/
+  0, /*sq_contains*/
+  0, /*sq_inplace_concat*/
+  0, /*sq_inplace_repeat*/
+};
+
+static PyMappingMethods __pyx_tp_as_mapping_Frame = {
+  __pyx_pw_3zmq_4core_7message_5Frame_15__len__, /*mp_length*/
+  0, /*mp_subscript*/
+  0, /*mp_ass_subscript*/
+};
+
+static PyBufferProcs __pyx_tp_as_buffer_Frame = {
+  #if PY_MAJOR_VERSION < 3
+  __pyx_pw_3zmq_4core_7message_5Frame_11__getreadbuffer__, /*bf_getreadbuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getwritebuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  __pyx_pw_3zmq_4core_7message_5Frame_9__getsegcount__, /*bf_getsegcount*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getcharbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  __pyx_pw_3zmq_4core_7message_5Frame_7__getbuffer__, /*bf_getbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_releasebuffer*/
+  #endif
+};
+
+static PyTypeObject __pyx_type_3zmq_4core_7message_Frame = {
+  PyVarObject_HEAD_INIT(0, 0)
+  __Pyx_NAMESTR("zmq.core.message.Frame"), /*tp_name*/
+  sizeof(struct __pyx_obj_3zmq_4core_7message_Frame), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_3zmq_4core_7message_Frame, /*tp_dealloc*/
+  0, /*tp_print*/
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*tp_repr*/
+  &__pyx_tp_as_number_Frame, /*tp_as_number*/
+  &__pyx_tp_as_sequence_Frame, /*tp_as_sequence*/
+  &__pyx_tp_as_mapping_Frame, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  __pyx_pw_3zmq_4core_7message_5Frame_17__str__, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  &__pyx_tp_as_buffer_Frame, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  __Pyx_DOCSTR("Frame(data=None, track=False)\n\n    A zmq message Frame class for non-copy send/recvs.\n\n    This class is only needed if you want to do non-copying send and recvs.\n    When you pass a string to this class, like ``Frame(s)``, the \n    ref-count of `s` is increased by two: once because the Frame saves `s` as \n    an instance attribute and another because a ZMQ message is created that\n    points to the buffer of `s`. This second ref-count increase makes sure\n    that `s` lives until all messages that use it have been sent. Once 0MQ\n    sends all the messages and it doesn't need the buffer of s, 0MQ will call\n    ``Py_DECREF(s)``.\n\n    Parameters\n    ----------\n\n    data : object, optional\n        any object that provides the buffer interface will be used to\n        construct the 0MQ message data.\n    track : bool [default: False]\n        whether a MessageTracker_ should be created to track this object.\n        Tracking a message has a cost at creation, because it creates a threadsafe\n        Event object.\n    \n    "), /*tp_doc*/
+  __pyx_tp_traverse_3zmq_4core_7message_Frame, /*tp_traverse*/
+  __pyx_tp_clear_3zmq_4core_7message_Frame, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_3zmq_4core_7message_Frame, /*tp_methods*/
+  0, /*tp_members*/
+  __pyx_getsets_3zmq_4core_7message_Frame, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  __pyx_pw_3zmq_4core_7message_5Frame_3__init__, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_3zmq_4core_7message_Frame, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*tp_version_tag*/
+  #endif
+};
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("message"),
+    __Pyx_DOCSTR(__pyx_k_13), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_s_10, __pyx_k_10, sizeof(__pyx_k_10), 0, 0, 1, 0},
+  {&__pyx_kp_s_11, __pyx_k_11, sizeof(__pyx_k_11), 0, 0, 1, 0},
+  {&__pyx_n_s_14, __pyx_k_14, sizeof(__pyx_k_14), 0, 0, 1, 1},
+  {&__pyx_kp_s_2, __pyx_k_2, sizeof(__pyx_k_2), 0, 0, 1, 0},
+  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
+  {&__pyx_n_s_7, __pyx_k_7, sizeof(__pyx_k_7), 0, 0, 1, 1},
+  {&__pyx_kp_s_8, __pyx_k_8, sizeof(__pyx_k_8), 0, 0, 1, 0},
+  {&__pyx_n_s__Again, __pyx_k__Again, sizeof(__pyx_k__Again), 0, 0, 1, 1},
+  {&__pyx_n_s__AttributeError, __pyx_k__AttributeError, sizeof(__pyx_k__AttributeError), 0, 0, 1, 1},
+  {&__pyx_n_b__B, __pyx_k__B, sizeof(__pyx_k__B), 0, 0, 0, 1},
+  {&__pyx_n_s__ContextTerminated, __pyx_k__ContextTerminated, sizeof(__pyx_k__ContextTerminated), 0, 0, 1, 1},
+  {&__pyx_n_s__Event, __pyx_k__Event, sizeof(__pyx_k__Event), 0, 0, 1, 1},
+  {&__pyx_n_s__Frame, __pyx_k__Frame, sizeof(__pyx_k__Frame), 0, 0, 1, 1},
+  {&__pyx_n_s__ImportError, __pyx_k__ImportError, sizeof(__pyx_k__ImportError), 0, 0, 1, 1},
+  {&__pyx_n_s__Message, __pyx_k__Message, sizeof(__pyx_k__Message), 0, 0, 1, 1},
+  {&__pyx_n_s__MessageTracker, __pyx_k__MessageTracker, sizeof(__pyx_k__MessageTracker), 0, 0, 1, 1},
+  {&__pyx_n_s__NotImplementedError, __pyx_k__NotImplementedError, sizeof(__pyx_k__NotImplementedError), 0, 0, 1, 1},
+  {&__pyx_n_s__SystemError, __pyx_k__SystemError, sizeof(__pyx_k__SystemError), 0, 0, 1, 1},
+  {&__pyx_n_s__TypeError, __pyx_k__TypeError, sizeof(__pyx_k__TypeError), 0, 0, 1, 1},
+  {&__pyx_n_s__ZMQError, __pyx_k__ZMQError, sizeof(__pyx_k__ZMQError), 0, 0, 1, 1},
+  {&__pyx_n_s___Event, __pyx_k___Event, sizeof(__pyx_k___Event), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s__ascii, __pyx_k__ascii, sizeof(__pyx_k__ascii), 0, 0, 1, 1},
+  {&__pyx_n_s__basestring, __pyx_k__basestring, sizeof(__pyx_k__basestring), 0, 0, 1, 1},
+  {&__pyx_n_s__buffer, __pyx_k__buffer, sizeof(__pyx_k__buffer), 0, 0, 1, 1},
+  {&__pyx_n_s__bytes, __pyx_k__bytes, sizeof(__pyx_k__bytes), 0, 0, 1, 1},
+  {&__pyx_n_s__char, __pyx_k__char, sizeof(__pyx_k__char), 0, 0, 1, 1},
+  {&__pyx_n_s__data, __pyx_k__data, sizeof(__pyx_k__data), 0, 0, 1, 1},
+  {&__pyx_n_s__decode, __pyx_k__decode, sizeof(__pyx_k__decode), 0, 0, 1, 1},
+  {&__pyx_n_s__dtype, __pyx_k__dtype, sizeof(__pyx_k__dtype), 0, 0, 1, 1},
+  {&__pyx_n_s__itemsize, __pyx_k__itemsize, sizeof(__pyx_k__itemsize), 0, 0, 1, 1},
+  {&__pyx_n_s__option, __pyx_k__option, sizeof(__pyx_k__option), 0, 0, 1, 1},
+  {&__pyx_n_s__property, __pyx_k__property, sizeof(__pyx_k__property), 0, 0, 1, 1},
+  {&__pyx_n_s__set, __pyx_k__set, sizeof(__pyx_k__set), 0, 0, 1, 1},
+  {&__pyx_n_s__threading, __pyx_k__threading, sizeof(__pyx_k__threading), 0, 0, 1, 1},
+  {&__pyx_n_s__time, __pyx_k__time, sizeof(__pyx_k__time), 0, 0, 1, 1},
+  {&__pyx_n_s__track, __pyx_k__track, sizeof(__pyx_k__track), 0, 0, 1, 1},
+  {&__pyx_n_s__typecode, __pyx_k__typecode, sizeof(__pyx_k__typecode), 0, 0, 1, 1},
+  {&__pyx_n_s__unicode, __pyx_k__unicode, sizeof(__pyx_k__unicode), 0, 0, 1, 1},
+  {&__pyx_n_s__value, __pyx_k__value, sizeof(__pyx_k__value), 0, 0, 1, 1},
+  {&__pyx_n_s__zmq, __pyx_k__zmq, sizeof(__pyx_k__zmq), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s__ImportError); if (!__pyx_builtin_ImportError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s__AttributeError); if (!__pyx_builtin_AttributeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s__property); if (!__pyx_builtin_property) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s__TypeError); if (!__pyx_builtin_TypeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_SystemError = __Pyx_GetBuiltinName(__pyx_n_s__SystemError); if (!__pyx_builtin_SystemError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s__NotImplementedError); if (!__pyx_builtin_NotImplementedError) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/message.pyx":121
+ * 
+ *         if isinstance(data, unicode):
+ *             raise TypeError("Unicode objects not allowed. Only: str/bytes, buffer interfaces.")             # <<<<<<<<<<<<<<
+ * 
+ *         if data is None:
+ */
+  __pyx_k_tuple_3 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_2)); if (unlikely(!__pyx_k_tuple_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_3);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_3));
+
+  /* "zmq/core/message.pyx":189
+ *         cdef Py_ssize_t data_len_c
+ *         if idx != 0:
+ *             raise SystemError("accessing non-existent buffer segment")             # <<<<<<<<<<<<<<
+ *         # read-only, because we don't want to allow
+ *         # editing of the message in-place
+ */
+  __pyx_k_tuple_6 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_5)); if (unlikely(!__pyx_k_tuple_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_6);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_6));
+
+  /* "buffers.pxd":194
+ * 
+ *     if PY_MAJOR_VERSION >= 3 and bfmt is not None:
+ *         return bfmt.decode('ascii')             # <<<<<<<<<<<<<<
+ *     return bfmt
+ * 
+ */
+  __pyx_k_tuple_9 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__ascii)); if (unlikely(!__pyx_k_tuple_9)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_9);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_9));
+
+  /* "buffers.pxd":241
+ *             return PyBuffer_FromReadWriteMemory(ptr, s)
+ *     else:
+ *         raise NotImplementedError("Old style buffers not available.")             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_k_tuple_12 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_11)); if (unlikely(!__pyx_k_tuple_12)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_12);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_12));
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC initmessage(void); /*proto*/
+PyMODINIT_FUNC initmessage(void)
+#else
+PyMODINIT_FUNC PyInit_message(void); /*proto*/
+PyMODINIT_FUNC PyInit_message(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_message(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("message"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_13), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core.message")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core.message", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core__message) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  if (PyType_Ready(&__pyx_type_3zmq_4core_7message_MessageTracker) < 0) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetAttrString(__pyx_m, "MessageTracker", (PyObject *)&__pyx_type_3zmq_4core_7message_MessageTracker) < 0) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_3zmq_4core_7message_MessageTracker = &__pyx_type_3zmq_4core_7message_MessageTracker;
+  __pyx_vtabptr_3zmq_4core_7message_Frame = &__pyx_vtable_3zmq_4core_7message_Frame;
+  __pyx_vtable_3zmq_4core_7message_Frame.fast_copy = (struct __pyx_obj_3zmq_4core_7message_Frame *(*)(struct __pyx_obj_3zmq_4core_7message_Frame *))__pyx_f_3zmq_4core_7message_5Frame_fast_copy;
+  __pyx_vtable_3zmq_4core_7message_Frame._getbuffer = (PyObject *(*)(struct __pyx_obj_3zmq_4core_7message_Frame *))__pyx_f_3zmq_4core_7message_5Frame__getbuffer;
+  if (PyType_Ready(&__pyx_type_3zmq_4core_7message_Frame) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_CPYTHON
+  {
+    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&__pyx_type_3zmq_4core_7message_Frame, "__init__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
+      __pyx_wrapperbase_3zmq_4core_7message_5Frame_2__init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
+      __pyx_wrapperbase_3zmq_4core_7message_5Frame_2__init__.doc = __pyx_doc_3zmq_4core_7message_5Frame_2__init__;
+      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_3zmq_4core_7message_5Frame_2__init__;
+    }
+  }
+  #endif
+  #if CYTHON_COMPILING_IN_CPYTHON
+  {
+    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&__pyx_type_3zmq_4core_7message_Frame, "__len__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
+      __pyx_wrapperbase_3zmq_4core_7message_5Frame_14__len__ = *((PyWrapperDescrObject *)wrapper)->d_base;
+      __pyx_wrapperbase_3zmq_4core_7message_5Frame_14__len__.doc = __pyx_doc_3zmq_4core_7message_5Frame_14__len__;
+      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_3zmq_4core_7message_5Frame_14__len__;
+    }
+  }
+  #endif
+  #if CYTHON_COMPILING_IN_CPYTHON
+  {
+    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&__pyx_type_3zmq_4core_7message_Frame, "__str__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
+      __pyx_wrapperbase_3zmq_4core_7message_5Frame_16__str__ = *((PyWrapperDescrObject *)wrapper)->d_base;
+      __pyx_wrapperbase_3zmq_4core_7message_5Frame_16__str__.doc = __pyx_doc_3zmq_4core_7message_5Frame_16__str__;
+      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_3zmq_4core_7message_5Frame_16__str__;
+    }
+  }
+  #endif
+  if (__Pyx_SetVtable(__pyx_type_3zmq_4core_7message_Frame.tp_dict, __pyx_vtabptr_3zmq_4core_7message_Frame) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetAttrString(__pyx_m, "Frame", (PyObject *)&__pyx_type_3zmq_4core_7message_Frame) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_3zmq_4core_7message_Frame = &__pyx_type_3zmq_4core_7message_Frame;
+  /*--- Type import code ---*/
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
+  #if CYTHON_COMPILING_IN_PYPY
+  sizeof(PyTypeObject),
+  #else
+  sizeof(PyHeapTypeObject),
+  #endif
+  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), 0); if (unlikely(!__pyx_ptype_7cpython_4bool_bool)) {__pyx_filename = __pyx_f[6]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), 0); if (unlikely(!__pyx_ptype_7cpython_7complex_complex)) {__pyx_filename = __pyx_f[7]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_date = __Pyx_ImportType("datetime", "date", sizeof(PyDateTime_Date), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_date)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_time = __Pyx_ImportType("datetime", "time", sizeof(PyDateTime_Time), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_time)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_datetime = __Pyx_ImportType("datetime", "datetime", sizeof(PyDateTime_DateTime), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_datetime)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_timedelta = __Pyx_ImportType("datetime", "timedelta", sizeof(PyDateTime_Delta), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_timedelta)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_tzinfo = __Pyx_ImportType("datetime", "tzinfo", sizeof(PyDateTime_TZInfo), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_tzinfo)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/message.pyx":39
+ * from libzmq cimport *
+ * 
+ * import time             # <<<<<<<<<<<<<<
+ * 
+ * try:
+ */
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__time), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__time, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/message.pyx":41
+ * import time
+ * 
+ * try:             # <<<<<<<<<<<<<<
+ *     # below 3.3
+ *     from threading import _Event as Event
+ */
+  {
+    __Pyx_ExceptionSave(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4);
+    __Pyx_XGOTREF(__pyx_t_2);
+    __Pyx_XGOTREF(__pyx_t_3);
+    __Pyx_XGOTREF(__pyx_t_4);
+    /*try:*/ {
+
+      /* "zmq/core/message.pyx":43
+ * try:
+ *     # below 3.3
+ *     from threading import _Event as Event             # <<<<<<<<<<<<<<
+ * except (ImportError, AttributeError):
+ *     # python throws ImportError, cython throws AttributeError
+ */
+      __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s___Event));
+      PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s___Event));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s___Event));
+      __pyx_t_5 = __Pyx_Import(((PyObject *)__pyx_n_s__threading), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+      __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_5, __pyx_n_s___Event); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      if (PyDict_SetItem(__pyx_d, __pyx_n_s__Event, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L2_error;}
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    }
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    goto __pyx_L9_try_end;
+    __pyx_L2_error:;
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+
+    /* "zmq/core/message.pyx":44
+ *     # below 3.3
+ *     from threading import _Event as Event
+ * except (ImportError, AttributeError):             # <<<<<<<<<<<<<<
+ *     # python throws ImportError, cython throws AttributeError
+ *     from threading import Event
+ */
+    __pyx_t_6 = PyErr_ExceptionMatches(__pyx_builtin_ImportError) || PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
+    if (__pyx_t_6) {
+      __Pyx_AddTraceback("zmq.core.message", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_1, &__pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_GOTREF(__pyx_t_7);
+
+      /* "zmq/core/message.pyx":46
+ * except (ImportError, AttributeError):
+ *     # python throws ImportError, cython throws AttributeError
+ *     from threading import Event             # <<<<<<<<<<<<<<
+ * 
+ * import zmq
+ */
+      __pyx_t_8 = PyList_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__Event));
+      PyList_SET_ITEM(__pyx_t_8, 0, ((PyObject *)__pyx_n_s__Event));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Event));
+      __pyx_t_9 = __Pyx_Import(((PyObject *)__pyx_n_s__threading), ((PyObject *)__pyx_t_8), -1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+      __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_DECREF(((PyObject *)__pyx_t_8)); __pyx_t_8 = 0;
+      __pyx_t_8 = __Pyx_ImportFrom(__pyx_t_9, __pyx_n_s__Event); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+      __Pyx_GOTREF(__pyx_t_8);
+      if (PyDict_SetItem(__pyx_d, __pyx_n_s__Event, __pyx_t_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L4_except_error;}
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      goto __pyx_L3_exception_handled;
+    }
+    __pyx_L4_except_error:;
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_XGIVEREF(__pyx_t_4);
+    __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
+    goto __pyx_L1_error;
+    __pyx_L3_exception_handled:;
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_XGIVEREF(__pyx_t_4);
+    __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
+    __pyx_L9_try_end:;
+  }
+
+  /* "zmq/core/message.pyx":48
+ *     from threading import Event
+ * 
+ * import zmq             # <<<<<<<<<<<<<<
+ * from zmq.core.checkrc cimport _check_rc
+ * from zmq.utils.strtypes import bytes,unicode,basestring
+ */
+  __pyx_t_7 = __Pyx_Import(((PyObject *)__pyx_n_s__zmq), 0, -1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__zmq, __pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+
+  /* "zmq/core/message.pyx":50
+ * import zmq
+ * from zmq.core.checkrc cimport _check_rc
+ * from zmq.utils.strtypes import bytes,unicode,basestring             # <<<<<<<<<<<<<<
+ * 
+ * #-----------------------------------------------------------------------------
+ */
+  __pyx_t_7 = PyList_New(3); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__bytes));
+  PyList_SET_ITEM(__pyx_t_7, 0, ((PyObject *)__pyx_n_s__bytes));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__bytes));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__unicode));
+  PyList_SET_ITEM(__pyx_t_7, 1, ((PyObject *)__pyx_n_s__unicode));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__unicode));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__basestring));
+  PyList_SET_ITEM(__pyx_t_7, 2, ((PyObject *)__pyx_n_s__basestring));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__basestring));
+  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s_14), ((PyObject *)__pyx_t_7), -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
+  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s__bytes); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__bytes, __pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s__unicode); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__unicode, __pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s__basestring); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__basestring, __pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/message.pyx":96
+ *     """
+ * 
+ *     def __cinit__(self, object data=None, track=False, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef int rc
+ *         cdef char *data_c = NULL
+ */
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_k_1 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "zmq/core/message.pyx":146
+ *         self._failed_init = False
+ * 
+ *     def __init__(self, object data=None, track=False):             # <<<<<<<<<<<<<<
+ *         """Enforce signature"""
+ *         pass
+ */
+  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_k_4 = __pyx_t_1;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "zmq/core/message.pyx":265
+ * 
+ *     @property
+ *     def buffer(self):             # <<<<<<<<<<<<<<
+ *         """Get a read-only buffer view of the message contents."""
+ *         if self._buffer is None:
+ */
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3zmq_4core_7message_Frame, __pyx_n_s__buffer); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_7);
+  PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyObject_Call(__pyx_builtin_property, ((PyObject *)__pyx_t_7), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3zmq_4core_7message_Frame->tp_dict, __pyx_n_s__buffer, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_ptype_3zmq_4core_7message_Frame);
+
+  /* "zmq/core/message.pyx":272
+ * 
+ *     @property
+ *     def bytes(self):             # <<<<<<<<<<<<<<
+ *         """Get the message content as a Python str/bytes object.
+ * 
+ */
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3zmq_4core_7message_Frame, __pyx_n_s__bytes); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_7);
+  PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = PyObject_Call(__pyx_builtin_property, ((PyObject *)__pyx_t_7), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3zmq_4core_7message_Frame->tp_dict, __pyx_n_s__bytes, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_ptype_3zmq_4core_7message_Frame);
+
+  /* "zmq/core/message.pyx":295
+ * 
+ * # legacy Message name
+ * Message = Frame             # <<<<<<<<<<<<<<
+ * 
+ * __all__ = ['Frame', 'Message']
+ */
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__Message, ((PyObject *)((PyObject*)__pyx_ptype_3zmq_4core_7message_Frame))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/message.pyx":297
+ * Message = Frame
+ * 
+ * __all__ = ['Frame', 'Message']             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__Frame));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__Frame));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Frame));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__Message));
+  PyList_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_n_s__Message));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Message));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+
+  /* "zmq/core/message.pyx":1
+ * """0MQ Message related classes."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+
+  /* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_9);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core.message", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core.message");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
+    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+        PyObject *r = PyList_GET_ITEM(o, i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
+    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+        PyObject *r = PyTuple_GET_ITEM(o, i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (is_list || PyList_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
+        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
+            PyObject *r = PyList_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    else if (PyTuple_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
+        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    } else {
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
+                if (likely(l >= 0)) {
+                    i += l;
+                } else {
+                    if (PyErr_ExceptionMatches(PyExc_OverflowError))
+                        PyErr_Clear();
+                    else
+                        return NULL;
+                }
+            }
+            return m->sq_item(o, i);
+        }
+    }
+#else
+    if (is_list || PySequence_Check(o)) {
+        return PySequence_GetItem(o, i);
+    }
+#endif
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON
+    result = PyDict_GetItem(__pyx_d, name);
+    if (result) {
+        Py_INCREF(result);
+    } else {
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    if (!result) {
+        PyErr_Clear();
+#endif
+        result = __Pyx_GetBuiltinName(name);
+    }
+    return result;
+}
+
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name,
+    PyObject* kw_name)
+{
+    PyErr_Format(PyExc_TypeError,
+        #if PY_MAJOR_VERSION >= 3
+        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
+        #else
+        "%s() got multiple values for keyword argument '%s'", func_name,
+        PyString_AsString(kw_name));
+        #endif
+}
+
+static int __Pyx_ParseOptionalKeywords(
+    PyObject *kwds,
+    PyObject **argnames[],
+    PyObject *kwds2,
+    PyObject *values[],
+    Py_ssize_t num_pos_args,
+    const char* function_name)
+{
+    PyObject *key = 0, *value = 0;
+    Py_ssize_t pos = 0;
+    PyObject*** name;
+    PyObject*** first_kw_arg = argnames + num_pos_args;
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
+        name = first_kw_arg;
+        while (*name && (**name != key)) name++;
+        if (*name) {
+            values[name-argnames] = value;
+            continue;
+        }
+        name = first_kw_arg;
+        #if PY_MAJOR_VERSION < 3
+        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
+            while (*name) {
+                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
+                        && _PyString_Eq(**name, key)) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    if ((**argname == key) || (
+                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
+                             && _PyString_Eq(**argname, key))) {
+                        goto arg_passed_twice;
+                    }
+                    argname++;
+                }
+            }
+        } else
+        #endif
+        if (likely(PyUnicode_Check(key))) {
+            while (*name) {
+                int cmp = (**name == key) ? 0 :
+                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
+                #endif
+                    PyUnicode_Compare(**name, key);
+                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                if (cmp == 0) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    int cmp = (**argname == key) ? 0 :
+                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
+                    #endif
+                        PyUnicode_Compare(**argname, key);
+                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                    if (cmp == 0) goto arg_passed_twice;
+                    argname++;
+                }
+            }
+        } else
+            goto invalid_keyword_type;
+        if (kwds2) {
+            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+        } else {
+            goto invalid_keyword;
+        }
+    }
+    return 0;
+arg_passed_twice:
+    __Pyx_RaiseDoubleKeywordsError(function_name, key);
+    goto bad;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%s() keywords must be strings", function_name);
+    goto bad;
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%s() got an unexpected keyword argument '%s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+bad:
+    return -1;
+}
+
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
+}
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_Restore(type, value, tb);
+#endif
+}
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(type, value, tb);
+#endif
+}
+
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
+    Py_XINCREF(type);
+    if (!value || value == Py_None)
+        value = NULL;
+    else
+        Py_INCREF(value);
+    if (!tb || tb == Py_None)
+        tb = NULL;
+    else {
+        Py_INCREF(tb);
+        if (!PyTraceBack_Check(tb)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: arg 3 must be a traceback or None");
+            goto raise_error;
+        }
+    }
+    #if PY_VERSION_HEX < 0x02050000
+    if (PyClass_Check(type)) {
+    #else
+    if (PyType_Check(type)) {
+    #endif
+#if CYTHON_COMPILING_IN_PYPY
+        if (!value) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+#endif
+        PyErr_NormalizeException(&type, &value, &tb);
+    } else {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        value = type;
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyInstance_Check(type)) {
+            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+            Py_INCREF(type);
+        } else {
+            type = 0;
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception must be an old-style class or instance");
+            goto raise_error;
+        }
+        #else
+        type = (PyObject*) Py_TYPE(type);
+        Py_INCREF(type);
+        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception class must be a subclass of BaseException");
+            goto raise_error;
+        }
+        #endif
+    }
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+#else /* Python 3+ */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    PyObject* owned_instance = NULL;
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
+    }
+    if (value == Py_None)
+        value = 0;
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (PyExceptionClass_Check(type)) {
+        PyObject *args;
+        if (!value)
+            args = PyTuple_New(0);
+        else if (PyTuple_Check(value)) {
+            Py_INCREF(value);
+            args = value;
+        } else
+            args = PyTuple_Pack(1, value);
+        if (!args)
+            goto bad;
+        owned_instance = PyEval_CallObject(type, args);
+        Py_DECREF(args);
+        if (!owned_instance)
+            goto bad;
+        value = owned_instance;
+        if (!PyExceptionInstance_Check(value)) {
+            PyErr_Format(PyExc_TypeError,
+                         "calling %R should have returned an instance of "
+                         "BaseException, not %R",
+                         type, Py_TYPE(value));
+            goto bad;
+        }
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
+    }
+#if PY_VERSION_HEX >= 0x03030000
+    if (cause) {
+#else
+    if (cause && cause != Py_None) {
+#endif
+        PyObject *fixed_cause;
+        if (cause == Py_None) {
+            fixed_cause = NULL;
+        } else if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        } else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+    PyErr_SetObject(type, value);
+    if (tb) {
+        PyThreadState *tstate = PyThreadState_GET();
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
+    }
+bad:
+    Py_XDECREF(owned_instance);
+    return;
+}
+#endif
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
+    PyObject *local_type, *local_value, *local_tb;
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    local_type = tstate->curexc_type;
+    local_value = tstate->curexc_value;
+    local_tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(&local_type, &local_value, &local_tb);
+#endif
+    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
+#if CYTHON_COMPILING_IN_CPYTHON
+    if (unlikely(tstate->curexc_type))
+#else
+    if (unlikely(PyErr_Occurred()))
+#endif
+        goto bad;
+    #if PY_MAJOR_VERSION >= 3
+    if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
+        goto bad;
+    #endif
+    Py_INCREF(local_type);
+    Py_INCREF(local_value);
+    Py_INCREF(local_tb);
+    *type = local_type;
+    *value = local_value;
+    *tb = local_tb;
+#if CYTHON_COMPILING_IN_CPYTHON
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = local_type;
+    tstate->exc_value = local_value;
+    tstate->exc_traceback = local_tb;
+    /* Make sure tstate is in a consistent state when we XDECREF
+       these objects (DECREF may run arbitrary code). */
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(local_type, local_value, local_tb);
+#endif
+    return 0;
+bad:
+    *type = 0;
+    *value = 0;
+    *tb = 0;
+    Py_XDECREF(local_type);
+    Py_XDECREF(local_value);
+    Py_XDECREF(local_tb);
+    return -1;
+}
+
+static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name) {
+    PyObject *result;
+    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
+    if (!result)
+        result = __Pyx_GetModuleGlobalName(name);
+    return result;
+}
+
+static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+#else
+    PyErr_GetExcInfo(type, value, tb);
+#endif
+}
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(type, value, tb);
+#endif
+}
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_VERSION_HEX < 0x03030000
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    #if PY_VERSION_HEX >= 0x02050000
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if (strchr(__Pyx_MODULE_NAME, '.')) {
+                #if PY_VERSION_HEX < 0x03030000
+                PyObject *py_level = PyInt_FromLong(1);
+                if (!py_level)
+                    goto bad;
+                module = PyObject_CallFunctionObjArgs(py_import,
+                    name, global_dict, empty_dict, list, py_level, NULL);
+                Py_DECREF(py_level);
+                #else
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                #endif
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0; /* try absolute import on failure */
+        }
+        #endif
+        if (!module) {
+            #if PY_VERSION_HEX < 0x03030000
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+    #else
+    if (level>0) {
+        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
+        goto bad;
+    }
+    module = PyObject_CallFunctionObjArgs(py_import,
+        name, global_dict, empty_dict, list, NULL);
+    #endif
+bad:
+    #if PY_VERSION_HEX < 0x03030000
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
+                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename) {
+    PyObject *old_exc, *old_val, *old_tb;
+    PyObject *ctx;
+    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
+    #if PY_MAJOR_VERSION < 3
+    ctx = PyString_FromString(name);
+    #else
+    ctx = PyUnicode_FromString(name);
+    #endif
+    __Pyx_ErrRestore(old_exc, old_val, old_tb);
+    if (!ctx) {
+        PyErr_WriteUnraisable(Py_None);
+    } else {
+        PyErr_WriteUnraisable(ctx);
+        Py_DECREF(ctx);
+    }
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
+#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
+    PyObject *ob = PyCapsule_New(vtable, 0, 0);
+#else
+    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
+#endif
+    if (!ob)
+        goto bad;
+    if (PyDict_SetItemString(dict, "__pyx_vtable__", ob) < 0)
+        goto bad;
+    Py_DECREF(ob);
+    return 0;
+bad:
+    Py_XDECREF(ob);
+    return -1;
+}
+
+#ifndef __PYX_HAVE_RT_ImportModule
+#define __PYX_HAVE_RT_ImportModule
+static PyObject *__Pyx_ImportModule(const char *name) {
+    PyObject *py_name = 0;
+    PyObject *py_module = 0;
+    py_name = __Pyx_PyIdentifier_FromString(name);
+    if (!py_name)
+        goto bad;
+    py_module = PyImport_Import(py_name);
+    Py_DECREF(py_name);
+    return py_module;
+bad:
+    Py_XDECREF(py_name);
+    return 0;
+}
+#endif
+
+#ifndef __PYX_HAVE_RT_ImportType
+#define __PYX_HAVE_RT_ImportType
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
+    size_t size, int strict)
+{
+    PyObject *py_module = 0;
+    PyObject *result = 0;
+    PyObject *py_name = 0;
+    char warning[200];
+    Py_ssize_t basicsize;
+#ifdef Py_LIMITED_API
+    PyObject *py_basicsize;
+#endif
+    py_module = __Pyx_ImportModule(module_name);
+    if (!py_module)
+        goto bad;
+    py_name = __Pyx_PyIdentifier_FromString(class_name);
+    if (!py_name)
+        goto bad;
+    result = PyObject_GetAttr(py_module, py_name);
+    Py_DECREF(py_name);
+    py_name = 0;
+    Py_DECREF(py_module);
+    py_module = 0;
+    if (!result)
+        goto bad;
+    if (!PyType_Check(result)) {
+        PyErr_Format(PyExc_TypeError,
+            "%s.%s is not a type object",
+            module_name, class_name);
+        goto bad;
+    }
+#ifndef Py_LIMITED_API
+    basicsize = ((PyTypeObject *)result)->tp_basicsize;
+#else
+    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
+    if (!py_basicsize)
+        goto bad;
+    basicsize = PyLong_AsSsize_t(py_basicsize);
+    Py_DECREF(py_basicsize);
+    py_basicsize = 0;
+    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
+#endif
+    if (!strict && (size_t)basicsize > size) {
+        PyOS_snprintf(warning, sizeof(warning),
+            "%s.%s size changed, may indicate binary incompatibility",
+            module_name, class_name);
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyErr_Warn(NULL, warning) < 0) goto bad;
+        #else
+        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
+        #endif
+    }
+    else if ((size_t)basicsize != size) {
+        PyErr_Format(PyExc_ValueError,
+            "%s.%s has the wrong size, try recompiling",
+            module_name, class_name);
+        goto bad;
+    }
+    return (PyTypeObject *)result;
+bad:
+    Py_XDECREF(py_module);
+    Py_XDECREF(result);
+    return NULL;
+}
+#endif
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
--- /dev/null
+++ pyzmq-13.1.0/zmq/core/stopwatch.c
@@ -0,0 +1,2898 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core__stopwatch
+#define __PYX_HAVE_API__zmq__core__stopwatch
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "stopwatch.pyx",
+};
+
+/*--- Type declarations ---*/
+struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch;
+
+/* "zmq/core/stopwatch.pxd":27
+ * 
+ * 
+ * cdef class Stopwatch:             # <<<<<<<<<<<<<<
+ *     """A simple stopwatch based on zmq_stopwatch_start/stop."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch {
+  PyObject_HEAD
+  void *watch;
+};
+
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
+
+static CYTHON_INLINE int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed); /*proto*/
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+
+#ifndef __PYX_FORCE_INIT_THREADS
+  #define __PYX_FORCE_INIT_THREADS 0
+#endif
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static int __Pyx_check_binary_version(void);
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'zmq.core.stopwatch' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_9stopwatch_Stopwatch = 0;
+#define __Pyx_MODULE_NAME "zmq.core.stopwatch"
+int __pyx_module_is_main_zmq__core__stopwatch = 0;
+
+/* Implementation of 'zmq.core.stopwatch' */
+static int __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch___cinit__(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self); /* proto */
+static void __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_2__dealloc__(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_4start(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_6stop(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_8sleep(CYTHON_UNUSED struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self, int __pyx_v_seconds); /* proto */
+static PyObject *__pyx_tp_new_3zmq_4core_9stopwatch_Stopwatch(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static char __pyx_k_1[] = "Stopwatch is already runing.";
+static char __pyx_k_3[] = "Must start the Stopwatch before calling stop.";
+static char __pyx_k_5[] = "0MQ Stopwatch class.";
+static char __pyx_k_6[] = "zmq.error";
+static char __pyx_k__stop[] = "stop";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k__ZMQError[] = "ZMQError";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__Stopwatch[] = "Stopwatch";
+static char __pyx_k____import__[] = "__import__";
+static PyObject *__pyx_kp_s_1;
+static PyObject *__pyx_kp_s_3;
+static PyObject *__pyx_n_s_6;
+static PyObject *__pyx_n_s__Stopwatch;
+static PyObject *__pyx_n_s__ZMQError;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____import__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s__stop;
+static PyObject *__pyx_k_tuple_2;
+static PyObject *__pyx_k_tuple_4;
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
+  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
+    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
+  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
+  __pyx_r = __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch___cinit__(((struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/stopwatch.pyx":42
+ *     """
+ * 
+ *     def __cinit__(self):             # <<<<<<<<<<<<<<
+ *         self.watch = NULL
+ * 
+ */
+
+static int __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch___cinit__(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__", 0);
+
+  /* "zmq/core/stopwatch.pyx":43
+ * 
+ *     def __cinit__(self):
+ *         self.watch = NULL             # <<<<<<<<<<<<<<
+ * 
+ *     def __dealloc__(self):
+ */
+  __pyx_v_self->watch = NULL;
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static void __pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
+static void __pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_3__dealloc__(PyObject *__pyx_v_self) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
+  __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_2__dealloc__(((struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "zmq/core/stopwatch.pyx":45
+ *         self.watch = NULL
+ * 
+ *     def __dealloc__(self):             # <<<<<<<<<<<<<<
+ *         try:
+ *             self.stop()
+ */
+
+static void __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_2__dealloc__(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self) {
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__dealloc__", 0);
+
+  /* "zmq/core/stopwatch.pyx":46
+ * 
+ *     def __dealloc__(self):
+ *         try:             # <<<<<<<<<<<<<<
+ *             self.stop()
+ *         except ZMQError:
+ */
+  {
+    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
+    __Pyx_XGOTREF(__pyx_t_1);
+    __Pyx_XGOTREF(__pyx_t_2);
+    __Pyx_XGOTREF(__pyx_t_3);
+    /*try:*/ {
+
+      /* "zmq/core/stopwatch.pyx":47
+ *     def __dealloc__(self):
+ *         try:
+ *             self.stop()             # <<<<<<<<<<<<<<
+ *         except ZMQError:
+ *             pass
+ */
+      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s__stop); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 47; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_Call(__pyx_t_4, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 47; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    }
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    goto __pyx_L10_try_end;
+    __pyx_L3_error:;
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+
+    /* "zmq/core/stopwatch.pyx":48
+ *         try:
+ *             self.stop()
+ *         except ZMQError:             # <<<<<<<<<<<<<<
+ *             pass
+ * 
+ */
+    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L5_except_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_6 = PyErr_ExceptionMatches(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (__pyx_t_6) {
+      PyErr_Restore(0,0,0);
+      goto __pyx_L4_exception_handled;
+    }
+    __pyx_L5_except_error:;
+    __Pyx_XGIVEREF(__pyx_t_1);
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
+    goto __pyx_L1_error;
+    __pyx_L4_exception_handled:;
+    __Pyx_XGIVEREF(__pyx_t_1);
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
+    __pyx_L10_try_end:;
+  }
+
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("zmq.core.stopwatch.Stopwatch.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_5start(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_9stopwatch_9Stopwatch_4start[] = "s.start()\n\n        Start the stopwatch.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_5start(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("start (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_4start(((struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/stopwatch.pyx":51
+ *             pass
+ * 
+ *     def start(self):             # <<<<<<<<<<<<<<
+ *         """s.start()
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_4start(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("start", 0);
+
+  /* "zmq/core/stopwatch.pyx":56
+ *         Start the stopwatch.
+ *         """
+ *         if self.watch == NULL:             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 self.watch = zmq_stopwatch_start()
+ */
+  __pyx_t_1 = (__pyx_v_self->watch == NULL);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/stopwatch.pyx":57
+ *         """
+ *         if self.watch == NULL:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 self.watch = zmq_stopwatch_start()
+ *         else:
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/stopwatch.pyx":58
+ *         if self.watch == NULL:
+ *             with nogil:
+ *                 self.watch = zmq_stopwatch_start()             # <<<<<<<<<<<<<<
+ *         else:
+ *             raise ZMQError('Stopwatch is already runing.')
+ */
+          __pyx_v_self->watch = zmq_stopwatch_start();
+        }
+
+        /* "zmq/core/stopwatch.pyx":57
+ *         """
+ *         if self.watch == NULL:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 self.watch = zmq_stopwatch_start()
+ *         else:
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/stopwatch.pyx":60
+ *                 self.watch = zmq_stopwatch_start()
+ *         else:
+ *             raise ZMQError('Stopwatch is already runing.')             # <<<<<<<<<<<<<<
+ * 
+ *     def stop(self):
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_k_tuple_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.stopwatch.Stopwatch.start", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_7stop(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_9stopwatch_9Stopwatch_6stop[] = "s.stop()\n\n        Stop the stopwatch.\n        \n        Returns\n        -------\n        t : unsigned long int\n            the number of microseconds since ``start()`` was called.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_7stop(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("stop (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_6stop(((struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/stopwatch.pyx":62
+ *             raise ZMQError('Stopwatch is already runing.')
+ * 
+ *     def stop(self):             # <<<<<<<<<<<<<<
+ *         """s.stop()
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_6stop(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self) {
+  unsigned long __pyx_v_time;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("stop", 0);
+
+  /* "zmq/core/stopwatch.pyx":73
+ *         """
+ *         cdef unsigned long time
+ *         if self.watch == NULL:             # <<<<<<<<<<<<<<
+ *             raise ZMQError('Must start the Stopwatch before calling stop.')
+ *         else:
+ */
+  __pyx_t_1 = (__pyx_v_self->watch == NULL);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/stopwatch.pyx":74
+ *         cdef unsigned long time
+ *         if self.watch == NULL:
+ *             raise ZMQError('Must start the Stopwatch before calling stop.')             # <<<<<<<<<<<<<<
+ *         else:
+ *             with nogil:
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_k_tuple_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/stopwatch.pyx":76
+ *             raise ZMQError('Must start the Stopwatch before calling stop.')
+ *         else:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 time = zmq_stopwatch_stop(self.watch)
+ *             self.watch = NULL
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/stopwatch.pyx":77
+ *         else:
+ *             with nogil:
+ *                 time = zmq_stopwatch_stop(self.watch)             # <<<<<<<<<<<<<<
+ *             self.watch = NULL
+ *             return time
+ */
+          __pyx_v_time = zmq_stopwatch_stop(__pyx_v_self->watch);
+        }
+
+        /* "zmq/core/stopwatch.pyx":76
+ *             raise ZMQError('Must start the Stopwatch before calling stop.')
+ *         else:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 time = zmq_stopwatch_stop(self.watch)
+ *             self.watch = NULL
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+
+    /* "zmq/core/stopwatch.pyx":78
+ *             with nogil:
+ *                 time = zmq_stopwatch_stop(self.watch)
+ *             self.watch = NULL             # <<<<<<<<<<<<<<
+ *             return time
+ * 
+ */
+    __pyx_v_self->watch = NULL;
+
+    /* "zmq/core/stopwatch.pyx":79
+ *                 time = zmq_stopwatch_stop(self.watch)
+ *             self.watch = NULL
+ *             return time             # <<<<<<<<<<<<<<
+ * 
+ *     def sleep(self, int seconds):
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_3 = PyLong_FromUnsignedLong(__pyx_v_time); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.stopwatch.Stopwatch.stop", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_9sleep(PyObject *__pyx_v_self, PyObject *__pyx_arg_seconds); /*proto*/
+static char __pyx_doc_3zmq_4core_9stopwatch_9Stopwatch_8sleep[] = "s.sleep(seconds)\n\n        Sleep for an integer number of seconds.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_9sleep(PyObject *__pyx_v_self, PyObject *__pyx_arg_seconds) {
+  int __pyx_v_seconds;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("sleep (wrapper)", 0);
+  assert(__pyx_arg_seconds); {
+    __pyx_v_seconds = __Pyx_PyInt_AsInt(__pyx_arg_seconds); if (unlikely((__pyx_v_seconds == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.stopwatch.Stopwatch.sleep", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_8sleep(((struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *)__pyx_v_self), ((int)__pyx_v_seconds));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/stopwatch.pyx":81
+ *             return time
+ * 
+ *     def sleep(self, int seconds):             # <<<<<<<<<<<<<<
+ *         """s.sleep(seconds)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_9stopwatch_9Stopwatch_8sleep(CYTHON_UNUSED struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch *__pyx_v_self, int __pyx_v_seconds) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("sleep", 0);
+
+  /* "zmq/core/stopwatch.pyx":86
+ *         Sleep for an integer number of seconds.
+ *         """
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             zmq_sleep(seconds)
+ * 
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/stopwatch.pyx":87
+ *         """
+ *         with nogil:
+ *             zmq_sleep(seconds)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+        zmq_sleep(__pyx_v_seconds);
+      }
+
+      /* "zmq/core/stopwatch.pyx":86
+ *         Sleep for an integer number of seconds.
+ *         """
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             zmq_sleep(seconds)
+ * 
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_tp_new_3zmq_4core_9stopwatch_Stopwatch(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
+  PyObject *o;
+  o = (*t->tp_alloc)(t, 0);
+  if (unlikely(!o)) return 0;
+  if (unlikely(__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
+    Py_DECREF(o); o = 0;
+  }
+  return o;
+}
+
+static void __pyx_tp_dealloc_3zmq_4core_9stopwatch_Stopwatch(PyObject *o) {
+  {
+    PyObject *etype, *eval, *etb;
+    PyErr_Fetch(&etype, &eval, &etb);
+    ++Py_REFCNT(o);
+    __pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_3__dealloc__(o);
+    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
+    --Py_REFCNT(o);
+    PyErr_Restore(etype, eval, etb);
+  }
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static PyMethodDef __pyx_methods_3zmq_4core_9stopwatch_Stopwatch[] = {
+  {__Pyx_NAMESTR("start"), (PyCFunction)__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_5start, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_9stopwatch_9Stopwatch_4start)},
+  {__Pyx_NAMESTR("stop"), (PyCFunction)__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_7stop, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_9stopwatch_9Stopwatch_6stop)},
+  {__Pyx_NAMESTR("sleep"), (PyCFunction)__pyx_pw_3zmq_4core_9stopwatch_9Stopwatch_9sleep, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_9stopwatch_9Stopwatch_8sleep)},
+  {0, 0, 0, 0}
+};
+
+static PyNumberMethods __pyx_tp_as_number_Stopwatch = {
+  0, /*nb_add*/
+  0, /*nb_subtract*/
+  0, /*nb_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_divide*/
+  #endif
+  0, /*nb_remainder*/
+  0, /*nb_divmod*/
+  0, /*nb_power*/
+  0, /*nb_negative*/
+  0, /*nb_positive*/
+  0, /*nb_absolute*/
+  0, /*nb_nonzero*/
+  0, /*nb_invert*/
+  0, /*nb_lshift*/
+  0, /*nb_rshift*/
+  0, /*nb_and*/
+  0, /*nb_xor*/
+  0, /*nb_or*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_coerce*/
+  #endif
+  0, /*nb_int*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_long*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*nb_float*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_oct*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_hex*/
+  #endif
+  0, /*nb_inplace_add*/
+  0, /*nb_inplace_subtract*/
+  0, /*nb_inplace_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_inplace_divide*/
+  #endif
+  0, /*nb_inplace_remainder*/
+  0, /*nb_inplace_power*/
+  0, /*nb_inplace_lshift*/
+  0, /*nb_inplace_rshift*/
+  0, /*nb_inplace_and*/
+  0, /*nb_inplace_xor*/
+  0, /*nb_inplace_or*/
+  0, /*nb_floor_divide*/
+  0, /*nb_true_divide*/
+  0, /*nb_inplace_floor_divide*/
+  0, /*nb_inplace_true_divide*/
+  #if PY_VERSION_HEX >= 0x02050000
+  0, /*nb_index*/
+  #endif
+};
+
+static PySequenceMethods __pyx_tp_as_sequence_Stopwatch = {
+  0, /*sq_length*/
+  0, /*sq_concat*/
+  0, /*sq_repeat*/
+  0, /*sq_item*/
+  0, /*sq_slice*/
+  0, /*sq_ass_item*/
+  0, /*sq_ass_slice*/
+  0, /*sq_contains*/
+  0, /*sq_inplace_concat*/
+  0, /*sq_inplace_repeat*/
+};
+
+static PyMappingMethods __pyx_tp_as_mapping_Stopwatch = {
+  0, /*mp_length*/
+  0, /*mp_subscript*/
+  0, /*mp_ass_subscript*/
+};
+
+static PyBufferProcs __pyx_tp_as_buffer_Stopwatch = {
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getreadbuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getwritebuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getsegcount*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getcharbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_getbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_releasebuffer*/
+  #endif
+};
+
+static PyTypeObject __pyx_type_3zmq_4core_9stopwatch_Stopwatch = {
+  PyVarObject_HEAD_INIT(0, 0)
+  __Pyx_NAMESTR("zmq.core.stopwatch.Stopwatch"), /*tp_name*/
+  sizeof(struct __pyx_obj_3zmq_4core_9stopwatch_Stopwatch), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_3zmq_4core_9stopwatch_Stopwatch, /*tp_dealloc*/
+  0, /*tp_print*/
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*tp_repr*/
+  &__pyx_tp_as_number_Stopwatch, /*tp_as_number*/
+  &__pyx_tp_as_sequence_Stopwatch, /*tp_as_sequence*/
+  &__pyx_tp_as_mapping_Stopwatch, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  &__pyx_tp_as_buffer_Stopwatch, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
+  __Pyx_DOCSTR("Stopwatch()\n\n    A simple stopwatch based on zmq_stopwatch_start/stop.\n\n    This class should be used for benchmarking and timing 0MQ code.\n    "), /*tp_doc*/
+  0, /*tp_traverse*/
+  0, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_3zmq_4core_9stopwatch_Stopwatch, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  0, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_3zmq_4core_9stopwatch_Stopwatch, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*tp_version_tag*/
+  #endif
+};
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("stopwatch"),
+    __Pyx_DOCSTR(__pyx_k_5), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 0},
+  {&__pyx_kp_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 0},
+  {&__pyx_n_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 1},
+  {&__pyx_n_s__Stopwatch, __pyx_k__Stopwatch, sizeof(__pyx_k__Stopwatch), 0, 0, 1, 1},
+  {&__pyx_n_s__ZMQError, __pyx_k__ZMQError, sizeof(__pyx_k__ZMQError), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s__stop, __pyx_k__stop, sizeof(__pyx_k__stop), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  return 0;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/stopwatch.pyx":60
+ *                 self.watch = zmq_stopwatch_start()
+ *         else:
+ *             raise ZMQError('Stopwatch is already runing.')             # <<<<<<<<<<<<<<
+ * 
+ *     def stop(self):
+ */
+  __pyx_k_tuple_2 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_1)); if (unlikely(!__pyx_k_tuple_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_2);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_2));
+
+  /* "zmq/core/stopwatch.pyx":74
+ *         cdef unsigned long time
+ *         if self.watch == NULL:
+ *             raise ZMQError('Must start the Stopwatch before calling stop.')             # <<<<<<<<<<<<<<
+ *         else:
+ *             with nogil:
+ */
+  __pyx_k_tuple_4 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_4);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_4));
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC initstopwatch(void); /*proto*/
+PyMODINIT_FUNC initstopwatch(void)
+#else
+PyMODINIT_FUNC PyInit_stopwatch(void); /*proto*/
+PyMODINIT_FUNC PyInit_stopwatch(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_stopwatch(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("stopwatch"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_5), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core.stopwatch")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core.stopwatch", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core__stopwatch) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  if (PyType_Ready(&__pyx_type_3zmq_4core_9stopwatch_Stopwatch) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetAttrString(__pyx_m, "Stopwatch", (PyObject *)&__pyx_type_3zmq_4core_9stopwatch_Stopwatch) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_3zmq_4core_9stopwatch_Stopwatch = &__pyx_type_3zmq_4core_9stopwatch_Stopwatch;
+  /*--- Type import code ---*/
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/stopwatch.pyx":28
+ * from libzmq cimport zmq_stopwatch_start, zmq_stopwatch_stop, zmq_sleep
+ * 
+ * from zmq.error import ZMQError             # <<<<<<<<<<<<<<
+ * 
+ * #-----------------------------------------------------------------------------
+ */
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQError));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__ZMQError));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQError));
+  __pyx_t_2 = __Pyx_Import(((PyObject *)__pyx_n_s_6), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s__ZMQError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ZMQError, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "zmq/core/stopwatch.pyx":90
+ * 
+ * 
+ * __all__ = ['Stopwatch']             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__Stopwatch));
+  PyList_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_n_s__Stopwatch));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Stopwatch));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+
+  /* "zmq/core/stopwatch.pyx":1
+ * """0MQ Stopwatch class."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core.stopwatch", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core.stopwatch");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
+}
+
+static CYTHON_INLINE int __Pyx_CheckKeywordStrings(
+    PyObject *kwdict,
+    const char* function_name,
+    int kw_allowed)
+{
+    PyObject* key = 0;
+    Py_ssize_t pos = 0;
+#if CPYTHON_COMPILING_IN_PYPY
+    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
+        goto invalid_keyword;
+    return 1;
+#else
+    while (PyDict_Next(kwdict, &pos, &key, 0)) {
+        #if PY_MAJOR_VERSION < 3
+        if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key)))
+        #endif
+            if (unlikely(!PyUnicode_Check(key)))
+                goto invalid_keyword_type;
+    }
+    if ((!kw_allowed) && unlikely(key))
+        goto invalid_keyword;
+    return 1;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%s() keywords must be strings", function_name);
+    return 0;
+#endif
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%s() got an unexpected keyword argument '%s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+    return 0;
+}
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON
+    result = PyDict_GetItem(__pyx_d, name);
+    if (result) {
+        Py_INCREF(result);
+    } else {
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    if (!result) {
+        PyErr_Clear();
+#endif
+        result = __Pyx_GetBuiltinName(name);
+    }
+    return result;
+}
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_Restore(type, value, tb);
+#endif
+}
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(type, value, tb);
+#endif
+}
+
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
+    Py_XINCREF(type);
+    if (!value || value == Py_None)
+        value = NULL;
+    else
+        Py_INCREF(value);
+    if (!tb || tb == Py_None)
+        tb = NULL;
+    else {
+        Py_INCREF(tb);
+        if (!PyTraceBack_Check(tb)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: arg 3 must be a traceback or None");
+            goto raise_error;
+        }
+    }
+    #if PY_VERSION_HEX < 0x02050000
+    if (PyClass_Check(type)) {
+    #else
+    if (PyType_Check(type)) {
+    #endif
+#if CYTHON_COMPILING_IN_PYPY
+        if (!value) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+#endif
+        PyErr_NormalizeException(&type, &value, &tb);
+    } else {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        value = type;
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyInstance_Check(type)) {
+            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+            Py_INCREF(type);
+        } else {
+            type = 0;
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception must be an old-style class or instance");
+            goto raise_error;
+        }
+        #else
+        type = (PyObject*) Py_TYPE(type);
+        Py_INCREF(type);
+        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception class must be a subclass of BaseException");
+            goto raise_error;
+        }
+        #endif
+    }
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+#else /* Python 3+ */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    PyObject* owned_instance = NULL;
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
+    }
+    if (value == Py_None)
+        value = 0;
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (PyExceptionClass_Check(type)) {
+        PyObject *args;
+        if (!value)
+            args = PyTuple_New(0);
+        else if (PyTuple_Check(value)) {
+            Py_INCREF(value);
+            args = value;
+        } else
+            args = PyTuple_Pack(1, value);
+        if (!args)
+            goto bad;
+        owned_instance = PyEval_CallObject(type, args);
+        Py_DECREF(args);
+        if (!owned_instance)
+            goto bad;
+        value = owned_instance;
+        if (!PyExceptionInstance_Check(value)) {
+            PyErr_Format(PyExc_TypeError,
+                         "calling %R should have returned an instance of "
+                         "BaseException, not %R",
+                         type, Py_TYPE(value));
+            goto bad;
+        }
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
+    }
+#if PY_VERSION_HEX >= 0x03030000
+    if (cause) {
+#else
+    if (cause && cause != Py_None) {
+#endif
+        PyObject *fixed_cause;
+        if (cause == Py_None) {
+            fixed_cause = NULL;
+        } else if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        } else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+    PyErr_SetObject(type, value);
+    if (tb) {
+        PyThreadState *tstate = PyThreadState_GET();
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
+    }
+bad:
+    Py_XDECREF(owned_instance);
+    return;
+}
+#endif
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+#else
+    PyErr_GetExcInfo(type, value, tb);
+#endif
+}
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(type, value, tb);
+#endif
+}
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_VERSION_HEX < 0x03030000
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    #if PY_VERSION_HEX >= 0x02050000
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if (strchr(__Pyx_MODULE_NAME, '.')) {
+                #if PY_VERSION_HEX < 0x03030000
+                PyObject *py_level = PyInt_FromLong(1);
+                if (!py_level)
+                    goto bad;
+                module = PyObject_CallFunctionObjArgs(py_import,
+                    name, global_dict, empty_dict, list, py_level, NULL);
+                Py_DECREF(py_level);
+                #else
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                #endif
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0; /* try absolute import on failure */
+        }
+        #endif
+        if (!module) {
+            #if PY_VERSION_HEX < 0x03030000
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+    #else
+    if (level>0) {
+        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
+        goto bad;
+    }
+    module = PyObject_CallFunctionObjArgs(py_import,
+        name, global_dict, empty_dict, list, NULL);
+    #endif
+bad:
+    #if PY_VERSION_HEX < 0x03030000
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
--- /dev/null
+++ pyzmq-13.1.0/zmq/core/_device.c
@@ -0,0 +1,4157 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core___device
+#define __PYX_HAVE_API__zmq__core___device
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#include "errno.h"
+#include "string.h"
+#include "stdio.h"
+#include "pythread.h"
+#include "datetime.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "_device.pyx",
+  "checkrc.pxd",
+  "datetime.pxd",
+  "context.pxd",
+  "socket.pxd",
+  "type.pxd",
+  "bool.pxd",
+  "complex.pxd",
+};
+
+/*--- Type declarations ---*/
+struct __pyx_obj_3zmq_4core_6socket_Socket;
+struct __pyx_obj_3zmq_4core_7context_Context;
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send;
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv;
+
+/* "zmq/core/socket.pxd":46
+ * 
+ *     # cpdef methods for direct-cython access:
+ *     cpdef object send(self, object data, int flags=*, copy=*, track=*)             # <<<<<<<<<<<<<<
+ *     cpdef object recv(self, int flags=*, copy=*, track=*)
+ * 
+ */
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send {
+  int __pyx_n;
+  int flags;
+  PyObject *copy;
+  PyObject *track;
+};
+
+/* "zmq/core/socket.pxd":47
+ *     # cpdef methods for direct-cython access:
+ *     cpdef object send(self, object data, int flags=*, copy=*, track=*)
+ *     cpdef object recv(self, int flags=*, copy=*, track=*)             # <<<<<<<<<<<<<<
+ * 
+ */
+struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv {
+  int __pyx_n;
+  int flags;
+  PyObject *copy;
+  PyObject *track;
+};
+
+/* "zmq/core/socket.pxd":33
+ * 
+ * 
+ * cdef class Socket:             # <<<<<<<<<<<<<<
+ *     """A 0MQ socket."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_6socket_Socket {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_6socket_Socket *__pyx_vtab;
+  PyObject *__weakref__;
+  void *handle;
+  int socket_type;
+  struct __pyx_obj_3zmq_4core_7context_Context *context;
+  int _closed;
+  int _pid;
+};
+
+
+/* "context.pxd":26
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class Context:             # <<<<<<<<<<<<<<
+ *     """Manage the lifecycle of a 0MQ context."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_7context_Context {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_7context_Context *__pyx_vtab;
+  PyObject *__weakref__;
+  void *handle;
+  void **_sockets;
+  size_t _n_sockets;
+  size_t _max_sockets;
+  int _pid;
+  PyObject *closed;
+};
+
+
+
+/* "zmq/core/socket.pxd":33
+ * 
+ * 
+ * cdef class Socket:             # <<<<<<<<<<<<<<
+ *     """A 0MQ socket."""
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_6socket_Socket {
+  PyObject *(*send)(struct __pyx_obj_3zmq_4core_6socket_Socket *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_send *__pyx_optional_args);
+  PyObject *(*recv)(struct __pyx_obj_3zmq_4core_6socket_Socket *, int __pyx_skip_dispatch, struct __pyx_opt_args_3zmq_4core_6socket_6Socket_recv *__pyx_optional_args);
+};
+static struct __pyx_vtabstruct_3zmq_4core_6socket_Socket *__pyx_vtabptr_3zmq_4core_6socket_Socket;
+
+
+/* "context.pxd":26
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class Context:             # <<<<<<<<<<<<<<
+ *     """Manage the lifecycle of a 0MQ context."""
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_7context_Context {
+  void (*_add_socket)(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+  void (*_remove_socket)(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+};
+static struct __pyx_vtabstruct_3zmq_4core_7context_Context *__pyx_vtabptr_3zmq_4core_7context_Context;
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
+
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/
+
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
+    const char* function_name); /*proto*/
+
+static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
+    const char *name, int exact); /*proto*/
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
+
+#ifndef __PYX_FORCE_INIT_THREADS
+  #define __PYX_FORCE_INIT_THREADS 0
+#endif
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static int __Pyx_check_binary_version(void);
+
+#if !defined(__Pyx_PyIdentifier_FromString)
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
+#else
+  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
+#endif
+#endif
+
+static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
+
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/
+
+static void* __Pyx_GetVtable(PyObject *dict); /*proto*/
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'zmq.core.context' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_7context_Context = 0;
+
+/* Module declarations from 'zmq.core.socket' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_6socket_Socket = 0;
+
+/* Module declarations from 'libc.errno' */
+
+/* Module declarations from 'cpython.version' */
+
+/* Module declarations from 'cpython.ref' */
+
+/* Module declarations from 'cpython.exc' */
+
+/* Module declarations from 'cpython.module' */
+
+/* Module declarations from 'cpython.mem' */
+
+/* Module declarations from 'cpython.tuple' */
+
+/* Module declarations from 'cpython.list' */
+
+/* Module declarations from 'libc.string' */
+
+/* Module declarations from 'libc.stdio' */
+
+/* Module declarations from 'cpython.object' */
+
+/* Module declarations from 'cpython.sequence' */
+
+/* Module declarations from 'cpython.mapping' */
+
+/* Module declarations from 'cpython.iterator' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.type' */
+static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
+
+/* Module declarations from 'cpython.number' */
+
+/* Module declarations from 'cpython.int' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.bool' */
+static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;
+
+/* Module declarations from 'cpython.long' */
+
+/* Module declarations from 'cpython.float' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.complex' */
+static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;
+
+/* Module declarations from 'cpython.string' */
+
+/* Module declarations from 'cpython.unicode' */
+
+/* Module declarations from 'cpython.dict' */
+
+/* Module declarations from 'cpython.instance' */
+
+/* Module declarations from 'cpython.function' */
+
+/* Module declarations from 'cpython.method' */
+
+/* Module declarations from 'cpython.weakref' */
+
+/* Module declarations from 'cpython.getargs' */
+
+/* Module declarations from 'cpython.pythread' */
+
+/* Module declarations from 'cpython.pystate' */
+
+/* Module declarations from 'cpython.cobject' */
+
+/* Module declarations from 'cpython.oldbuffer' */
+
+/* Module declarations from 'cpython.set' */
+
+/* Module declarations from 'cpython.buffer' */
+
+/* Module declarations from 'cpython.bytes' */
+
+/* Module declarations from 'cpython.pycapsule' */
+
+/* Module declarations from 'datetime' */
+
+/* Module declarations from 'cpython.datetime' */
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_date = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_time = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_datetime = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_timedelta = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_tzinfo = 0;
+
+/* Module declarations from 'cpython' */
+
+/* Module declarations from 'zmq.core.checkrc' */
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int); /*proto*/
+
+/* Module declarations from 'zmq.core._device' */
+#define __Pyx_MODULE_NAME "zmq.core._device"
+int __pyx_module_is_main_zmq__core___device = 0;
+
+/* Implementation of 'zmq.core._device' */
+static PyObject *__pyx_pf_3zmq_4core_7_device_device(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_device_type, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_frontend, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_backend); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7_device_2proxy(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_frontend, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_backend, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_capture); /* proto */
+static char __pyx_k_1[] = "zmq.error";
+static char __pyx_k_2[] = "Python binding for 0MQ device function.";
+static char __pyx_k_5[] = "/private/tmp/pyzmq/zmq/core/_device.pyx";
+static char __pyx_k_6[] = "zmq.core._device";
+static char __pyx_k__rc[] = "rc";
+static char __pyx_k__Again[] = "Again";
+static char __pyx_k__proxy[] = "proxy";
+static char __pyx_k__device[] = "device";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k__backend[] = "backend";
+static char __pyx_k__capture[] = "capture";
+static char __pyx_k__ZMQError[] = "ZMQError";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__frontend[] = "frontend";
+static char __pyx_k____import__[] = "__import__";
+static char __pyx_k__device_type[] = "device_type";
+static char __pyx_k__capture_handle[] = "capture_handle";
+static char __pyx_k__ContextTerminated[] = "ContextTerminated";
+static PyObject *__pyx_n_s_1;
+static PyObject *__pyx_kp_s_5;
+static PyObject *__pyx_n_s_6;
+static PyObject *__pyx_n_s__Again;
+static PyObject *__pyx_n_s__ContextTerminated;
+static PyObject *__pyx_n_s__ZMQError;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____import__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s__backend;
+static PyObject *__pyx_n_s__capture;
+static PyObject *__pyx_n_s__capture_handle;
+static PyObject *__pyx_n_s__device;
+static PyObject *__pyx_n_s__device_type;
+static PyObject *__pyx_n_s__frontend;
+static PyObject *__pyx_n_s__proxy;
+static PyObject *__pyx_n_s__rc;
+static PyObject *__pyx_k_tuple_3;
+static PyObject *__pyx_k_tuple_7;
+static PyObject *__pyx_k_codeobj_4;
+static PyObject *__pyx_k_codeobj_8;
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7_device_1device(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_7_device_device[] = "device(device_type, frontend, backend)\n\n    Start a zeromq device.\n    \n    WARNING: zmq.device is deprecated as of libzmq-3.2,\n    in favor of zmq.proxy.\n\n    Parameters\n    ----------\n    device_type : (QUEUE, FORWARDER, STREAMER)\n        The type of device to start.\n    frontend : Socket\n        The Socket instance for the incoming traffic.\n    backend : Socket\n        The Socket instance for the outbound traffic.\n    ";
+static PyMethodDef __pyx_mdef_3zmq_4core_7_device_1device = {__Pyx_NAMESTR("device"), (PyCFunction)__pyx_pw_3zmq_4core_7_device_1device, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7_device_device)};
+static PyObject *__pyx_pw_3zmq_4core_7_device_1device(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_v_device_type;
+  struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_frontend = 0;
+  struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_backend = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("device (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__device_type,&__pyx_n_s__frontend,&__pyx_n_s__backend,0};
+    PyObject* values[3] = {0,0,0};
+
+    /* "zmq/core/_device.pyx":34
+ * #-----------------------------------------------------------------------------
+ * 
+ * def device(int device_type, cSocket frontend, cSocket backend=None):             # <<<<<<<<<<<<<<
+ *     """device(device_type, frontend, backend)
+ * 
+ */
+    values[2] = (PyObject *)((struct __pyx_obj_3zmq_4core_6socket_Socket *)Py_None);
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__device_type)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__frontend)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("device", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+        case  2:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__backend);
+          if (value) { values[2] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "device") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_device_type = __Pyx_PyInt_AsInt(values[0]); if (unlikely((__pyx_v_device_type == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    __pyx_v_frontend = ((struct __pyx_obj_3zmq_4core_6socket_Socket *)values[1]);
+    __pyx_v_backend = ((struct __pyx_obj_3zmq_4core_6socket_Socket *)values[2]);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("device", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core._device.device", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_frontend), __pyx_ptype_3zmq_4core_6socket_Socket, 1, "frontend", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_backend), __pyx_ptype_3zmq_4core_6socket_Socket, 1, "backend", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_r = __pyx_pf_3zmq_4core_7_device_device(__pyx_self, __pyx_v_device_type, __pyx_v_frontend, __pyx_v_backend);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3zmq_4core_7_device_device(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_device_type, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_frontend, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_backend) {
+  int __pyx_v_rc;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("device", 0);
+
+  /* "zmq/core/_device.pyx":51
+ *         The Socket instance for the outbound traffic.
+ *     """
+ *     if ZMQ_VERSION_MAJOR >= 3:             # <<<<<<<<<<<<<<
+ *         return proxy(frontend, backend)
+ * 
+ */
+  __pyx_t_1 = (ZMQ_VERSION_MAJOR >= 3);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/_device.pyx":52
+ *     """
+ *     if ZMQ_VERSION_MAJOR >= 3:
+ *         return proxy(frontend, backend)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef int rc = 0
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__proxy); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_INCREF(((PyObject *)__pyx_v_frontend));
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_frontend));
+    __Pyx_GIVEREF(((PyObject *)__pyx_v_frontend));
+    __Pyx_INCREF(((PyObject *)__pyx_v_backend));
+    PyTuple_SET_ITEM(__pyx_t_3, 1, ((PyObject *)__pyx_v_backend));
+    __Pyx_GIVEREF(((PyObject *)__pyx_v_backend));
+    __pyx_t_4 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __pyx_r = __pyx_t_4;
+    __pyx_t_4 = 0;
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/_device.pyx":54
+ *         return proxy(frontend, backend)
+ * 
+ *     cdef int rc = 0             # <<<<<<<<<<<<<<
+ *     with nogil:
+ *         rc = zmq_device(device_type, frontend.handle, backend.handle)
+ */
+  __pyx_v_rc = 0;
+
+  /* "zmq/core/_device.pyx":55
+ * 
+ *     cdef int rc = 0
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_device(device_type, frontend.handle, backend.handle)
+ *     _check_rc(rc)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/_device.pyx":56
+ *     cdef int rc = 0
+ *     with nogil:
+ *         rc = zmq_device(device_type, frontend.handle, backend.handle)             # <<<<<<<<<<<<<<
+ *     _check_rc(rc)
+ *     return rc
+ */
+        __pyx_v_rc = zmq_device(__pyx_v_device_type, __pyx_v_frontend->handle, __pyx_v_backend->handle);
+      }
+
+      /* "zmq/core/_device.pyx":55
+ * 
+ *     cdef int rc = 0
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_device(device_type, frontend.handle, backend.handle)
+ *     _check_rc(rc)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/_device.pyx":57
+ *     with nogil:
+ *         rc = zmq_device(device_type, frontend.handle, backend.handle)
+ *     _check_rc(rc)             # <<<<<<<<<<<<<<
+ *     return rc
+ * 
+ */
+  __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/_device.pyx":58
+ *         rc = zmq_device(device_type, frontend.handle, backend.handle)
+ *     _check_rc(rc)
+ *     return rc             # <<<<<<<<<<<<<<
+ * 
+ * def proxy(cSocket frontend, cSocket backend, cSocket capture=None):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_4 = PyInt_FromLong(__pyx_v_rc); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_r = __pyx_t_4;
+  __pyx_t_4 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core._device.device", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7_device_3proxy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_7_device_2proxy[] = "proxy(frontend, backend, capture)\n\n    Start a zeromq proxy (replacement for device).\n\n    Parameters\n    ----------\n    frontend : Socket\n        The Socket instance for the incoming traffic.\n    backend : Socket\n        The Socket instance for the outbound traffic.\n    capture : Socket\n        The Socket instance for capturing traffic.\n    ";
+static PyMethodDef __pyx_mdef_3zmq_4core_7_device_3proxy = {__Pyx_NAMESTR("proxy"), (PyCFunction)__pyx_pw_3zmq_4core_7_device_3proxy, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7_device_2proxy)};
+static PyObject *__pyx_pw_3zmq_4core_7_device_3proxy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_frontend = 0;
+  struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_backend = 0;
+  struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_capture = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("proxy (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__frontend,&__pyx_n_s__backend,&__pyx_n_s__capture,0};
+    PyObject* values[3] = {0,0,0};
+
+    /* "zmq/core/_device.pyx":60
+ *     return rc
+ * 
+ * def proxy(cSocket frontend, cSocket backend, cSocket capture=None):             # <<<<<<<<<<<<<<
+ *     """proxy(frontend, backend, capture)
+ * 
+ */
+    values[2] = (PyObject *)((struct __pyx_obj_3zmq_4core_6socket_Socket *)Py_None);
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__frontend)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__backend)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("proxy", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+        case  2:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__capture);
+          if (value) { values[2] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "proxy") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_frontend = ((struct __pyx_obj_3zmq_4core_6socket_Socket *)values[0]);
+    __pyx_v_backend = ((struct __pyx_obj_3zmq_4core_6socket_Socket *)values[1]);
+    __pyx_v_capture = ((struct __pyx_obj_3zmq_4core_6socket_Socket *)values[2]);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("proxy", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core._device.proxy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_frontend), __pyx_ptype_3zmq_4core_6socket_Socket, 1, "frontend", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_backend), __pyx_ptype_3zmq_4core_6socket_Socket, 1, "backend", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_capture), __pyx_ptype_3zmq_4core_6socket_Socket, 1, "capture", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_r = __pyx_pf_3zmq_4core_7_device_2proxy(__pyx_self, __pyx_v_frontend, __pyx_v_backend, __pyx_v_capture);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3zmq_4core_7_device_2proxy(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_frontend, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_backend, struct __pyx_obj_3zmq_4core_6socket_Socket *__pyx_v_capture) {
+  int __pyx_v_rc;
+  void *__pyx_v_capture_handle;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  void *__pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("proxy", 0);
+
+  /* "zmq/core/_device.pyx":74
+ *         The Socket instance for capturing traffic.
+ *     """
+ *     cdef int rc = 0             # <<<<<<<<<<<<<<
+ *     cdef void* capture_handle
+ *     if isinstance(capture, cSocket):
+ */
+  __pyx_v_rc = 0;
+
+  /* "zmq/core/_device.pyx":76
+ *     cdef int rc = 0
+ *     cdef void* capture_handle
+ *     if isinstance(capture, cSocket):             # <<<<<<<<<<<<<<
+ *         capture_handle = capture.handle
+ *     else:
+ */
+  __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_capture), ((PyObject*)__pyx_ptype_3zmq_4core_6socket_Socket)); 
+  if (__pyx_t_1) {
+
+    /* "zmq/core/_device.pyx":77
+ *     cdef void* capture_handle
+ *     if isinstance(capture, cSocket):
+ *         capture_handle = capture.handle             # <<<<<<<<<<<<<<
+ *     else:
+ *         capture_handle = NULL
+ */
+    __pyx_t_2 = __pyx_v_capture->handle;
+    __pyx_v_capture_handle = __pyx_t_2;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/_device.pyx":79
+ *         capture_handle = capture.handle
+ *     else:
+ *         capture_handle = NULL             # <<<<<<<<<<<<<<
+ *     with nogil:
+ *         rc = zmq_proxy(frontend.handle, backend.handle, capture_handle)
+ */
+    __pyx_v_capture_handle = NULL;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/_device.pyx":80
+ *     else:
+ *         capture_handle = NULL
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_proxy(frontend.handle, backend.handle, capture_handle)
+ *     _check_rc(rc)
+ */
+  {
+      #ifdef WITH_THREAD
+      PyThreadState *_save;
+      Py_UNBLOCK_THREADS
+      #endif
+      /*try:*/ {
+
+        /* "zmq/core/_device.pyx":81
+ *         capture_handle = NULL
+ *     with nogil:
+ *         rc = zmq_proxy(frontend.handle, backend.handle, capture_handle)             # <<<<<<<<<<<<<<
+ *     _check_rc(rc)
+ *     return rc
+ */
+        __pyx_v_rc = zmq_proxy(__pyx_v_frontend->handle, __pyx_v_backend->handle, __pyx_v_capture_handle);
+      }
+
+      /* "zmq/core/_device.pyx":80
+ *     else:
+ *         capture_handle = NULL
+ *     with nogil:             # <<<<<<<<<<<<<<
+ *         rc = zmq_proxy(frontend.handle, backend.handle, capture_handle)
+ *     _check_rc(rc)
+ */
+      /*finally:*/ {
+        #ifdef WITH_THREAD
+        Py_BLOCK_THREADS
+        #endif
+      }
+  }
+
+  /* "zmq/core/_device.pyx":82
+ *     with nogil:
+ *         rc = zmq_proxy(frontend.handle, backend.handle, capture_handle)
+ *     _check_rc(rc)             # <<<<<<<<<<<<<<
+ *     return rc
+ * 
+ */
+  __pyx_t_3 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/_device.pyx":83
+ *         rc = zmq_proxy(frontend.handle, backend.handle, capture_handle)
+ *     _check_rc(rc)
+ *     return rc             # <<<<<<<<<<<<<<
+ * 
+ * __all__ = ['device', 'proxy']
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_4 = PyInt_FromLong(__pyx_v_rc); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_r = __pyx_t_4;
+  __pyx_t_4 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core._device.proxy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/checkrc.pxd":5
+ * from libzmq cimport zmq_errno, ZMQ_ETERM
+ * 
+ * cdef inline int _check_rc(int rc) except -1:             # <<<<<<<<<<<<<<
+ *     """internal utility for checking zmq return condition
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int __pyx_v_rc) {
+  int __pyx_v_errno;
+  PyObject *__pyx_v_Again = NULL;
+  PyObject *__pyx_v_ContextTerminated = NULL;
+  PyObject *__pyx_v_ZMQError = NULL;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_check_rc", 0);
+
+  /* "zmq/core/checkrc.pxd":10
+ *     and raising the appropriate Exception class
+ *     """
+ *     cdef int errno = zmq_errno()             # <<<<<<<<<<<<<<
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ */
+  __pyx_v_errno = zmq_errno();
+
+  /* "zmq/core/checkrc.pxd":11
+ *     """
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()             # <<<<<<<<<<<<<<
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ */
+  __pyx_t_1 = PyErr_CheckSignals(); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/checkrc.pxd":12
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()
+ *     if rc < 0:             # <<<<<<<<<<<<<<
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ */
+  __pyx_t_2 = (__pyx_v_rc < 0);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+    switch (__pyx_v_errno) {
+
+      /* "zmq/core/checkrc.pxd":13
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ *         if errno == EAGAIN:             # <<<<<<<<<<<<<<
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ */
+      case EAGAIN:
+
+      /* "zmq/core/checkrc.pxd":14
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again             # <<<<<<<<<<<<<<
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__Again));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__Again));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Again));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_1), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__Again); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_Again = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":15
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ *             raise Again(errno)             # <<<<<<<<<<<<<<
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_Again, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+
+      /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+      case ETERM:
+
+      /* "zmq/core/checkrc.pxd":17
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated             # <<<<<<<<<<<<<<
+ *             raise ContextTerminated(errno)
+ *         else:
+ */
+      __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      PyList_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_n_s__ContextTerminated));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      __pyx_t_3 = __Pyx_Import(((PyObject *)__pyx_n_s_1), ((PyObject *)__pyx_t_4), -1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__ContextTerminated); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_4);
+      __pyx_v_ContextTerminated = __pyx_t_4;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+      /* "zmq/core/checkrc.pxd":18
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)             # <<<<<<<<<<<<<<
+ *         else:
+ *             from zmq.error import ZMQError
+ */
+      __pyx_t_3 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_3);
+      __pyx_t_3 = 0;
+      __pyx_t_3 = PyObject_Call(__pyx_v_ContextTerminated, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+      default:
+
+      /* "zmq/core/checkrc.pxd":20
+ *             raise ContextTerminated(errno)
+ *         else:
+ *             from zmq.error import ZMQError             # <<<<<<<<<<<<<<
+ *             raise ZMQError(errno)
+ *         # return -1
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQError));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__ZMQError));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQError));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_1), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__ZMQError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_ZMQError = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":21
+ *         else:
+ *             from zmq.error import ZMQError
+ *             raise ZMQError(errno)             # <<<<<<<<<<<<<<
+ *         # return -1
+ *     return 0
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_ZMQError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+    }
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/checkrc.pxd":23
+ *             raise ZMQError(errno)
+ *         # return -1
+ *     return 0             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = 0;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.checkrc._check_rc", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_Again);
+  __Pyx_XDECREF(__pyx_v_ContextTerminated);
+  __Pyx_XDECREF(__pyx_v_ZMQError);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":104
+ * # Datetime C API initialization function.
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():             # <<<<<<<<<<<<<<
+ *     PyDateTime_IMPORT
+ * 
+ */
+
+static CYTHON_INLINE void __pyx_f_7cpython_8datetime_import_datetime(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("import_datetime", 0);
+
+  /* "cpython/datetime.pxd":105
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():
+ *     PyDateTime_IMPORT             # <<<<<<<<<<<<<<
+ * 
+ * # Create date object using DateTime CAPI factory function.
+ */
+  PyDateTime_IMPORT;
+
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "cpython/datetime.pxd":109
+ * # Create date object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_date_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("date_new", 0);
+
+  /* "cpython/datetime.pxd":110
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create time object using DateTime CAPI factory function
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Date_FromDate(__pyx_v_year, __pyx_v_month, __pyx_v_day, PyDateTimeAPI->DateType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.date_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":114
+ * # Create time object using DateTime CAPI factory function
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_new(int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("time_new", 0);
+
+  /* "cpython/datetime.pxd":115
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create datetime object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Time_FromTime(__pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->TimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.time_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":119
+ * # Create datetime object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day, int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("datetime_new", 0);
+
+  /* "cpython/datetime.pxd":120
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create timedelta object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->DateTime_FromDateAndTime(__pyx_v_year, __pyx_v_month, __pyx_v_day, __pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->DateTimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.datetime_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":124
+ * # Create timedelta object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_timedelta_new(int __pyx_v_days, int __pyx_v_seconds, int __pyx_v_useconds) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("timedelta_new", 0);
+
+  /* "cpython/datetime.pxd":125
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)             # <<<<<<<<<<<<<<
+ * 
+ * # More recognizable getters for date/time/datetime/timedelta.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Delta_FromDelta(__pyx_v_days, __pyx_v_seconds, __pyx_v_useconds, 1, PyDateTimeAPI->DeltaType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.timedelta_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":133
+ * 
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":134
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_Time *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":135
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":137
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get tzinfo of datetime
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":140
+ * 
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":141
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_DateTime *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":142
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":144
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of date
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":147
+ * 
+ * # Get year of date
+ * cdef inline int date_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_year", 0);
+
+  /* "cpython/datetime.pxd":148
+ * # Get year of date
+ * cdef inline int date_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of date
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":151
+ * 
+ * # Get month of date
+ * cdef inline int date_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_month", 0);
+
+  /* "cpython/datetime.pxd":152
+ * # Get month of date
+ * cdef inline int date_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of date
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":155
+ * 
+ * # Get day of date
+ * cdef inline int date_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_day", 0);
+
+  /* "cpython/datetime.pxd":156
+ * # Get day of date
+ * cdef inline int date_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of datetime
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":159
+ * 
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_year", 0);
+
+  /* "cpython/datetime.pxd":160
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of datetime
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":163
+ * 
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_month", 0);
+
+  /* "cpython/datetime.pxd":164
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of datetime
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":167
+ * 
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_day", 0);
+
+  /* "cpython/datetime.pxd":168
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of time
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":171
+ * 
+ * # Get hour of time
+ * cdef inline int time_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_hour", 0);
+
+  /* "cpython/datetime.pxd":172
+ * # Get hour of time
+ * cdef inline int time_hour(object o):
+ *     return PyDateTime_TIME_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":175
+ * 
+ * # Get minute of time
+ * cdef inline int time_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_minute", 0);
+
+  /* "cpython/datetime.pxd":176
+ * # Get minute of time
+ * cdef inline int time_minute(object o):
+ *     return PyDateTime_TIME_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":179
+ * 
+ * # Get second of time
+ * cdef inline int time_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_second", 0);
+
+  /* "cpython/datetime.pxd":180
+ * # Get second of time
+ * cdef inline int time_second(object o):
+ *     return PyDateTime_TIME_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":183
+ * 
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_microsecond", 0);
+
+  /* "cpython/datetime.pxd":184
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of datetime
+ */
+  __pyx_r = PyDateTime_TIME_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":187
+ * 
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_hour", 0);
+
+  /* "cpython/datetime.pxd":188
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):
+ *     return PyDateTime_DATE_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":191
+ * 
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_minute", 0);
+
+  /* "cpython/datetime.pxd":192
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):
+ *     return PyDateTime_DATE_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":195
+ * 
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_second", 0);
+
+  /* "cpython/datetime.pxd":196
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):
+ *     return PyDateTime_DATE_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":199
+ * 
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_microsecond", 0);
+
+  /* "cpython/datetime.pxd":200
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get days of timedelta
+ */
+  __pyx_r = PyDateTime_DATE_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":203
+ * 
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).days
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_days(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_days", 0);
+
+  /* "cpython/datetime.pxd":204
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):
+ *     return (<PyDateTime_Delta*>o).days             # <<<<<<<<<<<<<<
+ * 
+ * # Get seconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->days;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":207
+ * 
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).seconds
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_seconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_seconds", 0);
+
+  /* "cpython/datetime.pxd":208
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):
+ *     return (<PyDateTime_Delta*>o).seconds             # <<<<<<<<<<<<<<
+ * 
+ * # Get microseconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->seconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_microseconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_microseconds", 0);
+
+  /* "cpython/datetime.pxd":212
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):
+ *     return (<PyDateTime_Delta*>o).microseconds             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->microseconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("_device"),
+    __Pyx_DOCSTR(__pyx_k_2), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_n_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 1},
+  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
+  {&__pyx_n_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 1},
+  {&__pyx_n_s__Again, __pyx_k__Again, sizeof(__pyx_k__Again), 0, 0, 1, 1},
+  {&__pyx_n_s__ContextTerminated, __pyx_k__ContextTerminated, sizeof(__pyx_k__ContextTerminated), 0, 0, 1, 1},
+  {&__pyx_n_s__ZMQError, __pyx_k__ZMQError, sizeof(__pyx_k__ZMQError), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s__backend, __pyx_k__backend, sizeof(__pyx_k__backend), 0, 0, 1, 1},
+  {&__pyx_n_s__capture, __pyx_k__capture, sizeof(__pyx_k__capture), 0, 0, 1, 1},
+  {&__pyx_n_s__capture_handle, __pyx_k__capture_handle, sizeof(__pyx_k__capture_handle), 0, 0, 1, 1},
+  {&__pyx_n_s__device, __pyx_k__device, sizeof(__pyx_k__device), 0, 0, 1, 1},
+  {&__pyx_n_s__device_type, __pyx_k__device_type, sizeof(__pyx_k__device_type), 0, 0, 1, 1},
+  {&__pyx_n_s__frontend, __pyx_k__frontend, sizeof(__pyx_k__frontend), 0, 0, 1, 1},
+  {&__pyx_n_s__proxy, __pyx_k__proxy, sizeof(__pyx_k__proxy), 0, 0, 1, 1},
+  {&__pyx_n_s__rc, __pyx_k__rc, sizeof(__pyx_k__rc), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  return 0;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/_device.pyx":34
+ * #-----------------------------------------------------------------------------
+ * 
+ * def device(int device_type, cSocket frontend, cSocket backend=None):             # <<<<<<<<<<<<<<
+ *     """device(device_type, frontend, backend)
+ * 
+ */
+  __pyx_k_tuple_3 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__device_type), ((PyObject *)__pyx_n_s__frontend), ((PyObject *)__pyx_n_s__backend), ((PyObject *)__pyx_n_s__rc)); if (unlikely(!__pyx_k_tuple_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_3);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_3));
+  __pyx_k_codeobj_4 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_3, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_5, __pyx_n_s__device, 34, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/_device.pyx":60
+ *     return rc
+ * 
+ * def proxy(cSocket frontend, cSocket backend, cSocket capture=None):             # <<<<<<<<<<<<<<
+ *     """proxy(frontend, backend, capture)
+ * 
+ */
+  __pyx_k_tuple_7 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__frontend), ((PyObject *)__pyx_n_s__backend), ((PyObject *)__pyx_n_s__capture), ((PyObject *)__pyx_n_s__rc), ((PyObject *)__pyx_n_s__capture_handle)); if (unlikely(!__pyx_k_tuple_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_7);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_7));
+  __pyx_k_codeobj_8 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_7, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_5, __pyx_n_s__proxy, 60, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC init_device(void); /*proto*/
+PyMODINIT_FUNC init_device(void)
+#else
+PyMODINIT_FUNC PyInit__device(void); /*proto*/
+PyMODINIT_FUNC PyInit__device(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__device(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("_device"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_2), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core._device")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core._device", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core___device) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  /*--- Type import code ---*/
+  __pyx_ptype_3zmq_4core_7context_Context = __Pyx_ImportType("zmq.core.context", "Context", sizeof(struct __pyx_obj_3zmq_4core_7context_Context), 1); if (unlikely(!__pyx_ptype_3zmq_4core_7context_Context)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_vtabptr_3zmq_4core_7context_Context = (struct __pyx_vtabstruct_3zmq_4core_7context_Context*)__Pyx_GetVtable(__pyx_ptype_3zmq_4core_7context_Context->tp_dict); if (unlikely(!__pyx_vtabptr_3zmq_4core_7context_Context)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_3zmq_4core_6socket_Socket = __Pyx_ImportType("zmq.core.socket", "Socket", sizeof(struct __pyx_obj_3zmq_4core_6socket_Socket), 1); if (unlikely(!__pyx_ptype_3zmq_4core_6socket_Socket)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_vtabptr_3zmq_4core_6socket_Socket = (struct __pyx_vtabstruct_3zmq_4core_6socket_Socket*)__Pyx_GetVtable(__pyx_ptype_3zmq_4core_6socket_Socket->tp_dict); if (unlikely(!__pyx_vtabptr_3zmq_4core_6socket_Socket)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
+  #if CYTHON_COMPILING_IN_PYPY
+  sizeof(PyTypeObject),
+  #else
+  sizeof(PyHeapTypeObject),
+  #endif
+  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), 0); if (unlikely(!__pyx_ptype_7cpython_4bool_bool)) {__pyx_filename = __pyx_f[6]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), 0); if (unlikely(!__pyx_ptype_7cpython_7complex_complex)) {__pyx_filename = __pyx_f[7]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_date = __Pyx_ImportType("datetime", "date", sizeof(PyDateTime_Date), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_date)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_time = __Pyx_ImportType("datetime", "time", sizeof(PyDateTime_Time), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_time)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_datetime = __Pyx_ImportType("datetime", "datetime", sizeof(PyDateTime_DateTime), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_datetime)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_timedelta = __Pyx_ImportType("datetime", "timedelta", sizeof(PyDateTime_Delta), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_timedelta)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_tzinfo = __Pyx_ImportType("datetime", "tzinfo", sizeof(PyDateTime_TZInfo), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_tzinfo)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/_device.pyx":34
+ * #-----------------------------------------------------------------------------
+ * 
+ * def device(int device_type, cSocket frontend, cSocket backend=None):             # <<<<<<<<<<<<<<
+ *     """device(device_type, frontend, backend)
+ * 
+ */
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3zmq_4core_7_device_1device, NULL, __pyx_n_s_6); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__device, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/_device.pyx":60
+ *     return rc
+ * 
+ * def proxy(cSocket frontend, cSocket backend, cSocket capture=None):             # <<<<<<<<<<<<<<
+ *     """proxy(frontend, backend, capture)
+ * 
+ */
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3zmq_4core_7_device_3proxy, NULL, __pyx_n_s_6); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__proxy, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "zmq/core/_device.pyx":85
+ *     return rc
+ * 
+ * __all__ = ['device', 'proxy']             # <<<<<<<<<<<<<<
+ * 
+ */
+  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__device));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__device));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__device));
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__proxy));
+  PyList_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_n_s__proxy));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__proxy));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+
+  /* "zmq/core/_device.pyx":1
+ * """Python binding for 0MQ device function."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+
+  /* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core._device", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core._device");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
+}
+
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name,
+    PyObject* kw_name)
+{
+    PyErr_Format(PyExc_TypeError,
+        #if PY_MAJOR_VERSION >= 3
+        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
+        #else
+        "%s() got multiple values for keyword argument '%s'", func_name,
+        PyString_AsString(kw_name));
+        #endif
+}
+
+static int __Pyx_ParseOptionalKeywords(
+    PyObject *kwds,
+    PyObject **argnames[],
+    PyObject *kwds2,
+    PyObject *values[],
+    Py_ssize_t num_pos_args,
+    const char* function_name)
+{
+    PyObject *key = 0, *value = 0;
+    Py_ssize_t pos = 0;
+    PyObject*** name;
+    PyObject*** first_kw_arg = argnames + num_pos_args;
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
+        name = first_kw_arg;
+        while (*name && (**name != key)) name++;
+        if (*name) {
+            values[name-argnames] = value;
+            continue;
+        }
+        name = first_kw_arg;
+        #if PY_MAJOR_VERSION < 3
+        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
+            while (*name) {
+                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
+                        && _PyString_Eq(**name, key)) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    if ((**argname == key) || (
+                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
+                             && _PyString_Eq(**argname, key))) {
+                        goto arg_passed_twice;
+                    }
+                    argname++;
+                }
+            }
+        } else
+        #endif
+        if (likely(PyUnicode_Check(key))) {
+            while (*name) {
+                int cmp = (**name == key) ? 0 :
+                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
+                #endif
+                    PyUnicode_Compare(**name, key);
+                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                if (cmp == 0) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    int cmp = (**argname == key) ? 0 :
+                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
+                    #endif
+                        PyUnicode_Compare(**argname, key);
+                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                    if (cmp == 0) goto arg_passed_twice;
+                    argname++;
+                }
+            }
+        } else
+            goto invalid_keyword_type;
+        if (kwds2) {
+            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+        } else {
+            goto invalid_keyword;
+        }
+    }
+    return 0;
+arg_passed_twice:
+    __Pyx_RaiseDoubleKeywordsError(function_name, key);
+    goto bad;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%s() keywords must be strings", function_name);
+    goto bad;
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%s() got an unexpected keyword argument '%s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+bad:
+    return -1;
+}
+
+static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
+    const char *name, int exact)
+{
+    if (!type) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (none_allowed && obj == Py_None) return 1;
+    else if (exact) {
+        if (Py_TYPE(obj) == type) return 1;
+    }
+    else {
+        if (PyObject_TypeCheck(obj, type)) return 1;
+    }
+    PyErr_Format(PyExc_TypeError,
+        "Argument '%s' has incorrect type (expected %s, got %s)",
+        name, type->tp_name, Py_TYPE(obj)->tp_name);
+    return 0;
+}
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON
+    result = PyDict_GetItem(__pyx_d, name);
+    if (result) {
+        Py_INCREF(result);
+    } else {
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    if (!result) {
+        PyErr_Clear();
+#endif
+        result = __Pyx_GetBuiltinName(name);
+    }
+    return result;
+}
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_Restore(type, value, tb);
+#endif
+}
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(type, value, tb);
+#endif
+}
+
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
+    Py_XINCREF(type);
+    if (!value || value == Py_None)
+        value = NULL;
+    else
+        Py_INCREF(value);
+    if (!tb || tb == Py_None)
+        tb = NULL;
+    else {
+        Py_INCREF(tb);
+        if (!PyTraceBack_Check(tb)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: arg 3 must be a traceback or None");
+            goto raise_error;
+        }
+    }
+    #if PY_VERSION_HEX < 0x02050000
+    if (PyClass_Check(type)) {
+    #else
+    if (PyType_Check(type)) {
+    #endif
+#if CYTHON_COMPILING_IN_PYPY
+        if (!value) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+#endif
+        PyErr_NormalizeException(&type, &value, &tb);
+    } else {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        value = type;
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyInstance_Check(type)) {
+            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+            Py_INCREF(type);
+        } else {
+            type = 0;
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception must be an old-style class or instance");
+            goto raise_error;
+        }
+        #else
+        type = (PyObject*) Py_TYPE(type);
+        Py_INCREF(type);
+        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception class must be a subclass of BaseException");
+            goto raise_error;
+        }
+        #endif
+    }
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+#else /* Python 3+ */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    PyObject* owned_instance = NULL;
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
+    }
+    if (value == Py_None)
+        value = 0;
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (PyExceptionClass_Check(type)) {
+        PyObject *args;
+        if (!value)
+            args = PyTuple_New(0);
+        else if (PyTuple_Check(value)) {
+            Py_INCREF(value);
+            args = value;
+        } else
+            args = PyTuple_Pack(1, value);
+        if (!args)
+            goto bad;
+        owned_instance = PyEval_CallObject(type, args);
+        Py_DECREF(args);
+        if (!owned_instance)
+            goto bad;
+        value = owned_instance;
+        if (!PyExceptionInstance_Check(value)) {
+            PyErr_Format(PyExc_TypeError,
+                         "calling %R should have returned an instance of "
+                         "BaseException, not %R",
+                         type, Py_TYPE(value));
+            goto bad;
+        }
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
+    }
+#if PY_VERSION_HEX >= 0x03030000
+    if (cause) {
+#else
+    if (cause && cause != Py_None) {
+#endif
+        PyObject *fixed_cause;
+        if (cause == Py_None) {
+            fixed_cause = NULL;
+        } else if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        } else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+    PyErr_SetObject(type, value);
+    if (tb) {
+        PyThreadState *tstate = PyThreadState_GET();
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
+    }
+bad:
+    Py_XDECREF(owned_instance);
+    return;
+}
+#endif
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_VERSION_HEX < 0x03030000
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    #if PY_VERSION_HEX >= 0x02050000
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if (strchr(__Pyx_MODULE_NAME, '.')) {
+                #if PY_VERSION_HEX < 0x03030000
+                PyObject *py_level = PyInt_FromLong(1);
+                if (!py_level)
+                    goto bad;
+                module = PyObject_CallFunctionObjArgs(py_import,
+                    name, global_dict, empty_dict, list, py_level, NULL);
+                Py_DECREF(py_level);
+                #else
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                #endif
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0; /* try absolute import on failure */
+        }
+        #endif
+        if (!module) {
+            #if PY_VERSION_HEX < 0x03030000
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+    #else
+    if (level>0) {
+        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
+        goto bad;
+    }
+    module = PyObject_CallFunctionObjArgs(py_import,
+        name, global_dict, empty_dict, list, NULL);
+    #endif
+bad:
+    #if PY_VERSION_HEX < 0x03030000
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+#ifndef __PYX_HAVE_RT_ImportModule
+#define __PYX_HAVE_RT_ImportModule
+static PyObject *__Pyx_ImportModule(const char *name) {
+    PyObject *py_name = 0;
+    PyObject *py_module = 0;
+    py_name = __Pyx_PyIdentifier_FromString(name);
+    if (!py_name)
+        goto bad;
+    py_module = PyImport_Import(py_name);
+    Py_DECREF(py_name);
+    return py_module;
+bad:
+    Py_XDECREF(py_name);
+    return 0;
+}
+#endif
+
+#ifndef __PYX_HAVE_RT_ImportType
+#define __PYX_HAVE_RT_ImportType
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
+    size_t size, int strict)
+{
+    PyObject *py_module = 0;
+    PyObject *result = 0;
+    PyObject *py_name = 0;
+    char warning[200];
+    Py_ssize_t basicsize;
+#ifdef Py_LIMITED_API
+    PyObject *py_basicsize;
+#endif
+    py_module = __Pyx_ImportModule(module_name);
+    if (!py_module)
+        goto bad;
+    py_name = __Pyx_PyIdentifier_FromString(class_name);
+    if (!py_name)
+        goto bad;
+    result = PyObject_GetAttr(py_module, py_name);
+    Py_DECREF(py_name);
+    py_name = 0;
+    Py_DECREF(py_module);
+    py_module = 0;
+    if (!result)
+        goto bad;
+    if (!PyType_Check(result)) {
+        PyErr_Format(PyExc_TypeError,
+            "%s.%s is not a type object",
+            module_name, class_name);
+        goto bad;
+    }
+#ifndef Py_LIMITED_API
+    basicsize = ((PyTypeObject *)result)->tp_basicsize;
+#else
+    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
+    if (!py_basicsize)
+        goto bad;
+    basicsize = PyLong_AsSsize_t(py_basicsize);
+    Py_DECREF(py_basicsize);
+    py_basicsize = 0;
+    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
+#endif
+    if (!strict && (size_t)basicsize > size) {
+        PyOS_snprintf(warning, sizeof(warning),
+            "%s.%s size changed, may indicate binary incompatibility",
+            module_name, class_name);
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyErr_Warn(NULL, warning) < 0) goto bad;
+        #else
+        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
+        #endif
+    }
+    else if ((size_t)basicsize != size) {
+        PyErr_Format(PyExc_ValueError,
+            "%s.%s has the wrong size, try recompiling",
+            module_name, class_name);
+        goto bad;
+    }
+    return (PyTypeObject *)result;
+bad:
+    Py_XDECREF(py_module);
+    Py_XDECREF(result);
+    return NULL;
+}
+#endif
+
+static void* __Pyx_GetVtable(PyObject *dict) {
+    void* ptr;
+    PyObject *ob = PyMapping_GetItemString(dict, (char *)"__pyx_vtable__");
+    if (!ob)
+        goto bad;
+#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
+    ptr = PyCapsule_GetPointer(ob, 0);
+#else
+    ptr = PyCObject_AsVoidPtr(ob);
+#endif
+    if (!ptr && !PyErr_Occurred())
+        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
+    Py_DECREF(ob);
+    return ptr;
+bad:
+    Py_XDECREF(ob);
+    return NULL;
+}
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
--- /dev/null
+++ pyzmq-13.1.0/zmq/core/context.c
@@ -0,0 +1,5576 @@
+/* Generated by Cython 0.19 on Tue Apr 30 17:00:27 2013 */
+
+#define PY_SSIZE_T_CLEAN
+#ifndef CYTHON_USE_PYLONG_INTERNALS
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#else
+#include "pyconfig.h"
+#ifdef PYLONG_BITS_IN_DIGIT
+#define CYTHON_USE_PYLONG_INTERNALS 1
+#else
+#define CYTHON_USE_PYLONG_INTERNALS 0
+#endif
+#endif
+#endif
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02040000
+    #error Cython requires Python 2.4+.
+#else
+#include <stddef.h> /* For offsetof */
+#ifndef offsetof
+#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+#define CYTHON_COMPILING_IN_PYPY 1
+#define CYTHON_COMPILING_IN_CPYTHON 0
+#else
+#define CYTHON_COMPILING_IN_PYPY 0
+#define CYTHON_COMPILING_IN_CPYTHON 1
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define CYTHON_FORMAT_SSIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
+  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
+                                (PyErr_Format(PyExc_TypeError, \
+                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
+                                 (PyObject*)0))
+  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
+                                  !PyComplex_Check(o))
+  #define PyIndex_Check __Pyx_PyIndex_Check
+  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
+  #define __PYX_BUILD_PY_SSIZE_T "i"
+#else
+  #define __PYX_BUILD_PY_SSIZE_T "n"
+  #define CYTHON_FORMAT_SSIZE_T "z"
+  #define __Pyx_PyIndex_Check PyIndex_Check
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+  typedef struct {
+     void *buf;
+     PyObject *obj;
+     Py_ssize_t len;
+     Py_ssize_t itemsize;
+     int readonly;
+     int ndim;
+     char *format;
+     Py_ssize_t *shape;
+     Py_ssize_t *strides;
+     Py_ssize_t *suboffsets;
+     void *internal;
+  } Py_buffer;
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
+  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
+  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
+  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
+  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PyBytesObject                PyStringObject
+  #define PyBytes_Type                 PyString_Type
+  #define PyBytes_Check                PyString_Check
+  #define PyBytes_CheckExact           PyString_CheckExact
+  #define PyBytes_FromString           PyString_FromString
+  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
+  #define PyBytes_FromFormat           PyString_FromFormat
+  #define PyBytes_DecodeEscape         PyString_DecodeEscape
+  #define PyBytes_AsString             PyString_AsString
+  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
+  #define PyBytes_Size                 PyString_Size
+  #define PyBytes_AS_STRING            PyString_AS_STRING
+  #define PyBytes_GET_SIZE             PyString_GET_SIZE
+  #define PyBytes_Repr                 PyString_Repr
+  #define PyBytes_Concat               PyString_Concat
+  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
+                                         PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
+  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_VERSION_HEX < 0x03020000
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
+  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
+  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
+#else
+  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
+  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
+  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
+        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
+        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
+            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
+#endif
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
+   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
+   a quiet NaN. */
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#if defined(WIN32) || defined(MS_WINDOWS)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#define __PYX_HAVE__zmq__core__context
+#define __PYX_HAVE_API__zmq__core__context
+#include "string.h"
+#include "stdlib.h"
+#include "zmq_compat.h"
+#include "zmq.h"
+#include "zmq_utils.h"
+#include "getpid_compat.h"
+#include "errno.h"
+#include "stdio.h"
+#include "pythread.h"
+#include "datetime.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#ifdef PYREX_WITHOUT_ASSERTIONS
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
+#define __PYX_DEFAULT_STRING_ENCODING ""
+#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
+#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
+#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
+#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
+#if PY_MAJOR_VERSION < 3
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
+{
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return u_end - u - 1;
+}
+#else
+#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
+#endif
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (ascii_chars_u == NULL) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+    }
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params() {
+    PyObject* sys = NULL;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (sys == NULL) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    if (default_encoding == NULL) goto bad;
+    default_encoding_c = PyBytes_AS_STRING(default_encoding);
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(sys);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(sys);
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+#ifdef __GNUC__
+  /* Test for GCC > 2.95 */
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
+    #define likely(x)   __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+  #else /* __GNUC__ > 2 ... */
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+  #endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+
+static PyObject *__pyx_m;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "context.pyx",
+  "checkrc.pxd",
+  "datetime.pxd",
+  "type.pxd",
+  "bool.pxd",
+  "complex.pxd",
+};
+
+/*--- Type declarations ---*/
+struct __pyx_obj_3zmq_4core_7context_Context;
+
+/* "zmq/core/context.pxd":26
+ * #-----------------------------------------------------------------------------
+ * 
+ * cdef class Context:             # <<<<<<<<<<<<<<
+ *     """Manage the lifecycle of a 0MQ context."""
+ * 
+ */
+struct __pyx_obj_3zmq_4core_7context_Context {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3zmq_4core_7context_Context *__pyx_vtab;
+  PyObject *__weakref__;
+  void *handle;
+  void **_sockets;
+  size_t _n_sockets;
+  size_t _max_sockets;
+  int _pid;
+  PyObject *closed;
+};
+
+
+
+/* "zmq/core/context.pyx":42
+ * _instance = None
+ * 
+ * cdef class Context:             # <<<<<<<<<<<<<<
+ *     """Context(io_threads=1)
+ * 
+ */
+
+struct __pyx_vtabstruct_3zmq_4core_7context_Context {
+  void (*_add_socket)(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+  void (*_remove_socket)(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+};
+static struct __pyx_vtabstruct_3zmq_4core_7context_Context *__pyx_vtabptr_3zmq_4core_7context_Context;
+static CYTHON_INLINE void __pyx_f_3zmq_4core_7context_7Context__add_socket(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+static CYTHON_INLINE void __pyx_f_3zmq_4core_7context_7Context__remove_socket(struct __pyx_obj_3zmq_4core_7context_Context *, void *);
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          if (acquire_gil) { \
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+              PyGILState_Release(__pyx_gilstate_save); \
+          } else { \
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext() \
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/
+
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/
+
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
+    const char* function_name); /*proto*/
+
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/
+
+static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name); /*proto*/
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/
+
+#ifndef __PYX_FORCE_INIT_THREADS
+  #define __PYX_FORCE_INIT_THREADS 0
+#endif
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);
+
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static void __Pyx_WriteUnraisable(const char *name, int clineno,
+                                  int lineno, const char *filename); /*proto*/
+
+static int __Pyx_check_binary_version(void);
+
+static int __Pyx_SetVtable(PyObject *dict, void *vtable); /*proto*/
+
+#if !defined(__Pyx_PyIdentifier_FromString)
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
+#else
+  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
+#endif
+#endif
+
+static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
+
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/
+
+typedef struct {
+    int code_line;
+    PyCodeObject* code_object;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+
+/* Module declarations from 'libc.string' */
+
+/* Module declarations from 'libc.stdlib' */
+
+/* Module declarations from 'zmq.core.libzmq' */
+
+/* Module declarations from 'libc.errno' */
+
+/* Module declarations from 'cpython.version' */
+
+/* Module declarations from 'cpython.ref' */
+
+/* Module declarations from 'cpython.exc' */
+
+/* Module declarations from 'cpython.module' */
+
+/* Module declarations from 'cpython.mem' */
+
+/* Module declarations from 'cpython.tuple' */
+
+/* Module declarations from 'cpython.list' */
+
+/* Module declarations from 'libc.stdio' */
+
+/* Module declarations from 'cpython.object' */
+
+/* Module declarations from 'cpython.sequence' */
+
+/* Module declarations from 'cpython.mapping' */
+
+/* Module declarations from 'cpython.iterator' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.type' */
+static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;
+
+/* Module declarations from 'cpython.number' */
+
+/* Module declarations from 'cpython.int' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.bool' */
+static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;
+
+/* Module declarations from 'cpython.long' */
+
+/* Module declarations from 'cpython.float' */
+
+/* Module declarations from '__builtin__' */
+
+/* Module declarations from 'cpython.complex' */
+static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;
+
+/* Module declarations from 'cpython.string' */
+
+/* Module declarations from 'cpython.unicode' */
+
+/* Module declarations from 'cpython.dict' */
+
+/* Module declarations from 'cpython.instance' */
+
+/* Module declarations from 'cpython.function' */
+
+/* Module declarations from 'cpython.method' */
+
+/* Module declarations from 'cpython.weakref' */
+
+/* Module declarations from 'cpython.getargs' */
+
+/* Module declarations from 'cpython.pythread' */
+
+/* Module declarations from 'cpython.pystate' */
+
+/* Module declarations from 'cpython.cobject' */
+
+/* Module declarations from 'cpython.oldbuffer' */
+
+/* Module declarations from 'cpython.set' */
+
+/* Module declarations from 'cpython.buffer' */
+
+/* Module declarations from 'cpython.bytes' */
+
+/* Module declarations from 'cpython.pycapsule' */
+
+/* Module declarations from 'datetime' */
+
+/* Module declarations from 'cpython.datetime' */
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_date = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_time = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_datetime = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_timedelta = 0;
+static PyTypeObject *__pyx_ptype_7cpython_8datetime_tzinfo = 0;
+
+/* Module declarations from 'cpython' */
+
+/* Module declarations from 'zmq.core.checkrc' */
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int); /*proto*/
+
+/* Module declarations from 'zmq.core.context' */
+static PyTypeObject *__pyx_ptype_3zmq_4core_7context_Context = 0;
+#define __Pyx_MODULE_NAME "zmq.core.context"
+int __pyx_module_is_main_zmq__core__context = 0;
+
+/* Implementation of 'zmq.core.context' */
+static PyObject *__pyx_builtin_property;
+static PyObject *__pyx_builtin_MemoryError;
+static PyObject *__pyx_builtin_range;
+static PyObject *__pyx_builtin_RuntimeError;
+static PyObject *__pyx_builtin_TypeError;
+static int __pyx_pf_3zmq_4core_7context_7Context___cinit__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, int __pyx_v_io_threads, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static int __pyx_pf_3zmq_4core_7context_7Context_2__init__(CYTHON_UNUSED struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_io_threads); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_4__del__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self); /* proto */
+static void __pyx_pf_3zmq_4core_7context_7Context_6__dealloc__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_8_handle(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_10term(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_12set(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, int __pyx_v_option, PyObject *__pyx_v_optval); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_14get(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, int __pyx_v_option); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_16destroy(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, PyObject *__pyx_v_linger); /* proto */
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_6closed___get__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self); /* proto */
+static int __pyx_pf_3zmq_4core_7context_7Context_6closed_2__set__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
+static int __pyx_pf_3zmq_4core_7context_7Context_6closed_4__del__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self); /* proto */
+static PyObject *__pyx_tp_new_3zmq_4core_7context_Context(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static char __pyx_k_1[] = "Could not allocate _sockets array";
+static char __pyx_k_3[] = "Could not reallocate _sockets array";
+static char __pyx_k_5[] = "Context has been destroyed";
+static char __pyx_k_7[] = "expected int, got: %r";
+static char __pyx_k_9[] = "zmq.error";
+static char __pyx_k_10[] = "0MQ Context class.";
+static char __pyx_k__term[] = "term";
+static char __pyx_k__Again[] = "Again";
+static char __pyx_k__range[] = "range";
+static char __pyx_k__linger[] = "linger";
+static char __pyx_k__option[] = "option";
+static char __pyx_k__optval[] = "optval";
+static char __pyx_k__Context[] = "Context";
+static char __pyx_k____all__[] = "__all__";
+static char __pyx_k___handle[] = "_handle";
+static char __pyx_k__ZMQError[] = "ZMQError";
+static char __pyx_k____main__[] = "__main__";
+static char __pyx_k____test__[] = "__test__";
+static char __pyx_k__property[] = "property";
+static char __pyx_k__TypeError[] = "TypeError";
+static char __pyx_k___instance[] = "_instance";
+static char __pyx_k____import__[] = "__import__";
+static char __pyx_k__io_threads[] = "io_threads";
+static char __pyx_k__MemoryError[] = "MemoryError";
+static char __pyx_k__RuntimeError[] = "RuntimeError";
+static char __pyx_k__ContextTerminated[] = "ContextTerminated";
+static PyObject *__pyx_kp_s_1;
+static PyObject *__pyx_kp_s_3;
+static PyObject *__pyx_kp_s_5;
+static PyObject *__pyx_kp_s_7;
+static PyObject *__pyx_n_s_9;
+static PyObject *__pyx_n_s__Again;
+static PyObject *__pyx_n_s__Context;
+static PyObject *__pyx_n_s__ContextTerminated;
+static PyObject *__pyx_n_s__MemoryError;
+static PyObject *__pyx_n_s__RuntimeError;
+static PyObject *__pyx_n_s__TypeError;
+static PyObject *__pyx_n_s__ZMQError;
+static PyObject *__pyx_n_s____all__;
+static PyObject *__pyx_n_s____import__;
+static PyObject *__pyx_n_s____main__;
+static PyObject *__pyx_n_s____test__;
+static PyObject *__pyx_n_s___handle;
+static PyObject *__pyx_n_s___instance;
+static PyObject *__pyx_n_s__io_threads;
+static PyObject *__pyx_n_s__linger;
+static PyObject *__pyx_n_s__option;
+static PyObject *__pyx_n_s__optval;
+static PyObject *__pyx_n_s__property;
+static PyObject *__pyx_n_s__range;
+static PyObject *__pyx_n_s__term;
+static PyObject *__pyx_int_1;
+static PyObject *__pyx_k_tuple_2;
+static PyObject *__pyx_k_tuple_4;
+static PyObject *__pyx_k_tuple_6;
+static PyObject *__pyx_k_tuple_8;
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7context_7Context_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3zmq_4core_7context_7Context_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_v_io_threads;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__io_threads,0};
+    PyObject* values[1] = {0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__io_threads);
+          if (value) { values[0] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    if (values[0]) {
+      __pyx_v_io_threads = __Pyx_PyInt_AsInt(values[0]); if (unlikely((__pyx_v_io_threads == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    } else {
+      __pyx_v_io_threads = ((int)1);
+    }
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("zmq.core.context.Context.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context___cinit__(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self), __pyx_v_io_threads, __pyx_v_kwargs);
+  __Pyx_XDECREF(__pyx_v_kwargs);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/context.pyx":53
+ *     """
+ * 
+ *     def __cinit__(self, int io_threads = 1, **kwargs):             # <<<<<<<<<<<<<<
+ *         self.handle = NULL
+ *         self._sockets = NULL
+ */
+
+static int __pyx_pf_3zmq_4core_7context_7Context___cinit__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, int __pyx_v_io_threads, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
+  int __pyx_v_rc;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__cinit__", 0);
+
+  /* "zmq/core/context.pyx":54
+ * 
+ *     def __cinit__(self, int io_threads = 1, **kwargs):
+ *         self.handle = NULL             # <<<<<<<<<<<<<<
+ *         self._sockets = NULL
+ * 
+ */
+  __pyx_v_self->handle = NULL;
+
+  /* "zmq/core/context.pyx":55
+ *     def __cinit__(self, int io_threads = 1, **kwargs):
+ *         self.handle = NULL
+ *         self._sockets = NULL             # <<<<<<<<<<<<<<
+ * 
+ *         if ZMQ_VERSION_MAJOR >= 3:
+ */
+  __pyx_v_self->_sockets = NULL;
+
+  /* "zmq/core/context.pyx":57
+ *         self._sockets = NULL
+ * 
+ *         if ZMQ_VERSION_MAJOR >= 3:             # <<<<<<<<<<<<<<
+ *             self.handle = zmq_ctx_new()
+ *         else:
+ */
+  __pyx_t_1 = (ZMQ_VERSION_MAJOR >= 3);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":58
+ * 
+ *         if ZMQ_VERSION_MAJOR >= 3:
+ *             self.handle = zmq_ctx_new()             # <<<<<<<<<<<<<<
+ *         else:
+ *             self.handle = zmq_init(io_threads)
+ */
+    __pyx_v_self->handle = zmq_ctx_new();
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "zmq/core/context.pyx":60
+ *             self.handle = zmq_ctx_new()
+ *         else:
+ *             self.handle = zmq_init(io_threads)             # <<<<<<<<<<<<<<
+ * 
+ *         if self.handle == NULL:
+ */
+    __pyx_v_self->handle = zmq_init(__pyx_v_io_threads);
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/context.pyx":62
+ *             self.handle = zmq_init(io_threads)
+ * 
+ *         if self.handle == NULL:             # <<<<<<<<<<<<<<
+ *             raise ZMQError()
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_self->handle == NULL);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":63
+ * 
+ *         if self.handle == NULL:
+ *             raise ZMQError()             # <<<<<<<<<<<<<<
+ * 
+ *         cdef int rc = 0
+ */
+    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/context.pyx":65
+ *             raise ZMQError()
+ * 
+ *         cdef int rc = 0             # <<<<<<<<<<<<<<
+ *         if ZMQ_VERSION_MAJOR >= 3:
+ *             rc = zmq_ctx_set(self.handle, ZMQ_IO_THREADS, io_threads)
+ */
+  __pyx_v_rc = 0;
+
+  /* "zmq/core/context.pyx":66
+ * 
+ *         cdef int rc = 0
+ *         if ZMQ_VERSION_MAJOR >= 3:             # <<<<<<<<<<<<<<
+ *             rc = zmq_ctx_set(self.handle, ZMQ_IO_THREADS, io_threads)
+ *             _check_rc(rc)
+ */
+  __pyx_t_1 = (ZMQ_VERSION_MAJOR >= 3);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":67
+ *         cdef int rc = 0
+ *         if ZMQ_VERSION_MAJOR >= 3:
+ *             rc = zmq_ctx_set(self.handle, ZMQ_IO_THREADS, io_threads)             # <<<<<<<<<<<<<<
+ *             _check_rc(rc)
+ * 
+ */
+    __pyx_v_rc = zmq_ctx_set(__pyx_v_self->handle, ZMQ_IO_THREADS, __pyx_v_io_threads);
+
+    /* "zmq/core/context.pyx":68
+ *         if ZMQ_VERSION_MAJOR >= 3:
+ *             rc = zmq_ctx_set(self.handle, ZMQ_IO_THREADS, io_threads)
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *         self.closed = False
+ */
+    __pyx_t_4 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
+
+  /* "zmq/core/context.pyx":70
+ *             _check_rc(rc)
+ * 
+ *         self.closed = False             # <<<<<<<<<<<<<<
+ *         self._n_sockets = 0
+ *         self._max_sockets = 32
+ */
+  __pyx_t_3 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  __Pyx_GOTREF(__pyx_v_self->closed);
+  __Pyx_DECREF(__pyx_v_self->closed);
+  __pyx_v_self->closed = __pyx_t_3;
+  __pyx_t_3 = 0;
+
+  /* "zmq/core/context.pyx":71
+ * 
+ *         self.closed = False
+ *         self._n_sockets = 0             # <<<<<<<<<<<<<<
+ *         self._max_sockets = 32
+ * 
+ */
+  __pyx_v_self->_n_sockets = 0;
+
+  /* "zmq/core/context.pyx":72
+ *         self.closed = False
+ *         self._n_sockets = 0
+ *         self._max_sockets = 32             # <<<<<<<<<<<<<<
+ * 
+ *         self._sockets = <void **>malloc(self._max_sockets*sizeof(void *))
+ */
+  __pyx_v_self->_max_sockets = 32;
+
+  /* "zmq/core/context.pyx":74
+ *         self._max_sockets = 32
+ * 
+ *         self._sockets = <void **>malloc(self._max_sockets*sizeof(void *))             # <<<<<<<<<<<<<<
+ *         if self._sockets == NULL:
+ *             raise MemoryError("Could not allocate _sockets array")
+ */
+  __pyx_v_self->_sockets = ((void **)malloc((__pyx_v_self->_max_sockets * (sizeof(void *)))));
+
+  /* "zmq/core/context.pyx":75
+ * 
+ *         self._sockets = <void **>malloc(self._max_sockets*sizeof(void *))
+ *         if self._sockets == NULL:             # <<<<<<<<<<<<<<
+ *             raise MemoryError("Could not allocate _sockets array")
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_self->_sockets == NULL);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":76
+ *         self._sockets = <void **>malloc(self._max_sockets*sizeof(void *))
+ *         if self._sockets == NULL:
+ *             raise MemoryError("Could not allocate _sockets array")             # <<<<<<<<<<<<<<
+ * 
+ *         self._pid = getpid()
+ */
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_MemoryError, ((PyObject *)__pyx_k_tuple_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "zmq/core/context.pyx":78
+ *             raise MemoryError("Could not allocate _sockets array")
+ * 
+ *         self._pid = getpid()             # <<<<<<<<<<<<<<
+ * 
+ *     def __init__(self, io_threads=1):
+ */
+  __pyx_v_self->_pid = getpid();
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.context.Context.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7context_7Context_3__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3zmq_4core_7context_7Context_3__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  CYTHON_UNUSED PyObject *__pyx_v_io_threads = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__io_threads,0};
+    PyObject* values[1] = {0};
+    values[0] = ((PyObject *)__pyx_int_1);
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__io_threads);
+          if (value) { values[0] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_io_threads = values[0];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.context.Context.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_2__init__(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self), __pyx_v_io_threads);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/context.pyx":80
+ *         self._pid = getpid()
+ * 
+ *     def __init__(self, io_threads=1):             # <<<<<<<<<<<<<<
+ *         # no-op
+ *         pass
+ */
+
+static int __pyx_pf_3zmq_4core_7context_7Context_2__init__(CYTHON_UNUSED struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_io_threads) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__", 0);
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_5__del__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_7context_7Context_4__del__[] = "deleting a Context should terminate it, without trying non-threadsafe destroy";
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_5__del__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_4__del__(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/context.pyx":85
+ * 
+ * 
+ *     def __del__(self):             # <<<<<<<<<<<<<<
+ *         """deleting a Context should terminate it, without trying non-threadsafe destroy"""
+ *         self.term()
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_4__del__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__del__", 0);
+
+  /* "zmq/core/context.pyx":87
+ *     def __del__(self):
+ *         """deleting a Context should terminate it, without trying non-threadsafe destroy"""
+ *         self.term()             # <<<<<<<<<<<<<<
+ * 
+ *     def __dealloc__(self):
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s__term); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.context.Context.__del__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static void __pyx_pw_3zmq_4core_7context_7Context_7__dealloc__(PyObject *__pyx_v_self); /*proto*/
+static void __pyx_pw_3zmq_4core_7context_7Context_7__dealloc__(PyObject *__pyx_v_self) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
+  __pyx_pf_3zmq_4core_7context_7Context_6__dealloc__(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "zmq/core/context.pyx":89
+ *         self.term()
+ * 
+ *     def __dealloc__(self):             # <<<<<<<<<<<<<<
+ *         """don't touch members in dealloc, just cleanup allocations"""
+ *         cdef int rc
+ */
+
+static void __pyx_pf_3zmq_4core_7context_7Context_6__dealloc__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self) {
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__dealloc__", 0);
+
+  /* "zmq/core/context.pyx":92
+ *         """don't touch members in dealloc, just cleanup allocations"""
+ *         cdef int rc
+ *         if self._sockets != NULL:             # <<<<<<<<<<<<<<
+ *             free(self._sockets)
+ *             self._sockets = NULL
+ */
+  __pyx_t_1 = (__pyx_v_self->_sockets != NULL);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":93
+ *         cdef int rc
+ *         if self._sockets != NULL:
+ *             free(self._sockets)             # <<<<<<<<<<<<<<
+ *             self._sockets = NULL
+ *             self._n_sockets = 0
+ */
+    free(__pyx_v_self->_sockets);
+
+    /* "zmq/core/context.pyx":94
+ *         if self._sockets != NULL:
+ *             free(self._sockets)
+ *             self._sockets = NULL             # <<<<<<<<<<<<<<
+ *             self._n_sockets = 0
+ *         self.term()
+ */
+    __pyx_v_self->_sockets = NULL;
+
+    /* "zmq/core/context.pyx":95
+ *             free(self._sockets)
+ *             self._sockets = NULL
+ *             self._n_sockets = 0             # <<<<<<<<<<<<<<
+ *         self.term()
+ * 
+ */
+    __pyx_v_self->_n_sockets = 0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/context.pyx":96
+ *             self._sockets = NULL
+ *             self._n_sockets = 0
+ *         self.term()             # <<<<<<<<<<<<<<
+ * 
+ *     cdef inline void _add_socket(self, void* handle):
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s__term); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("zmq.core.context.Context.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "zmq/core/context.pyx":98
+ *         self.term()
+ * 
+ *     cdef inline void _add_socket(self, void* handle):             # <<<<<<<<<<<<<<
+ *         """Add a socket handle to be closed when Context terminates.
+ * 
+ */
+
+static CYTHON_INLINE void __pyx_f_3zmq_4core_7context_7Context__add_socket(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, void *__pyx_v_handle) {
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_add_socket", 0);
+
+  /* "zmq/core/context.pyx":104
+ *         """
+ *         # print self._n_sockets, self._max_sockets
+ *         if self._n_sockets >= self._max_sockets:             # <<<<<<<<<<<<<<
+ *             self._max_sockets *= 2
+ *             self._sockets = <void **>realloc(self._sockets, self._max_sockets*sizeof(void *))
+ */
+  __pyx_t_1 = (__pyx_v_self->_n_sockets >= __pyx_v_self->_max_sockets);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":105
+ *         # print self._n_sockets, self._max_sockets
+ *         if self._n_sockets >= self._max_sockets:
+ *             self._max_sockets *= 2             # <<<<<<<<<<<<<<
+ *             self._sockets = <void **>realloc(self._sockets, self._max_sockets*sizeof(void *))
+ *             if self._sockets == NULL:
+ */
+    __pyx_v_self->_max_sockets = (__pyx_v_self->_max_sockets * 2);
+
+    /* "zmq/core/context.pyx":106
+ *         if self._n_sockets >= self._max_sockets:
+ *             self._max_sockets *= 2
+ *             self._sockets = <void **>realloc(self._sockets, self._max_sockets*sizeof(void *))             # <<<<<<<<<<<<<<
+ *             if self._sockets == NULL:
+ *                 raise MemoryError("Could not reallocate _sockets array")
+ */
+    __pyx_v_self->_sockets = ((void **)realloc(__pyx_v_self->_sockets, (__pyx_v_self->_max_sockets * (sizeof(void *)))));
+
+    /* "zmq/core/context.pyx":107
+ *             self._max_sockets *= 2
+ *             self._sockets = <void **>realloc(self._sockets, self._max_sockets*sizeof(void *))
+ *             if self._sockets == NULL:             # <<<<<<<<<<<<<<
+ *                 raise MemoryError("Could not reallocate _sockets array")
+ * 
+ */
+    __pyx_t_1 = (__pyx_v_self->_sockets == NULL);
+    if (__pyx_t_1) {
+
+      /* "zmq/core/context.pyx":108
+ *             self._sockets = <void **>realloc(self._sockets, self._max_sockets*sizeof(void *))
+ *             if self._sockets == NULL:
+ *                 raise MemoryError("Could not reallocate _sockets array")             # <<<<<<<<<<<<<<
+ * 
+ *         self._sockets[self._n_sockets] = handle
+ */
+      __pyx_t_2 = PyObject_Call(__pyx_builtin_MemoryError, ((PyObject *)__pyx_k_tuple_4), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L4;
+    }
+    __pyx_L4:;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/context.pyx":110
+ *                 raise MemoryError("Could not reallocate _sockets array")
+ * 
+ *         self._sockets[self._n_sockets] = handle             # <<<<<<<<<<<<<<
+ *         self._n_sockets += 1
+ *         # print self._n_sockets, self._max_sockets
+ */
+  (__pyx_v_self->_sockets[__pyx_v_self->_n_sockets]) = __pyx_v_handle;
+
+  /* "zmq/core/context.pyx":111
+ * 
+ *         self._sockets[self._n_sockets] = handle
+ *         self._n_sockets += 1             # <<<<<<<<<<<<<<
+ *         # print self._n_sockets, self._max_sockets
+ * 
+ */
+  __pyx_v_self->_n_sockets = (__pyx_v_self->_n_sockets + 1);
+
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_WriteUnraisable("zmq.core.context.Context._add_socket", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "zmq/core/context.pyx":114
+ *         # print self._n_sockets, self._max_sockets
+ * 
+ *     cdef inline void _remove_socket(self, void* handle):             # <<<<<<<<<<<<<<
+ *         """Remove a socket from the collected handles.
+ * 
+ */
+
+static CYTHON_INLINE void __pyx_f_3zmq_4core_7context_7Context__remove_socket(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, void *__pyx_v_handle) {
+  int __pyx_v_found;
+  size_t __pyx_v_idx;
+  __Pyx_RefNannyDeclarations
+  size_t __pyx_t_1;
+  size_t __pyx_t_2;
+  int __pyx_t_3;
+  __Pyx_RefNannySetupContext("_remove_socket", 0);
+
+  /* "zmq/core/context.pyx":120
+ *         close a socket a second time.
+ *         """
+ *         cdef bint found = False             # <<<<<<<<<<<<<<
+ * 
+ *         for idx in range(self._n_sockets):
+ */
+  __pyx_v_found = 0;
+
+  /* "zmq/core/context.pyx":122
+ *         cdef bint found = False
+ * 
+ *         for idx in range(self._n_sockets):             # <<<<<<<<<<<<<<
+ *             if self._sockets[idx] == handle:
+ *                 found=True
+ */
+  __pyx_t_1 = __pyx_v_self->_n_sockets;
+  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
+    __pyx_v_idx = __pyx_t_2;
+
+    /* "zmq/core/context.pyx":123
+ * 
+ *         for idx in range(self._n_sockets):
+ *             if self._sockets[idx] == handle:             # <<<<<<<<<<<<<<
+ *                 found=True
+ *                 break
+ */
+    __pyx_t_3 = ((__pyx_v_self->_sockets[__pyx_v_idx]) == __pyx_v_handle);
+    if (__pyx_t_3) {
+
+      /* "zmq/core/context.pyx":124
+ *         for idx in range(self._n_sockets):
+ *             if self._sockets[idx] == handle:
+ *                 found=True             # <<<<<<<<<<<<<<
+ *                 break
+ * 
+ */
+      __pyx_v_found = 1;
+
+      /* "zmq/core/context.pyx":125
+ *             if self._sockets[idx] == handle:
+ *                 found=True
+ *                 break             # <<<<<<<<<<<<<<
+ * 
+ *         if found:
+ */
+      goto __pyx_L4_break;
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+  }
+  __pyx_L4_break:;
+
+  /* "zmq/core/context.pyx":127
+ *                 break
+ * 
+ *         if found:             # <<<<<<<<<<<<<<
+ *             self._n_sockets -= 1
+ *             if self._n_sockets:
+ */
+  if (__pyx_v_found) {
+
+    /* "zmq/core/context.pyx":128
+ * 
+ *         if found:
+ *             self._n_sockets -= 1             # <<<<<<<<<<<<<<
+ *             if self._n_sockets:
+ *                 # move last handle to closed socket's index
+ */
+    __pyx_v_self->_n_sockets = (__pyx_v_self->_n_sockets - 1);
+
+    /* "zmq/core/context.pyx":129
+ *         if found:
+ *             self._n_sockets -= 1
+ *             if self._n_sockets:             # <<<<<<<<<<<<<<
+ *                 # move last handle to closed socket's index
+ *                 self._sockets[idx] = self._sockets[self._n_sockets]
+ */
+    if (__pyx_v_self->_n_sockets) {
+
+      /* "zmq/core/context.pyx":131
+ *             if self._n_sockets:
+ *                 # move last handle to closed socket's index
+ *                 self._sockets[idx] = self._sockets[self._n_sockets]             # <<<<<<<<<<<<<<
+ * 
+ *     @property
+ */
+      (__pyx_v_self->_sockets[__pyx_v_idx]) = (__pyx_v_self->_sockets[__pyx_v_self->_n_sockets]);
+      goto __pyx_L7;
+    }
+    __pyx_L7:;
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  __Pyx_RefNannyFinishContext();
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_9_handle(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_9_handle(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("_handle (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_8_handle(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/context.pyx":134
+ * 
+ *     @property
+ *     def _handle(self):             # <<<<<<<<<<<<<<
+ *         return <Py_ssize_t> self.handle
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_8_handle(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_handle", 0);
+
+  /* "zmq/core/context.pyx":135
+ *     @property
+ *     def _handle(self):
+ *         return <Py_ssize_t> self.handle             # <<<<<<<<<<<<<<
+ * 
+ *     def term(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyInt_FromSsize_t(((Py_ssize_t)__pyx_v_self->handle)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("zmq.core.context.Context._handle", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_11term(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3zmq_4core_7context_7Context_10term[] = "ctx.term()\n\n        Close or terminate the context.\n        \n        This can be called to close the context by hand. If this is not called,\n        the context will automatically be closed when it is garbage collected.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_11term(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("term (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_10term(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/context.pyx":137
+ *         return <Py_ssize_t> self.handle
+ * 
+ *     def term(self):             # <<<<<<<<<<<<<<
+ *         """ctx.term()
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_10term(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self) {
+  int __pyx_v_rc;
+  CYTHON_UNUSED int __pyx_v_i;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("term", 0);
+
+  /* "zmq/core/context.pyx":146
+ *         """
+ *         cdef int rc
+ *         cdef int i=-1             # <<<<<<<<<<<<<<
+ * 
+ *         if self.handle != NULL and not self.closed and getpid() == self._pid:
+ */
+  __pyx_v_i = -1;
+
+  /* "zmq/core/context.pyx":148
+ *         cdef int i=-1
+ * 
+ *         if self.handle != NULL and not self.closed and getpid() == self._pid:             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 rc = zmq_ctx_destroy(self.handle)
+ */
+  __pyx_t_1 = (__pyx_v_self->handle != NULL);
+  if (__pyx_t_1) {
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_self->closed); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = (!__pyx_t_2);
+    if (__pyx_t_3) {
+      __pyx_t_2 = (getpid() == __pyx_v_self->_pid);
+      __pyx_t_4 = __pyx_t_2;
+    } else {
+      __pyx_t_4 = __pyx_t_3;
+    }
+    __pyx_t_3 = __pyx_t_4;
+  } else {
+    __pyx_t_3 = __pyx_t_1;
+  }
+  if (__pyx_t_3) {
+
+    /* "zmq/core/context.pyx":149
+ * 
+ *         if self.handle != NULL and not self.closed and getpid() == self._pid:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_ctx_destroy(self.handle)
+ *             _check_rc(rc)
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        Py_UNBLOCK_THREADS
+        #endif
+        /*try:*/ {
+
+          /* "zmq/core/context.pyx":150
+ *         if self.handle != NULL and not self.closed and getpid() == self._pid:
+ *             with nogil:
+ *                 rc = zmq_ctx_destroy(self.handle)             # <<<<<<<<<<<<<<
+ *             _check_rc(rc)
+ *             self.handle = NULL
+ */
+          __pyx_v_rc = zmq_ctx_destroy(__pyx_v_self->handle);
+        }
+
+        /* "zmq/core/context.pyx":149
+ * 
+ *         if self.handle != NULL and not self.closed and getpid() == self._pid:
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 rc = zmq_ctx_destroy(self.handle)
+ *             _check_rc(rc)
+ */
+        /*finally:*/ {
+          #ifdef WITH_THREAD
+          Py_BLOCK_THREADS
+          #endif
+        }
+    }
+
+    /* "zmq/core/context.pyx":151
+ *             with nogil:
+ *                 rc = zmq_ctx_destroy(self.handle)
+ *             _check_rc(rc)             # <<<<<<<<<<<<<<
+ *             self.handle = NULL
+ *             self.closed = True
+ */
+    __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+    /* "zmq/core/context.pyx":152
+ *                 rc = zmq_ctx_destroy(self.handle)
+ *             _check_rc(rc)
+ *             self.handle = NULL             # <<<<<<<<<<<<<<
+ *             self.closed = True
+ * 
+ */
+    __pyx_v_self->handle = NULL;
+
+    /* "zmq/core/context.pyx":153
+ *             _check_rc(rc)
+ *             self.handle = NULL
+ *             self.closed = True             # <<<<<<<<<<<<<<
+ * 
+ *     def set(self, int option, optval):
+ */
+    __pyx_t_6 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_GIVEREF(__pyx_t_6);
+    __Pyx_GOTREF(__pyx_v_self->closed);
+    __Pyx_DECREF(__pyx_v_self->closed);
+    __pyx_v_self->closed = __pyx_t_6;
+    __pyx_t_6 = 0;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("zmq.core.context.Context.term", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_13set(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_7context_7Context_12set[] = "ctx.set(option, optval)\n\n        Set context options.\n\n        See the 0MQ API documentation for zmq_ctx_set\n        for details on specific options.\n        \n        New in libzmq-3.2\n\n        Parameters\n        ----------\n        option : int\n            The option to set.  Available values will depend on your\n            version of libzmq.  Examples include::\n            \n                zmq.IO_THREADS, zmq.MAX_SOCKETS\n        \n        optval : int\n            The value of the option to set.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_13set(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_v_option;
+  PyObject *__pyx_v_optval = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("set (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__option,&__pyx_n_s__optval,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__option)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        case  1:
+        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__optval)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("set", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_option = __Pyx_PyInt_AsInt(values[0]); if (unlikely((__pyx_v_option == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    __pyx_v_optval = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("set", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.context.Context.set", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_12set(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self), __pyx_v_option, __pyx_v_optval);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/context.pyx":155
+ *             self.closed = True
+ * 
+ *     def set(self, int option, optval):             # <<<<<<<<<<<<<<
+ *         """ctx.set(option, optval)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_12set(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, int __pyx_v_option, PyObject *__pyx_v_optval) {
+  int __pyx_v_optval_int_c;
+  int __pyx_v_rc;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("set", 0);
+
+  /* "zmq/core/context.pyx":180
+ *         cdef char* optval_c
+ * 
+ *         if self.closed:             # <<<<<<<<<<<<<<
+ *             raise RuntimeError("Context has been destroyed")
+ * 
+ */
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_self->closed); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":181
+ * 
+ *         if self.closed:
+ *             raise RuntimeError("Context has been destroyed")             # <<<<<<<<<<<<<<
+ * 
+ *         if not isinstance(optval, int):
+ */
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_6), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/context.pyx":183
+ *             raise RuntimeError("Context has been destroyed")
+ * 
+ *         if not isinstance(optval, int):             # <<<<<<<<<<<<<<
+ *             raise TypeError('expected int, got: %r' % optval)
+ *         optval_int_c = optval
+ */
+  __pyx_t_1 = PyInt_Check(__pyx_v_optval); 
+  __pyx_t_3 = (!__pyx_t_1);
+  if (__pyx_t_3) {
+
+    /* "zmq/core/context.pyx":184
+ * 
+ *         if not isinstance(optval, int):
+ *             raise TypeError('expected int, got: %r' % optval)             # <<<<<<<<<<<<<<
+ *         optval_int_c = optval
+ *         rc = zmq_ctx_set(self.handle, option, optval_int_c)
+ */
+    __pyx_t_2 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_7), __pyx_v_optval); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_2));
+    __Pyx_GIVEREF(((PyObject *)__pyx_t_2));
+    __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  /* "zmq/core/context.pyx":185
+ *         if not isinstance(optval, int):
+ *             raise TypeError('expected int, got: %r' % optval)
+ *         optval_int_c = optval             # <<<<<<<<<<<<<<
+ *         rc = zmq_ctx_set(self.handle, option, optval_int_c)
+ *         _check_rc(rc)
+ */
+  __pyx_t_5 = __Pyx_PyInt_AsInt(__pyx_v_optval); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_optval_int_c = __pyx_t_5;
+
+  /* "zmq/core/context.pyx":186
+ *             raise TypeError('expected int, got: %r' % optval)
+ *         optval_int_c = optval
+ *         rc = zmq_ctx_set(self.handle, option, optval_int_c)             # <<<<<<<<<<<<<<
+ *         _check_rc(rc)
+ * 
+ */
+  __pyx_v_rc = zmq_ctx_set(__pyx_v_self->handle, __pyx_v_option, __pyx_v_optval_int_c);
+
+  /* "zmq/core/context.pyx":187
+ *         optval_int_c = optval
+ *         rc = zmq_ctx_set(self.handle, option, optval_int_c)
+ *         _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *     def get(self, int option):
+ */
+  __pyx_t_5 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.context.Context.set", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_15get(PyObject *__pyx_v_self, PyObject *__pyx_arg_option); /*proto*/
+static char __pyx_doc_3zmq_4core_7context_7Context_14get[] = "ctx.get(option)\n\n        Get the value of a context option.\n\n        See the 0MQ API documentation for zmq_ctx_get\n        for details on specific options.\n        \n        New in libzmq-3.2\n\n        Parameters\n        ----------\n        option : int\n            The option to get.  Available values will depend on your\n            version of libzmq.  Examples include::\n            \n                zmq.IO_THREADS, zmq.MAX_SOCKETS\n            \n        Returns\n        -------\n        optval : int\n            The value of the option as an integer.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_15get(PyObject *__pyx_v_self, PyObject *__pyx_arg_option) {
+  int __pyx_v_option;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get (wrapper)", 0);
+  assert(__pyx_arg_option); {
+    __pyx_v_option = __Pyx_PyInt_AsInt(__pyx_arg_option); if (unlikely((__pyx_v_option == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.context.Context.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_14get(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self), ((int)__pyx_v_option));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/context.pyx":189
+ *         _check_rc(rc)
+ * 
+ *     def get(self, int option):             # <<<<<<<<<<<<<<
+ *         """ctx.get(option)
+ * 
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_14get(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, int __pyx_v_option) {
+  int __pyx_v_rc;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_3;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get", 0);
+
+  /* "zmq/core/context.pyx":216
+ *         cdef int rc
+ * 
+ *         if self.closed:             # <<<<<<<<<<<<<<
+ *             raise RuntimeError("Context has been destroyed")
+ * 
+ */
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_self->closed); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":217
+ * 
+ *         if self.closed:
+ *             raise RuntimeError("Context has been destroyed")             # <<<<<<<<<<<<<<
+ * 
+ *         rc = zmq_ctx_get(self.handle, option)
+ */
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_8), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 217; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 217; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/context.pyx":219
+ *             raise RuntimeError("Context has been destroyed")
+ * 
+ *         rc = zmq_ctx_get(self.handle, option)             # <<<<<<<<<<<<<<
+ *         _check_rc(rc)
+ * 
+ */
+  __pyx_v_rc = zmq_ctx_get(__pyx_v_self->handle, __pyx_v_option);
+
+  /* "zmq/core/context.pyx":220
+ * 
+ *         rc = zmq_ctx_get(self.handle, option)
+ *         _check_rc(rc)             # <<<<<<<<<<<<<<
+ * 
+ *         return rc
+ */
+  __pyx_t_3 = __pyx_f_3zmq_4core_7checkrc__check_rc(__pyx_v_rc); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/context.pyx":222
+ *         _check_rc(rc)
+ * 
+ *         return rc             # <<<<<<<<<<<<<<
+ * 
+ *     def destroy(self, linger=None):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = PyInt_FromLong(__pyx_v_rc); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("zmq.core.context.Context.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_17destroy(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3zmq_4core_7context_7Context_16destroy[] = "ctx.destroy(linger=None)\n        \n        Close all sockets associated with this context, and then terminate\n        the context. If linger is specified,\n        the LINGER sockopt of the sockets will be set prior to closing.\n        \n        WARNING:\n        \n        destroy involves calling zmq_close(), which is *NOT* threadsafe.\n        If there are active sockets in other threads, this must not be called.\n        ";
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_17destroy(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_linger = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("destroy (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__linger,0};
+    PyObject* values[1] = {0};
+
+    /* "zmq/core/context.pyx":224
+ *         return rc
+ * 
+ *     def destroy(self, linger=None):             # <<<<<<<<<<<<<<
+ *         """ctx.destroy(linger=None)
+ * 
+ */
+    values[0] = ((PyObject *)Py_None);
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (kw_args > 0) {
+          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__linger);
+          if (value) { values[0] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "destroy") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 224; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_linger = values[0];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("destroy", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 224; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("zmq.core.context.Context.destroy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_16destroy(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self), __pyx_v_linger);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_16destroy(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, PyObject *__pyx_v_linger) {
+  int __pyx_v_linger_c;
+  int __pyx_v_setlinger;
+  int __pyx_v_rc;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("destroy", 0);
+
+  /* "zmq/core/context.pyx":238
+ * 
+ *         cdef int linger_c
+ *         cdef bint setlinger=False             # <<<<<<<<<<<<<<
+ * 
+ *         if linger is not None:
+ */
+  __pyx_v_setlinger = 0;
+
+  /* "zmq/core/context.pyx":240
+ *         cdef bint setlinger=False
+ * 
+ *         if linger is not None:             # <<<<<<<<<<<<<<
+ *             linger_c = linger
+ *             setlinger=True
+ */
+  __pyx_t_1 = (__pyx_v_linger != Py_None);
+  if (__pyx_t_1) {
+
+    /* "zmq/core/context.pyx":241
+ * 
+ *         if linger is not None:
+ *             linger_c = linger             # <<<<<<<<<<<<<<
+ *             setlinger=True
+ *         if self.handle != NULL and not self.closed and self._n_sockets:
+ */
+    __pyx_t_2 = __Pyx_PyInt_AsInt(__pyx_v_linger); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_linger_c = __pyx_t_2;
+
+    /* "zmq/core/context.pyx":242
+ *         if linger is not None:
+ *             linger_c = linger
+ *             setlinger=True             # <<<<<<<<<<<<<<
+ *         if self.handle != NULL and not self.closed and self._n_sockets:
+ *             while self._n_sockets:
+ */
+    __pyx_v_setlinger = 1;
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/context.pyx":243
+ *             linger_c = linger
+ *             setlinger=True
+ *         if self.handle != NULL and not self.closed and self._n_sockets:             # <<<<<<<<<<<<<<
+ *             while self._n_sockets:
+ *                 if setlinger:
+ */
+  __pyx_t_1 = (__pyx_v_self->handle != NULL);
+  if (__pyx_t_1) {
+    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_self->closed); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_4 = (!__pyx_t_3);
+    if (__pyx_t_4) {
+      __pyx_t_3 = __pyx_v_self->_n_sockets;
+    } else {
+      __pyx_t_3 = __pyx_t_4;
+    }
+    __pyx_t_4 = __pyx_t_3;
+  } else {
+    __pyx_t_4 = __pyx_t_1;
+  }
+  if (__pyx_t_4) {
+
+    /* "zmq/core/context.pyx":244
+ *             setlinger=True
+ *         if self.handle != NULL and not self.closed and self._n_sockets:
+ *             while self._n_sockets:             # <<<<<<<<<<<<<<
+ *                 if setlinger:
+ *                     zmq_setsockopt(self._sockets[0], ZMQ_LINGER, &linger_c, sizeof(int))
+ */
+    while (1) {
+      if (!__pyx_v_self->_n_sockets) break;
+
+      /* "zmq/core/context.pyx":245
+ *         if self.handle != NULL and not self.closed and self._n_sockets:
+ *             while self._n_sockets:
+ *                 if setlinger:             # <<<<<<<<<<<<<<
+ *                     zmq_setsockopt(self._sockets[0], ZMQ_LINGER, &linger_c, sizeof(int))
+ *                 rc = zmq_close(self._sockets[0])
+ */
+      if (__pyx_v_setlinger) {
+
+        /* "zmq/core/context.pyx":246
+ *             while self._n_sockets:
+ *                 if setlinger:
+ *                     zmq_setsockopt(self._sockets[0], ZMQ_LINGER, &linger_c, sizeof(int))             # <<<<<<<<<<<<<<
+ *                 rc = zmq_close(self._sockets[0])
+ *                 if rc < 0 and zmq_errno() != ZMQ_ENOTSOCK:
+ */
+        zmq_setsockopt((__pyx_v_self->_sockets[0]), ZMQ_LINGER, (&__pyx_v_linger_c), (sizeof(int)));
+        goto __pyx_L7;
+      }
+      __pyx_L7:;
+
+      /* "zmq/core/context.pyx":247
+ *                 if setlinger:
+ *                     zmq_setsockopt(self._sockets[0], ZMQ_LINGER, &linger_c, sizeof(int))
+ *                 rc = zmq_close(self._sockets[0])             # <<<<<<<<<<<<<<
+ *                 if rc < 0 and zmq_errno() != ZMQ_ENOTSOCK:
+ *                     raise ZMQError()
+ */
+      __pyx_v_rc = zmq_close((__pyx_v_self->_sockets[0]));
+
+      /* "zmq/core/context.pyx":248
+ *                     zmq_setsockopt(self._sockets[0], ZMQ_LINGER, &linger_c, sizeof(int))
+ *                 rc = zmq_close(self._sockets[0])
+ *                 if rc < 0 and zmq_errno() != ZMQ_ENOTSOCK:             # <<<<<<<<<<<<<<
+ *                     raise ZMQError()
+ *                 self._n_sockets -= 1
+ */
+      __pyx_t_4 = (__pyx_v_rc < 0);
+      if (__pyx_t_4) {
+        __pyx_t_1 = (zmq_errno() != ENOTSOCK);
+        __pyx_t_3 = __pyx_t_1;
+      } else {
+        __pyx_t_3 = __pyx_t_4;
+      }
+      if (__pyx_t_3) {
+
+        /* "zmq/core/context.pyx":249
+ *                 rc = zmq_close(self._sockets[0])
+ *                 if rc < 0 and zmq_errno() != ZMQ_ENOTSOCK:
+ *                     raise ZMQError()             # <<<<<<<<<<<<<<
+ *                 self._n_sockets -= 1
+ *                 self._sockets[0] = self._sockets[self._n_sockets]
+ */
+        __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s__ZMQError); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_5);
+        __pyx_t_6 = PyObject_Call(__pyx_t_5, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_6);
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_Raise(__pyx_t_6, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        goto __pyx_L8;
+      }
+      __pyx_L8:;
+
+      /* "zmq/core/context.pyx":250
+ *                 if rc < 0 and zmq_errno() != ZMQ_ENOTSOCK:
+ *                     raise ZMQError()
+ *                 self._n_sockets -= 1             # <<<<<<<<<<<<<<
+ *                 self._sockets[0] = self._sockets[self._n_sockets]
+ *             self.term()
+ */
+      __pyx_v_self->_n_sockets = (__pyx_v_self->_n_sockets - 1);
+
+      /* "zmq/core/context.pyx":251
+ *                     raise ZMQError()
+ *                 self._n_sockets -= 1
+ *                 self._sockets[0] = self._sockets[self._n_sockets]             # <<<<<<<<<<<<<<
+ *             self.term()
+ * 
+ */
+      (__pyx_v_self->_sockets[0]) = (__pyx_v_self->_sockets[__pyx_v_self->_n_sockets]);
+    }
+
+    /* "zmq/core/context.pyx":252
+ *                 self._n_sockets -= 1
+ *                 self._sockets[0] = self._sockets[self._n_sockets]
+ *             self.term()             # <<<<<<<<<<<<<<
+ * 
+ * __all__ = ['Context']
+ */
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s__term); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_5 = PyObject_Call(__pyx_t_6, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    goto __pyx_L4;
+  }
+  __pyx_L4:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("zmq.core.context.Context.destroy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_6closed_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3zmq_4core_7context_7Context_6closed_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_6closed___get__(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/context.pxd":36
+ *     cdef int _pid               # the pid of the process which created me (for fork safety)
+ * 
+ *     cdef public object closed   # bool property for a closed context.             # <<<<<<<<<<<<<<
+ *     # helpers for events on _sockets in Socket.__cinit__()/close()
+ *     cdef inline void _add_socket(self, void* handle)
+ */
+
+static PyObject *__pyx_pf_3zmq_4core_7context_7Context_6closed___get__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->closed);
+  __pyx_r = __pyx_v_self->closed;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7context_7Context_6closed_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
+static int __pyx_pw_3zmq_4core_7context_7Context_6closed_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_6closed_2__set__(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self), ((PyObject *)__pyx_v_value));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7context_7Context_6closed_2__set__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self, PyObject *__pyx_v_value) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__set__", 0);
+  __Pyx_INCREF(__pyx_v_value);
+  __Pyx_GIVEREF(__pyx_v_value);
+  __Pyx_GOTREF(__pyx_v_self->closed);
+  __Pyx_DECREF(__pyx_v_self->closed);
+  __pyx_v_self->closed = __pyx_v_value;
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static int __pyx_pw_3zmq_4core_7context_7Context_6closed_5__del__(PyObject *__pyx_v_self); /*proto*/
+static int __pyx_pw_3zmq_4core_7context_7Context_6closed_5__del__(PyObject *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3zmq_4core_7context_7Context_6closed_4__del__(((struct __pyx_obj_3zmq_4core_7context_Context *)__pyx_v_self));
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3zmq_4core_7context_7Context_6closed_4__del__(struct __pyx_obj_3zmq_4core_7context_Context *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__del__", 0);
+  __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(Py_None);
+  __Pyx_GOTREF(__pyx_v_self->closed);
+  __Pyx_DECREF(__pyx_v_self->closed);
+  __pyx_v_self->closed = Py_None;
+
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "zmq/core/checkrc.pxd":5
+ * from libzmq cimport zmq_errno, ZMQ_ETERM
+ * 
+ * cdef inline int _check_rc(int rc) except -1:             # <<<<<<<<<<<<<<
+ *     """internal utility for checking zmq return condition
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_3zmq_4core_7checkrc__check_rc(int __pyx_v_rc) {
+  int __pyx_v_errno;
+  PyObject *__pyx_v_Again = NULL;
+  PyObject *__pyx_v_ContextTerminated = NULL;
+  PyObject *__pyx_v_ZMQError = NULL;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_check_rc", 0);
+
+  /* "zmq/core/checkrc.pxd":10
+ *     and raising the appropriate Exception class
+ *     """
+ *     cdef int errno = zmq_errno()             # <<<<<<<<<<<<<<
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ */
+  __pyx_v_errno = zmq_errno();
+
+  /* "zmq/core/checkrc.pxd":11
+ *     """
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()             # <<<<<<<<<<<<<<
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ */
+  __pyx_t_1 = PyErr_CheckSignals(); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/checkrc.pxd":12
+ *     cdef int errno = zmq_errno()
+ *     PyErr_CheckSignals()
+ *     if rc < 0:             # <<<<<<<<<<<<<<
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ */
+  __pyx_t_2 = (__pyx_v_rc < 0);
+  if (__pyx_t_2) {
+
+    /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+    switch (__pyx_v_errno) {
+
+      /* "zmq/core/checkrc.pxd":13
+ *     PyErr_CheckSignals()
+ *     if rc < 0:
+ *         if errno == EAGAIN:             # <<<<<<<<<<<<<<
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ */
+      case EAGAIN:
+
+      /* "zmq/core/checkrc.pxd":14
+ *     if rc < 0:
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again             # <<<<<<<<<<<<<<
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__Again));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__Again));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Again));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_9), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__Again); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_Again = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":15
+ *         if errno == EAGAIN:
+ *             from zmq.error import Again
+ *             raise Again(errno)             # <<<<<<<<<<<<<<
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_Again, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+
+      /* "zmq/core/checkrc.pxd":16
+ *             from zmq.error import Again
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:             # <<<<<<<<<<<<<<
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)
+ */
+      case ETERM:
+
+      /* "zmq/core/checkrc.pxd":17
+ *             raise Again(errno)
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated             # <<<<<<<<<<<<<<
+ *             raise ContextTerminated(errno)
+ *         else:
+ */
+      __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      PyList_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_n_s__ContextTerminated));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ContextTerminated));
+      __pyx_t_3 = __Pyx_Import(((PyObject *)__pyx_n_s_9), ((PyObject *)__pyx_t_4), -1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s__ContextTerminated); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 17; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_4);
+      __pyx_v_ContextTerminated = __pyx_t_4;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+      /* "zmq/core/checkrc.pxd":18
+ *         elif errno == ZMQ_ETERM:
+ *             from zmq.error import ContextTerminated
+ *             raise ContextTerminated(errno)             # <<<<<<<<<<<<<<
+ *         else:
+ *             from zmq.error import ZMQError
+ */
+      __pyx_t_3 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_3);
+      __pyx_t_3 = 0;
+      __pyx_t_3 = PyObject_Call(__pyx_v_ContextTerminated, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+      default:
+
+      /* "zmq/core/checkrc.pxd":20
+ *             raise ContextTerminated(errno)
+ *         else:
+ *             from zmq.error import ZMQError             # <<<<<<<<<<<<<<
+ *             raise ZMQError(errno)
+ *         # return -1
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQError));
+      PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__ZMQError));
+      __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQError));
+      __pyx_t_4 = __Pyx_Import(((PyObject *)__pyx_n_s_9), ((PyObject *)__pyx_t_3), -1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s__ZMQError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_3);
+      __pyx_v_ZMQError = __pyx_t_3;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+      /* "zmq/core/checkrc.pxd":21
+ *         else:
+ *             from zmq.error import ZMQError
+ *             raise ZMQError(errno)             # <<<<<<<<<<<<<<
+ *         # return -1
+ *     return 0
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_errno); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_v_ZMQError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+    }
+    goto __pyx_L3;
+  }
+  __pyx_L3:;
+
+  /* "zmq/core/checkrc.pxd":23
+ *             raise ZMQError(errno)
+ *         # return -1
+ *     return 0             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = 0;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("zmq.core.checkrc._check_rc", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_Again);
+  __Pyx_XDECREF(__pyx_v_ContextTerminated);
+  __Pyx_XDECREF(__pyx_v_ZMQError);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":104
+ * # Datetime C API initialization function.
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():             # <<<<<<<<<<<<<<
+ *     PyDateTime_IMPORT
+ * 
+ */
+
+static CYTHON_INLINE void __pyx_f_7cpython_8datetime_import_datetime(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("import_datetime", 0);
+
+  /* "cpython/datetime.pxd":105
+ * # You have to call it before any usage of DateTime CAPI functions.
+ * cdef inline void import_datetime():
+ *     PyDateTime_IMPORT             # <<<<<<<<<<<<<<
+ * 
+ * # Create date object using DateTime CAPI factory function.
+ */
+  PyDateTime_IMPORT;
+
+  __Pyx_RefNannyFinishContext();
+}
+
+/* "cpython/datetime.pxd":109
+ * # Create date object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_date_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("date_new", 0);
+
+  /* "cpython/datetime.pxd":110
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object date_new(int year, int month, int day):
+ *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create time object using DateTime CAPI factory function
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Date_FromDate(__pyx_v_year, __pyx_v_month, __pyx_v_day, PyDateTimeAPI->DateType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.date_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":114
+ * # Create time object using DateTime CAPI factory function
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_new(int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("time_new", 0);
+
+  /* "cpython/datetime.pxd":115
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create datetime object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Time_FromTime(__pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->TimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.time_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":119
+ * # Create datetime object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day, int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("datetime_new", 0);
+
+  /* "cpython/datetime.pxd":120
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):
+ *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)             # <<<<<<<<<<<<<<
+ * 
+ * # Create timedelta object using DateTime CAPI factory function.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->DateTime_FromDateAndTime(__pyx_v_year, __pyx_v_month, __pyx_v_day, __pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->DateTimeType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.datetime_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":124
+ * # Create timedelta object using DateTime CAPI factory function.
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):             # <<<<<<<<<<<<<<
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_timedelta_new(int __pyx_v_days, int __pyx_v_seconds, int __pyx_v_useconds) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("timedelta_new", 0);
+
+  /* "cpython/datetime.pxd":125
+ * # Note, there are no range checks for any of the arguments.
+ * cdef inline object timedelta_new(int days, int seconds, int useconds):
+ *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)             # <<<<<<<<<<<<<<
+ * 
+ * # More recognizable getters for date/time/datetime/timedelta.
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyDateTimeAPI->Delta_FromDelta(__pyx_v_days, __pyx_v_seconds, __pyx_v_useconds, 1, PyDateTimeAPI->DeltaType); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("cpython.datetime.timedelta_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":133
+ * 
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":134
+ * # Get tzinfo of time
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_Time *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":135
+ * cdef inline object time_tzinfo(object o):
+ *     if (<PyDateTime_Time*>o).hastzinfo:
+ *         return <object>(<PyDateTime_Time*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":137
+ *         return <object>(<PyDateTime_Time*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get tzinfo of datetime
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":140
+ * 
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):             # <<<<<<<<<<<<<<
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ */
+
+static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_tzinfo(PyObject *__pyx_v_o) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_tzinfo", 0);
+
+  /* "cpython/datetime.pxd":141
+ * # Get tzinfo of datetime
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:             # <<<<<<<<<<<<<<
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ */
+  if (((PyDateTime_DateTime *)__pyx_v_o)->hastzinfo) {
+
+    /* "cpython/datetime.pxd":142
+ * cdef inline object datetime_tzinfo(object o):
+ *     if (<PyDateTime_DateTime*>o).hastzinfo:
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo             # <<<<<<<<<<<<<<
+ *     else:
+ *         return None
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo));
+    __pyx_r = ((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo);
+    goto __pyx_L0;
+    goto __pyx_L3;
+  }
+  /*else*/ {
+
+    /* "cpython/datetime.pxd":144
+ *         return <object>(<PyDateTime_DateTime*>o).tzinfo
+ *     else:
+ *         return None             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of date
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_None);
+    __pyx_r = Py_None;
+    goto __pyx_L0;
+  }
+  __pyx_L3:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":147
+ * 
+ * # Get year of date
+ * cdef inline int date_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_year", 0);
+
+  /* "cpython/datetime.pxd":148
+ * # Get year of date
+ * cdef inline int date_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of date
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":151
+ * 
+ * # Get month of date
+ * cdef inline int date_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_month", 0);
+
+  /* "cpython/datetime.pxd":152
+ * # Get month of date
+ * cdef inline int date_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of date
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":155
+ * 
+ * # Get day of date
+ * cdef inline int date_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("date_day", 0);
+
+  /* "cpython/datetime.pxd":156
+ * # Get day of date
+ * cdef inline int date_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get year of datetime
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":159
+ * 
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_YEAR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_year(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_year", 0);
+
+  /* "cpython/datetime.pxd":160
+ * # Get year of datetime
+ * cdef inline int datetime_year(object o):
+ *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get month of datetime
+ */
+  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":163
+ * 
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_MONTH(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_month(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_month", 0);
+
+  /* "cpython/datetime.pxd":164
+ * # Get month of datetime
+ * cdef inline int datetime_month(object o):
+ *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get day of datetime
+ */
+  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":167
+ * 
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_GET_DAY(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_day(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_day", 0);
+
+  /* "cpython/datetime.pxd":168
+ * # Get day of datetime
+ * cdef inline int datetime_day(object o):
+ *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of time
+ */
+  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":171
+ * 
+ * # Get hour of time
+ * cdef inline int time_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_hour", 0);
+
+  /* "cpython/datetime.pxd":172
+ * # Get hour of time
+ * cdef inline int time_hour(object o):
+ *     return PyDateTime_TIME_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":175
+ * 
+ * # Get minute of time
+ * cdef inline int time_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_minute", 0);
+
+  /* "cpython/datetime.pxd":176
+ * # Get minute of time
+ * cdef inline int time_minute(object o):
+ *     return PyDateTime_TIME_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":179
+ * 
+ * # Get second of time
+ * cdef inline int time_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_second", 0);
+
+  /* "cpython/datetime.pxd":180
+ * # Get second of time
+ * cdef inline int time_second(object o):
+ *     return PyDateTime_TIME_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of time
+ */
+  __pyx_r = PyDateTime_TIME_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":183
+ * 
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("time_microsecond", 0);
+
+  /* "cpython/datetime.pxd":184
+ * # Get microsecond of time
+ * cdef inline int time_microsecond(object o):
+ *     return PyDateTime_TIME_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get hour of datetime
+ */
+  __pyx_r = PyDateTime_TIME_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":187
+ * 
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_HOUR(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_hour(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_hour", 0);
+
+  /* "cpython/datetime.pxd":188
+ * # Get hour of datetime
+ * cdef inline int datetime_hour(object o):
+ *     return PyDateTime_DATE_GET_HOUR(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get minute of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_HOUR(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":191
+ * 
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MINUTE(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_minute(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_minute", 0);
+
+  /* "cpython/datetime.pxd":192
+ * # Get minute of datetime
+ * cdef inline int datetime_minute(object o):
+ *     return PyDateTime_DATE_GET_MINUTE(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get second of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_MINUTE(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":195
+ * 
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_SECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_second(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_second", 0);
+
+  /* "cpython/datetime.pxd":196
+ * # Get second of datetime
+ * cdef inline int datetime_second(object o):
+ *     return PyDateTime_DATE_GET_SECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get microsecond of datetime
+ */
+  __pyx_r = PyDateTime_DATE_GET_SECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":199
+ * 
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):             # <<<<<<<<<<<<<<
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_microsecond(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("datetime_microsecond", 0);
+
+  /* "cpython/datetime.pxd":200
+ * # Get microsecond of datetime
+ * cdef inline int datetime_microsecond(object o):
+ *     return PyDateTime_DATE_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
+ * 
+ * # Get days of timedelta
+ */
+  __pyx_r = PyDateTime_DATE_GET_MICROSECOND(__pyx_v_o);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":203
+ * 
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).days
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_days(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_days", 0);
+
+  /* "cpython/datetime.pxd":204
+ * # Get days of timedelta
+ * cdef inline int timedelta_days(object o):
+ *     return (<PyDateTime_Delta*>o).days             # <<<<<<<<<<<<<<
+ * 
+ * # Get seconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->days;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":207
+ * 
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).seconds
+ * 
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_seconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_seconds", 0);
+
+  /* "cpython/datetime.pxd":208
+ * # Get seconds of timedelta
+ * cdef inline int timedelta_seconds(object o):
+ *     return (<PyDateTime_Delta*>o).seconds             # <<<<<<<<<<<<<<
+ * 
+ * # Get microseconds of timedelta
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->seconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+
+static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_microseconds(PyObject *__pyx_v_o) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("timedelta_microseconds", 0);
+
+  /* "cpython/datetime.pxd":212
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):
+ *     return (<PyDateTime_Delta*>o).microseconds             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->microseconds;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+static struct __pyx_vtabstruct_3zmq_4core_7context_Context __pyx_vtable_3zmq_4core_7context_Context;
+
+static PyObject *__pyx_tp_new_3zmq_4core_7context_Context(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_3zmq_4core_7context_Context *p;
+  PyObject *o;
+  o = (*t->tp_alloc)(t, 0);
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_3zmq_4core_7context_Context *)o);
+  p->__pyx_vtab = __pyx_vtabptr_3zmq_4core_7context_Context;
+  p->__weakref__ = 0;
+  p->closed = Py_None; Py_INCREF(Py_None);
+  if (unlikely(__pyx_pw_3zmq_4core_7context_7Context_1__cinit__(o, a, k) < 0)) {
+    Py_DECREF(o); o = 0;
+  }
+  return o;
+}
+
+static void __pyx_tp_dealloc_3zmq_4core_7context_Context(PyObject *o) {
+  struct __pyx_obj_3zmq_4core_7context_Context *p = (struct __pyx_obj_3zmq_4core_7context_Context *)o;
+  PyObject_GC_UnTrack(o);
+  {
+    PyObject *etype, *eval, *etb;
+    PyErr_Fetch(&etype, &eval, &etb);
+    ++Py_REFCNT(o);
+    __pyx_pw_3zmq_4core_7context_7Context_7__dealloc__(o);
+    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
+    --Py_REFCNT(o);
+    PyErr_Restore(etype, eval, etb);
+  }
+  if (p->__weakref__) PyObject_ClearWeakRefs(o);
+  Py_CLEAR(p->closed);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static int __pyx_tp_traverse_3zmq_4core_7context_Context(PyObject *o, visitproc v, void *a) {
+  int e;
+  struct __pyx_obj_3zmq_4core_7context_Context *p = (struct __pyx_obj_3zmq_4core_7context_Context *)o;
+  if (p->closed) {
+    e = (*v)(p->closed, a); if (e) return e;
+  }
+  return 0;
+}
+
+static int __pyx_tp_clear_3zmq_4core_7context_Context(PyObject *o) {
+  struct __pyx_obj_3zmq_4core_7context_Context *p = (struct __pyx_obj_3zmq_4core_7context_Context *)o;
+  PyObject* tmp;
+  tmp = ((PyObject*)p->closed);
+  p->closed = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  return 0;
+}
+
+static PyObject *__pyx_getprop_3zmq_4core_7context_7Context_closed(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3zmq_4core_7context_7Context_6closed_1__get__(o);
+}
+
+static int __pyx_setprop_3zmq_4core_7context_7Context_closed(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
+  if (v) {
+    return __pyx_pw_3zmq_4core_7context_7Context_6closed_3__set__(o, v);
+  }
+  else {
+    return __pyx_pw_3zmq_4core_7context_7Context_6closed_5__del__(o);
+  }
+}
+
+static PyMethodDef __pyx_methods_3zmq_4core_7context_Context[] = {
+  {__Pyx_NAMESTR("__del__"), (PyCFunction)__pyx_pw_3zmq_4core_7context_7Context_5__del__, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7context_7Context_4__del__)},
+  {__Pyx_NAMESTR("_handle"), (PyCFunction)__pyx_pw_3zmq_4core_7context_7Context_9_handle, METH_NOARGS, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("term"), (PyCFunction)__pyx_pw_3zmq_4core_7context_7Context_11term, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7context_7Context_10term)},
+  {__Pyx_NAMESTR("set"), (PyCFunction)__pyx_pw_3zmq_4core_7context_7Context_13set, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7context_7Context_12set)},
+  {__Pyx_NAMESTR("get"), (PyCFunction)__pyx_pw_3zmq_4core_7context_7Context_15get, METH_O, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7context_7Context_14get)},
+  {__Pyx_NAMESTR("destroy"), (PyCFunction)__pyx_pw_3zmq_4core_7context_7Context_17destroy, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3zmq_4core_7context_7Context_16destroy)},
+  {0, 0, 0, 0}
+};
+
+static struct PyGetSetDef __pyx_getsets_3zmq_4core_7context_Context[] = {
+  {(char *)"closed", __pyx_getprop_3zmq_4core_7context_7Context_closed, __pyx_setprop_3zmq_4core_7context_7Context_closed, 0, 0},
+  {0, 0, 0, 0, 0}
+};
+
+static PyNumberMethods __pyx_tp_as_number_Context = {
+  0, /*nb_add*/
+  0, /*nb_subtract*/
+  0, /*nb_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_divide*/
+  #endif
+  0, /*nb_remainder*/
+  0, /*nb_divmod*/
+  0, /*nb_power*/
+  0, /*nb_negative*/
+  0, /*nb_positive*/
+  0, /*nb_absolute*/
+  0, /*nb_nonzero*/
+  0, /*nb_invert*/
+  0, /*nb_lshift*/
+  0, /*nb_rshift*/
+  0, /*nb_and*/
+  0, /*nb_xor*/
+  0, /*nb_or*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_coerce*/
+  #endif
+  0, /*nb_int*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_long*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*nb_float*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_oct*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_hex*/
+  #endif
+  0, /*nb_inplace_add*/
+  0, /*nb_inplace_subtract*/
+  0, /*nb_inplace_multiply*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*nb_inplace_divide*/
+  #endif
+  0, /*nb_inplace_remainder*/
+  0, /*nb_inplace_power*/
+  0, /*nb_inplace_lshift*/
+  0, /*nb_inplace_rshift*/
+  0, /*nb_inplace_and*/
+  0, /*nb_inplace_xor*/
+  0, /*nb_inplace_or*/
+  0, /*nb_floor_divide*/
+  0, /*nb_true_divide*/
+  0, /*nb_inplace_floor_divide*/
+  0, /*nb_inplace_true_divide*/
+  #if PY_VERSION_HEX >= 0x02050000
+  0, /*nb_index*/
+  #endif
+};
+
+static PySequenceMethods __pyx_tp_as_sequence_Context = {
+  0, /*sq_length*/
+  0, /*sq_concat*/
+  0, /*sq_repeat*/
+  0, /*sq_item*/
+  0, /*sq_slice*/
+  0, /*sq_ass_item*/
+  0, /*sq_ass_slice*/
+  0, /*sq_contains*/
+  0, /*sq_inplace_concat*/
+  0, /*sq_inplace_repeat*/
+};
+
+static PyMappingMethods __pyx_tp_as_mapping_Context = {
+  0, /*mp_length*/
+  0, /*mp_subscript*/
+  0, /*mp_ass_subscript*/
+};
+
+static PyBufferProcs __pyx_tp_as_buffer_Context = {
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getreadbuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getwritebuffer*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getsegcount*/
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  0, /*bf_getcharbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_getbuffer*/
+  #endif
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*bf_releasebuffer*/
+  #endif
+};
+
+static PyTypeObject __pyx_type_3zmq_4core_7context_Context = {
+  PyVarObject_HEAD_INIT(0, 0)
+  __Pyx_NAMESTR("zmq.core.context.Context"), /*tp_name*/
+  sizeof(struct __pyx_obj_3zmq_4core_7context_Context), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_3zmq_4core_7context_Context, /*tp_dealloc*/
+  0, /*tp_print*/
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #else
+  0, /*reserved*/
+  #endif
+  0, /*tp_repr*/
+  &__pyx_tp_as_number_Context, /*tp_as_number*/
+  &__pyx_tp_as_sequence_Context, /*tp_as_sequence*/
+  &__pyx_tp_as_mapping_Context, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  &__pyx_tp_as_buffer_Context, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  __Pyx_DOCSTR("Context(io_threads=1)\n\n    Manage the lifecycle of a 0MQ context.\n\n    Parameters\n    ----------\n    io_threads : int\n        The number of IO threads.\n    "), /*tp_doc*/
+  __pyx_tp_traverse_3zmq_4core_7context_Context, /*tp_traverse*/
+  __pyx_tp_clear_3zmq_4core_7context_Context, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_3zmq_4core_7context_Context, /*tp_methods*/
+  0, /*tp_members*/
+  __pyx_getsets_3zmq_4core_7context_Context, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  __pyx_pw_3zmq_4core_7context_7Context_3__init__, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_3zmq_4core_7context_Context, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  #if PY_VERSION_HEX >= 0x02060000
+  0, /*tp_version_tag*/
+  #endif
+};
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+  #if PY_VERSION_HEX < 0x03020000
+    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
+  #else
+    PyModuleDef_HEAD_INIT,
+  #endif
+    __Pyx_NAMESTR("context"),
+    __Pyx_DOCSTR(__pyx_k_10), /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 0},
+  {&__pyx_kp_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 0},
+  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
+  {&__pyx_kp_s_7, __pyx_k_7, sizeof(__pyx_k_7), 0, 0, 1, 0},
+  {&__pyx_n_s_9, __pyx_k_9, sizeof(__pyx_k_9), 0, 0, 1, 1},
+  {&__pyx_n_s__Again, __pyx_k__Again, sizeof(__pyx_k__Again), 0, 0, 1, 1},
+  {&__pyx_n_s__Context, __pyx_k__Context, sizeof(__pyx_k__Context), 0, 0, 1, 1},
+  {&__pyx_n_s__ContextTerminated, __pyx_k__ContextTerminated, sizeof(__pyx_k__ContextTerminated), 0, 0, 1, 1},
+  {&__pyx_n_s__MemoryError, __pyx_k__MemoryError, sizeof(__pyx_k__MemoryError), 0, 0, 1, 1},
+  {&__pyx_n_s__RuntimeError, __pyx_k__RuntimeError, sizeof(__pyx_k__RuntimeError), 0, 0, 1, 1},
+  {&__pyx_n_s__TypeError, __pyx_k__TypeError, sizeof(__pyx_k__TypeError), 0, 0, 1, 1},
+  {&__pyx_n_s__ZMQError, __pyx_k__ZMQError, sizeof(__pyx_k__ZMQError), 0, 0, 1, 1},
+  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
+  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
+  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
+  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
+  {&__pyx_n_s___handle, __pyx_k___handle, sizeof(__pyx_k___handle), 0, 0, 1, 1},
+  {&__pyx_n_s___instance, __pyx_k___instance, sizeof(__pyx_k___instance), 0, 0, 1, 1},
+  {&__pyx_n_s__io_threads, __pyx_k__io_threads, sizeof(__pyx_k__io_threads), 0, 0, 1, 1},
+  {&__pyx_n_s__linger, __pyx_k__linger, sizeof(__pyx_k__linger), 0, 0, 1, 1},
+  {&__pyx_n_s__option, __pyx_k__option, sizeof(__pyx_k__option), 0, 0, 1, 1},
+  {&__pyx_n_s__optval, __pyx_k__optval, sizeof(__pyx_k__optval), 0, 0, 1, 1},
+  {&__pyx_n_s__property, __pyx_k__property, sizeof(__pyx_k__property), 0, 0, 1, 1},
+  {&__pyx_n_s__range, __pyx_k__range, sizeof(__pyx_k__range), 0, 0, 1, 1},
+  {&__pyx_n_s__term, __pyx_k__term, sizeof(__pyx_k__term), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s__property); if (!__pyx_builtin_property) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s__MemoryError); if (!__pyx_builtin_MemoryError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s__range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s__RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s__TypeError); if (!__pyx_builtin_TypeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+static int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "zmq/core/context.pyx":76
+ *         self._sockets = <void **>malloc(self._max_sockets*sizeof(void *))
+ *         if self._sockets == NULL:
+ *             raise MemoryError("Could not allocate _sockets array")             # <<<<<<<<<<<<<<
+ * 
+ *         self._pid = getpid()
+ */
+  __pyx_k_tuple_2 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_1)); if (unlikely(!__pyx_k_tuple_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_2);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_2));
+
+  /* "zmq/core/context.pyx":108
+ *             self._sockets = <void **>realloc(self._sockets, self._max_sockets*sizeof(void *))
+ *             if self._sockets == NULL:
+ *                 raise MemoryError("Could not reallocate _sockets array")             # <<<<<<<<<<<<<<
+ * 
+ *         self._sockets[self._n_sockets] = handle
+ */
+  __pyx_k_tuple_4 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_4);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_4));
+
+  /* "zmq/core/context.pyx":181
+ * 
+ *         if self.closed:
+ *             raise RuntimeError("Context has been destroyed")             # <<<<<<<<<<<<<<
+ * 
+ *         if not isinstance(optval, int):
+ */
+  __pyx_k_tuple_6 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_5)); if (unlikely(!__pyx_k_tuple_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_6);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_6));
+
+  /* "zmq/core/context.pyx":217
+ * 
+ *         if self.closed:
+ *             raise RuntimeError("Context has been destroyed")             # <<<<<<<<<<<<<<
+ * 
+ *         rc = zmq_ctx_get(self.handle, option)
+ */
+  __pyx_k_tuple_8 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_5)); if (unlikely(!__pyx_k_tuple_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 217; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_k_tuple_8);
+  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_8));
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC initcontext(void); /*proto*/
+PyMODINIT_FUNC initcontext(void)
+#else
+PyMODINIT_FUNC PyInit_context(void); /*proto*/
+PyMODINIT_FUNC PyInit_context(void)
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_REFNANNY
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+  if (!__Pyx_RefNanny) {
+      PyErr_Clear();
+      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_RefNanny)
+          Py_FatalError("failed to import 'refnanny' module");
+  }
+  #endif
+  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_context(void)", 0);
+  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #ifdef __Pyx_CyFunction_USED
+  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("context"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_10), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  Py_INCREF(__pyx_d);
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!PyDict_GetItemString(modules, "zmq.core.context")) {
+      if (unlikely(PyDict_SetItemString(modules, "zmq.core.context", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+  }
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if CYTHON_COMPILING_IN_PYPY
+  Py_INCREF(__pyx_b);
+  #endif
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  #endif
+  if (__pyx_module_is_main_zmq__core__context) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Constants init code ---*/
+  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Global init code ---*/
+  /*--- Variable export code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  __pyx_vtabptr_3zmq_4core_7context_Context = &__pyx_vtable_3zmq_4core_7context_Context;
+  __pyx_vtable_3zmq_4core_7context_Context._add_socket = (void (*)(struct __pyx_obj_3zmq_4core_7context_Context *, void *))__pyx_f_3zmq_4core_7context_7Context__add_socket;
+  __pyx_vtable_3zmq_4core_7context_Context._remove_socket = (void (*)(struct __pyx_obj_3zmq_4core_7context_Context *, void *))__pyx_f_3zmq_4core_7context_7Context__remove_socket;
+  if (PyType_Ready(&__pyx_type_3zmq_4core_7context_Context) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetVtable(__pyx_type_3zmq_4core_7context_Context.tp_dict, __pyx_vtabptr_3zmq_4core_7context_Context) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__Pyx_SetAttrString(__pyx_m, "Context", (PyObject *)&__pyx_type_3zmq_4core_7context_Context) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (__pyx_type_3zmq_4core_7context_Context.tp_weaklistoffset == 0) __pyx_type_3zmq_4core_7context_Context.tp_weaklistoffset = offsetof(struct __pyx_obj_3zmq_4core_7context_Context, __weakref__);
+  __pyx_ptype_3zmq_4core_7context_Context = &__pyx_type_3zmq_4core_7context_Context;
+  /*--- Type import code ---*/
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
+  #if CYTHON_COMPILING_IN_PYPY
+  sizeof(PyTypeObject),
+  #else
+  sizeof(PyHeapTypeObject),
+  #endif
+  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), 0); if (unlikely(!__pyx_ptype_7cpython_4bool_bool)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), 0); if (unlikely(!__pyx_ptype_7cpython_7complex_complex)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_date = __Pyx_ImportType("datetime", "date", sizeof(PyDateTime_Date), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_date)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_time = __Pyx_ImportType("datetime", "time", sizeof(PyDateTime_Time), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_time)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_datetime = __Pyx_ImportType("datetime", "datetime", sizeof(PyDateTime_DateTime), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_datetime)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_timedelta = __Pyx_ImportType("datetime", "timedelta", sizeof(PyDateTime_Delta), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_timedelta)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7cpython_8datetime_tzinfo = __Pyx_ImportType("datetime", "tzinfo", sizeof(PyDateTime_TZInfo), 0); if (unlikely(!__pyx_ptype_7cpython_8datetime_tzinfo)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Variable import code ---*/
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "zmq/core/context.pyx":33
+ *     int getpid()
+ * 
+ * from zmq.error import ZMQError             # <<<<<<<<<<<<<<
+ * from zmq.core.checkrc cimport _check_rc
+ * 
+ */
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__ZMQError));
+  PyList_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__ZMQError));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ZMQError));
+  __pyx_t_2 = __Pyx_Import(((PyObject *)__pyx_n_s_9), ((PyObject *)__pyx_t_1), -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s__ZMQError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ZMQError, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "zmq/core/context.pyx":40
+ * #-----------------------------------------------------------------------------
+ * 
+ * _instance = None             # <<<<<<<<<<<<<<
+ * 
+ * cdef class Context:
+ */
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s___instance, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "zmq/core/context.pyx":134
+ * 
+ *     @property
+ *     def _handle(self):             # <<<<<<<<<<<<<<
+ *         return <Py_ssize_t> self.handle
+ * 
+ */
+  __pyx_t_2 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3zmq_4core_7context_Context, __pyx_n_s___handle); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_t_2 = PyObject_Call(__pyx_builtin_property, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3zmq_4core_7context_Context->tp_dict, __pyx_n_s___handle, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  PyType_Modified(__pyx_ptype_3zmq_4core_7context_Context);
+
+  /* "zmq/core/context.pyx":254
+ *             self.term()
+ * 
+ * __all__ = ['Context']             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_INCREF(((PyObject *)__pyx_n_s__Context));
+  PyList_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_n_s__Context));
+  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__Context));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____all__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+
+  /* "zmq/core/context.pyx":1
+ * """0MQ Context class."""             # <<<<<<<<<<<<<<
+ * 
+ * #
+ */
+  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+
+  /* "cpython/datetime.pxd":211
+ * 
+ * # Get microseconds of timedelta
+ * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
+ *     return (<PyDateTime_Delta*>o).microseconds
+ */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  if (__pyx_m) {
+    __Pyx_AddTraceback("init zmq.core.context", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    Py_DECREF(__pyx_m); __pyx_m = 0;
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init zmq.core.context");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+/* Runtime support code */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule((char *)modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif /* CYTHON_REFNANNY */
+
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name,
+    PyObject* kw_name)
+{
+    PyErr_Format(PyExc_TypeError,
+        #if PY_MAJOR_VERSION >= 3
+        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
+        #else
+        "%s() got multiple values for keyword argument '%s'", func_name,
+        PyString_AsString(kw_name));
+        #endif
+}
+
+static int __Pyx_ParseOptionalKeywords(
+    PyObject *kwds,
+    PyObject **argnames[],
+    PyObject *kwds2,
+    PyObject *values[],
+    Py_ssize_t num_pos_args,
+    const char* function_name)
+{
+    PyObject *key = 0, *value = 0;
+    Py_ssize_t pos = 0;
+    PyObject*** name;
+    PyObject*** first_kw_arg = argnames + num_pos_args;
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
+        name = first_kw_arg;
+        while (*name && (**name != key)) name++;
+        if (*name) {
+            values[name-argnames] = value;
+            continue;
+        }
+        name = first_kw_arg;
+        #if PY_MAJOR_VERSION < 3
+        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
+            while (*name) {
+                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
+                        && _PyString_Eq(**name, key)) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    if ((**argname == key) || (
+                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
+                             && _PyString_Eq(**argname, key))) {
+                        goto arg_passed_twice;
+                    }
+                    argname++;
+                }
+            }
+        } else
+        #endif
+        if (likely(PyUnicode_Check(key))) {
+            while (*name) {
+                int cmp = (**name == key) ? 0 :
+                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
+                #endif
+                    PyUnicode_Compare(**name, key);
+                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                if (cmp == 0) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    int cmp = (**argname == key) ? 0 :
+                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
+                    #endif
+                        PyUnicode_Compare(**argname, key);
+                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                    if (cmp == 0) goto arg_passed_twice;
+                    argname++;
+                }
+            }
+        } else
+            goto invalid_keyword_type;
+        if (kwds2) {
+            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+        } else {
+            goto invalid_keyword;
+        }
+    }
+    return 0;
+arg_passed_twice:
+    __Pyx_RaiseDoubleKeywordsError(function_name, key);
+    goto bad;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%s() keywords must be strings", function_name);
+    goto bad;
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%s() got an unexpected keyword argument '%s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+bad:
+    return -1;
+}
+
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
+}
+
+static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON
+    result = PyDict_GetItem(__pyx_d, name);
+    if (result) {
+        Py_INCREF(result);
+    } else {
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    if (!result) {
+        PyErr_Clear();
+#endif
+        result = __Pyx_GetBuiltinName(name);
+    }
+    return result;
+}
+
+static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_Restore(type, value, tb);
+#endif
+}
+static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(type, value, tb);
+#endif
+}
+
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
+    Py_XINCREF(type);
+    if (!value || value == Py_None)
+        value = NULL;
+    else
+        Py_INCREF(value);
+    if (!tb || tb == Py_None)
+        tb = NULL;
+    else {
+        Py_INCREF(tb);
+        if (!PyTraceBack_Check(tb)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: arg 3 must be a traceback or None");
+            goto raise_error;
+        }
+    }
+    #if PY_VERSION_HEX < 0x02050000
+    if (PyClass_Check(type)) {
+    #else
+    if (PyType_Check(type)) {
+    #endif
+#if CYTHON_COMPILING_IN_PYPY
+        if (!value) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+#endif
+        PyErr_NormalizeException(&type, &value, &tb);
+    } else {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        value = type;
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyInstance_Check(type)) {
+            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+            Py_INCREF(type);
+        } else {
+            type = 0;
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception must be an old-style class or instance");
+            goto raise_error;
+        }
+        #else
+        type = (PyObject*) Py_TYPE(type);
+        Py_INCREF(type);
+        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception class must be a subclass of BaseException");
+            goto raise_error;
+        }
+        #endif
+    }
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+#else /* Python 3+ */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    PyObject* owned_instance = NULL;
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
+    }
+    if (value == Py_None)
+        value = 0;
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (PyExceptionClass_Check(type)) {
+        PyObject *args;
+        if (!value)
+            args = PyTuple_New(0);
+        else if (PyTuple_Check(value)) {
+            Py_INCREF(value);
+            args = value;
+        } else
+            args = PyTuple_Pack(1, value);
+        if (!args)
+            goto bad;
+        owned_instance = PyEval_CallObject(type, args);
+        Py_DECREF(args);
+        if (!owned_instance)
+            goto bad;
+        value = owned_instance;
+        if (!PyExceptionInstance_Check(value)) {
+            PyErr_Format(PyExc_TypeError,
+                         "calling %R should have returned an instance of "
+                         "BaseException, not %R",
+                         type, Py_TYPE(value));
+            goto bad;
+        }
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
+    }
+#if PY_VERSION_HEX >= 0x03030000
+    if (cause) {
+#else
+    if (cause && cause != Py_None) {
+#endif
+        PyObject *fixed_cause;
+        if (cause == Py_None) {
+            fixed_cause = NULL;
+        } else if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        } else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+    PyErr_SetObject(type, value);
+    if (tb) {
+        PyThreadState *tstate = PyThreadState_GET();
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
+    }
+bad:
+    Py_XDECREF(owned_instance);
+    return;
+}
+#endif
+
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name) {
+    PyObject *result;
+    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
+    if (!result)
+        result = __Pyx_GetModuleGlobalName(name);
+    return result;
+}
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_VERSION_HEX < 0x03030000
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    #if PY_VERSION_HEX >= 0x02050000
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if (strchr(__Pyx_MODULE_NAME, '.')) {
+                #if PY_VERSION_HEX < 0x03030000
+                PyObject *py_level = PyInt_FromLong(1);
+                if (!py_level)
+                    goto bad;
+                module = PyObject_CallFunctionObjArgs(py_import,
+                    name, global_dict, empty_dict, list, py_level, NULL);
+                Py_DECREF(py_level);
+                #else
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                #endif
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0; /* try absolute import on failure */
+        }
+        #endif
+        if (!module) {
+            #if PY_VERSION_HEX < 0x03030000
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+    #else
+    if (level>0) {
+        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
+        goto bad;
+    }
+    module = PyObject_CallFunctionObjArgs(py_import,
+        name, global_dict, empty_dict, list, NULL);
+    #endif
+bad:
+    #if PY_VERSION_HEX < 0x03030000
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned char" :
+                    "value too large to convert to unsigned char");
+            }
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned short" :
+                    "value too large to convert to unsigned short");
+            }
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to unsigned int" :
+                    "value too large to convert to unsigned int");
+            }
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    const char neg_one = (char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to char" :
+                    "value too large to convert to char");
+            }
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    const short neg_one = (short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to short" :
+                    "value too large to convert to short");
+            }
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    const signed char neg_one = (signed char)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed char" :
+                    "value too large to convert to signed char");
+            }
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    const signed short neg_one = (signed short)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed short" :
+                    "value too large to convert to signed short");
+            }
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    const signed int neg_one = (signed int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to signed int" :
+                    "value too large to convert to signed int");
+            }
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
+    const int neg_one = (int)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (!unlikely(val == -1 && PyErr_Occurred())) {
+                PyErr_SetString(PyExc_OverflowError,
+                    (is_unsigned && unlikely(val < 0)) ?
+                    "can't convert negative value to int" :
+                    "value too large to convert to int");
+            }
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned long");
+                return (unsigned long)-1;
+            }
+            return (unsigned long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned long)PyLong_AsLong(x);
+        }
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned PY_LONG_LONG");
+                return (unsigned PY_LONG_LONG)-1;
+            }
+            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+    const long neg_one = (long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to long");
+            return (long)-1;
+        }
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to long");
+                return (long)-1;
+            }
+            return (long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (long)PyLong_AsLong(x);
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to PY_LONG_LONG");
+            return (PY_LONG_LONG)-1;
+        }
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to PY_LONG_LONG");
+                return (PY_LONG_LONG)-1;
+            }
+            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+    const signed long neg_one = (signed long)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed long");
+            return (signed long)-1;
+        }
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed long");
+                return (signed long)-1;
+            }
+            return (signed long)PyLong_AsUnsignedLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed long)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed long)PyLong_AsLong(x);
+        }
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+#include "longintrepr.h"
+#endif
+#endif
+static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (is_unsigned && unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to signed PY_LONG_LONG");
+            return (signed PY_LONG_LONG)-1;
+        }
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            if (unlikely(Py_SIZE(x) < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to signed PY_LONG_LONG");
+                return (signed PY_LONG_LONG)-1;
+            }
+            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
+        } else {
+#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
+#if CYTHON_USE_PYLONG_INTERNALS
+            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
+                switch (Py_SIZE(x)) {
+                    case  0: return 0;
+                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
+                }
+            }
+#endif
+#endif
+            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
+        }
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
+                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename) {
+    PyObject *old_exc, *old_val, *old_tb;
+    PyObject *ctx;
+    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
+    #if PY_MAJOR_VERSION < 3
+    ctx = PyString_FromString(name);
+    #else
+    ctx = PyUnicode_FromString(name);
+    #endif
+    __Pyx_ErrRestore(old_exc, old_val, old_tb);
+    if (!ctx) {
+        PyErr_WriteUnraisable(Py_None);
+    } else {
+        PyErr_WriteUnraisable(ctx);
+        Py_DECREF(ctx);
+    }
+}
+
+static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        #if PY_VERSION_HEX < 0x02050000
+        return PyErr_Warn(NULL, message);
+        #else
+        return PyErr_WarnEx(NULL, message, 1);
+        #endif
+    }
+    return 0;
+}
+
+static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
+#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
+    PyObject *ob = PyCapsule_New(vtable, 0, 0);
+#else
+    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
+#endif
+    if (!ob)
+        goto bad;
+    if (PyDict_SetItemString(dict, "__pyx_vtable__", ob) < 0)
+        goto bad;
+    Py_DECREF(ob);
+    return 0;
+bad:
+    Py_XDECREF(ob);
+    return -1;
+}
+
+#ifndef __PYX_HAVE_RT_ImportModule
+#define __PYX_HAVE_RT_ImportModule
+static PyObject *__Pyx_ImportModule(const char *name) {
+    PyObject *py_name = 0;
+    PyObject *py_module = 0;
+    py_name = __Pyx_PyIdentifier_FromString(name);
+    if (!py_name)
+        goto bad;
+    py_module = PyImport_Import(py_name);
+    Py_DECREF(py_name);
+    return py_module;
+bad:
+    Py_XDECREF(py_name);
+    return 0;
+}
+#endif
+
+#ifndef __PYX_HAVE_RT_ImportType
+#define __PYX_HAVE_RT_ImportType
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
+    size_t size, int strict)
+{
+    PyObject *py_module = 0;
+    PyObject *result = 0;
+    PyObject *py_name = 0;
+    char warning[200];
+    Py_ssize_t basicsize;
+#ifdef Py_LIMITED_API
+    PyObject *py_basicsize;
+#endif
+    py_module = __Pyx_ImportModule(module_name);
+    if (!py_module)
+        goto bad;
+    py_name = __Pyx_PyIdentifier_FromString(class_name);
+    if (!py_name)
+        goto bad;
+    result = PyObject_GetAttr(py_module, py_name);
+    Py_DECREF(py_name);
+    py_name = 0;
+    Py_DECREF(py_module);
+    py_module = 0;
+    if (!result)
+        goto bad;
+    if (!PyType_Check(result)) {
+        PyErr_Format(PyExc_TypeError,
+            "%s.%s is not a type object",
+            module_name, class_name);
+        goto bad;
+    }
+#ifndef Py_LIMITED_API
+    basicsize = ((PyTypeObject *)result)->tp_basicsize;
+#else
+    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
+    if (!py_basicsize)
+        goto bad;
+    basicsize = PyLong_AsSsize_t(py_basicsize);
+    Py_DECREF(py_basicsize);
+    py_basicsize = 0;
+    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
+#endif
+    if (!strict && (size_t)basicsize > size) {
+        PyOS_snprintf(warning, sizeof(warning),
+            "%s.%s size changed, may indicate binary incompatibility",
+            module_name, class_name);
+        #if PY_VERSION_HEX < 0x02050000
+        if (PyErr_Warn(NULL, warning) < 0) goto bad;
+        #else
+        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
+        #endif
+    }
+    else if ((size_t)basicsize != size) {
+        PyErr_Format(PyExc_ValueError,
+            "%s.%s has the wrong size, try recompiling",
+            module_name, class_name);
+        goto bad;
+    }
+    return (PyTypeObject *)result;
+bad:
+    Py_XDECREF(py_module);
+    Py_XDECREF(result);
+    return NULL;
+}
+#endif
+
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = (start + end) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(filename);
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_code = __Pyx_PyCode_New(
+        0,            /*int argcount,*/
+        0,            /*int kwonlyargcount,*/
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,      /*int firstlineno,*/
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    Py_DECREF(py_funcname);
+    return py_code;
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyObject *py_globals = 0;
+    PyFrameObject *py_frame = 0;
+    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
+    if (!py_code) {
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) goto bad;
+        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
+    }
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = py_line;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+#if PY_VERSION_HEX < 0x03030000
+        char* defenc_c;
+        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+        if (!defenc) return NULL;
+        defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        {
+            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+            char* c;
+            for (c = defenc_c; c < end; c++) {
+                if ((unsigned char) (*c) >= 128) {
+                    PyUnicode_AsASCIIString(o);
+                    return NULL;
+                }
+            }
+        }
+#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
+        *length = PyBytes_GET_SIZE(defenc);
+        return defenc_c;
+#else /* PY_VERSION_HEX < 0x03030000 */
+        if (PyUnicode_READY(o) == -1) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+        if (PyUnicode_IS_ASCII(o)) {
+            *length = PyUnicode_GET_DATA_SIZE(o);
+            return PyUnicode_AsUTF8(o);
+        } else {
+            PyUnicode_AsASCIIString(o);
+            return NULL;
+        }
+#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+        return PyUnicode_AsUTF8AndSize(o, length);
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
+#endif /* PY_VERSION_HEX < 0x03030000 */
+    } else
+#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (r < 0) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_MAJOR_VERSION < 3
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
+           PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
+#endif /* Py_PYTHON_H */
